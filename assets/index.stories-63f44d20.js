var mn=Object.defineProperty;var xn=(e,n,t)=>n in e?mn(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t;var z=(e,n,t)=>(xn(e,typeof n!="symbol"?n+"":n,t),t),wn=(e,n,t)=>{if(!n.has(e))throw TypeError("Cannot "+t)};var K=(e,n,t)=>(wn(e,n,"read from private field"),t?t.call(e):n.get(e)),Ht=(e,n,t)=>{if(n.has(e))throw TypeError("Cannot add the same private member more than once");n instanceof WeakSet?n.add(e):n.set(e,t)};import{x as bn,d as O,R as ln,y as fn,V as I,z as un,L as k,T as ft,F as An,r as dt,J as Pn,D as Tn,K as ot,N as Xt,U as vn,M as pn,W as Yt,u as Bn,s as gn,c as Sn}from"./setup-f1b0c42e.js";var q;class Mn extends bn{constructor(t){super();z(this,"camera");z(this,"raycaster");z(this,"objects",[]);z(this,"pointerDown",new O);z(this,"pointerUp",new O);z(this,"pointerMove",new O);z(this,"recursive",!0);z(this,"renderer");Ht(this,q,{click:0,move:0});z(this,"onPointerDown",t=>{this.getNormalizedCoordinates(t,this.pointerDown)});z(this,"onPointerUp",t=>{if(this.camera===void 0||(this.getNormalizedCoordinates(t,this.pointerUp),this.pointerDown.sub(this.pointerUp).lengthSq()>.001))return;this.raycaster.setFromCamera(this.pointerUp,this.camera);const s=this.raycaster.intersectObjects(this.objects,this.recursive);this.dispatchEvent({type:"click",intersections:s})});z(this,"onPointerMove",t=>{if(this.camera===void 0)return;this.getNormalizedCoordinates(t,this.pointerMove),this.raycaster.setFromCamera(this.pointerMove,this.camera);const s=this.raycaster.intersectObjects(this.objects,this.recursive);this.dispatchEvent({type:"move",intersections:s})});this.camera=t.camera,this.renderer=t.renderer,this.raycaster=t.raycaster??new ln,this.objects=t.objects??(t.scene?[t.scene]:[]),this.recursive=t.recursive??!0}on(t,s){super.addEventListener(t,s);const i=this.renderer.domElement;t==="move"&&K(this,q).move===0?i.addEventListener("pointermove",this.onPointerMove,{passive:!0}):t==="click"&&K(this,q).click===0&&(i.addEventListener("pointerdown",this.onPointerDown,{passive:!0}),i.addEventListener("pointerup",this.onPointerUp,{passive:!0})),K(this,q)[t]+=1}off(t,s){super.removeEventListener(t,s);const i=this.renderer.domElement;K(this,q)[t]-=1,t==="move"&&K(this,q).move<=0?i.removeEventListener("pointermove",this.onPointerMove):t==="click"&&K(this,q).click<=0&&(i.addEventListener("pointerdown",this.onPointerDown,{passive:!0}),i.addEventListener("pointerup",this.onPointerUp,{passive:!0}))}getNormalizedCoordinates(t,s){const i=this.renderer.domElement,o=i.getBoundingClientRect();s.x=(t.clientX-o.x)/i.clientWidth*2-1,s.y=-((t.clientY-o.y)/i.clientHeight*2)+1}dispose(){const t=this.renderer.domElement;t.removeEventListener("pointerdown",this.onPointerDown),t.removeEventListener("pointerup",this.onPointerUp),t.removeEventListener("pointermove",this.onPointerMove)}}q=new WeakMap;const dn=0,In=1,Cn=2,Zt=2,Lt=1.25,Wt=1,It=6*4+4+4,Vt=65535,En=Math.pow(2,-24);class wt{constructor(){}}function R(e,n,t){return t.min.x=n[e],t.min.y=n[e+1],t.min.z=n[e+2],t.max.x=n[e+3],t.max.y=n[e+4],t.max.z=n[e+5],t}function Fn(e){e[0]=e[1]=e[2]=1/0,e[3]=e[4]=e[5]=-1/0}function Kt(e){let n=-1,t=-1/0;for(let s=0;s<3;s++){const i=e[s+3]-e[s];i>t&&(t=i,n=s)}return n}function $t(e,n){n.set(e)}function Jt(e,n,t){let s,i;for(let o=0;o<3;o++){const r=o+3;s=e[o],i=n[o],t[o]=s<i?s:i,s=e[r],i=n[r],t[r]=s>i?s:i}}function bt(e,n,t){for(let s=0;s<3;s++){const i=n[e+2*s],o=n[e+2*s+1],r=i-o,l=i+o;r<t[s]&&(t[s]=r),l>t[s+3]&&(t[s+3]=l)}}function ct(e){const n=e[3]-e[0],t=e[4]-e[1],s=e[5]-e[2];return 2*(n*t+t*s+s*n)}function Ln(e,n){if(!e.index){const t=e.attributes.position.count,s=n.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;let i;t>65535?i=new Uint32Array(new s(4*t)):i=new Uint16Array(new s(2*t)),e.setIndex(new fn(i,1));for(let o=0;o<t;o++)i[o]=o}}function zn(e){if(!e.groups||!e.groups.length)return[{offset:0,count:e.index.count/3}];const n=[],t=new Set;for(const i of e.groups)t.add(i.start),t.add(i.start+i.count);const s=Array.from(t.values()).sort((i,o)=>i-o);for(let i=0;i<s.length-1;i++){const o=s[i],r=s[i+1];n.push({offset:o/3,count:(r-o)/3})}return n}function zt(e,n,t,s,i=null){let o=1/0,r=1/0,l=1/0,c=-1/0,f=-1/0,u=-1/0,d=1/0,a=1/0,h=1/0,P=-1/0,g=-1/0,m=-1/0;const p=i!==null;for(let x=n*6,y=(n+t)*6;x<y;x+=6){const b=e[x+0],w=e[x+1],A=b-w,v=b+w;A<o&&(o=A),v>c&&(c=v),p&&b<d&&(d=b),p&&b>P&&(P=b);const B=e[x+2],T=e[x+3],S=B-T,M=B+T;S<r&&(r=S),M>f&&(f=M),p&&B<a&&(a=B),p&&B>g&&(g=B);const C=e[x+4],E=e[x+5],F=C-E,L=C+E;F<l&&(l=F),L>u&&(u=L),p&&C<h&&(h=C),p&&C>m&&(m=C)}s[0]=o,s[1]=r,s[2]=l,s[3]=c,s[4]=f,s[5]=u,p&&(i[0]=d,i[1]=a,i[2]=h,i[3]=P,i[4]=g,i[5]=m)}function Un(e,n,t,s){let i=1/0,o=1/0,r=1/0,l=-1/0,c=-1/0,f=-1/0;for(let u=n*6,d=(n+t)*6;u<d;u+=6){const a=e[u+0];a<i&&(i=a),a>l&&(l=a);const h=e[u+2];h<o&&(o=h),h>c&&(c=h);const P=e[u+4];P<r&&(r=P),P>f&&(f=P)}s[0]=i,s[1]=o,s[2]=r,s[3]=l,s[4]=c,s[5]=f}function Dn(e,n,t,s,i){let o=t,r=t+s-1;const l=i.pos,c=i.axis*2;for(;;){for(;o<=r&&n[o*6+c]<l;)o++;for(;o<=r&&n[r*6+c]>=l;)r--;if(o<r){for(let f=0;f<3;f++){let u=e[o*3+f];e[o*3+f]=e[r*3+f],e[r*3+f]=u;let d=n[o*6+f*2+0];n[o*6+f*2+0]=n[r*6+f*2+0],n[r*6+f*2+0]=d;let a=n[o*6+f*2+1];n[o*6+f*2+1]=n[r*6+f*2+1],n[r*6+f*2+1]=a}o++,r--}else return o}}const V=32,_n=(e,n)=>e.candidate-n.candidate,X=new Array(V).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),At=new Float32Array(6);function Rn(e,n,t,s,i,o){let r=-1,l=0;if(o===dn)r=Kt(n),r!==-1&&(l=(n[r]+n[r+3])/2);else if(o===In)r=Kt(e),r!==-1&&(l=Nn(t,s,i,r));else if(o===Cn){const c=ct(e);let f=Lt*i;const u=s*6,d=(s+i)*6;for(let a=0;a<3;a++){const h=n[a],m=(n[a+3]-h)/V;if(i<V/4){const p=[...X];p.length=i;let x=0;for(let b=u;b<d;b+=6,x++){const w=p[x];w.candidate=t[b+2*a],w.count=0;const{bounds:A,leftCacheBounds:v,rightCacheBounds:B}=w;for(let T=0;T<3;T++)B[T]=1/0,B[T+3]=-1/0,v[T]=1/0,v[T+3]=-1/0,A[T]=1/0,A[T+3]=-1/0;bt(b,t,A)}p.sort(_n);let y=i;for(let b=0;b<y;b++){const w=p[b];for(;b+1<y&&p[b+1].candidate===w.candidate;)p.splice(b+1,1),y--}for(let b=u;b<d;b+=6){const w=t[b+2*a];for(let A=0;A<y;A++){const v=p[A];w>=v.candidate?bt(b,t,v.rightCacheBounds):(bt(b,t,v.leftCacheBounds),v.count++)}}for(let b=0;b<y;b++){const w=p[b],A=w.count,v=i-w.count,B=w.leftCacheBounds,T=w.rightCacheBounds;let S=0;A!==0&&(S=ct(B)/c);let M=0;v!==0&&(M=ct(T)/c);const C=Wt+Lt*(S*A+M*v);C<f&&(r=a,f=C,l=w.candidate)}}else{for(let y=0;y<V;y++){const b=X[y];b.count=0,b.candidate=h+m+y*m;const w=b.bounds;for(let A=0;A<3;A++)w[A]=1/0,w[A+3]=-1/0}for(let y=u;y<d;y+=6){let A=~~((t[y+2*a]-h)/m);A>=V&&(A=V-1);const v=X[A];v.count++,bt(y,t,v.bounds)}const p=X[V-1];$t(p.bounds,p.rightCacheBounds);for(let y=V-2;y>=0;y--){const b=X[y],w=X[y+1];Jt(b.bounds,w.rightCacheBounds,b.rightCacheBounds)}let x=0;for(let y=0;y<V-1;y++){const b=X[y],w=b.count,A=b.bounds,B=X[y+1].rightCacheBounds;w!==0&&(x===0?$t(A,At):Jt(A,At,At)),x+=w;let T=0,S=0;x!==0&&(T=ct(At)/c);const M=i-x;M!==0&&(S=ct(B)/c);const C=Wt+Lt*(T*x+S*M);C<f&&(r=a,f=C,l=b.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${o} used.`);return{axis:r,pos:l}}function Nn(e,n,t,s){let i=0;for(let o=n,r=n+t;o<r;o++)i+=e[o*6+s*2];return i/t}function Vn(e,n){Fn(n);const t=e.attributes.position,s=e.index.array,i=s.length/3,o=new Float32Array(i*6),r=t.normalized,l=t.array,c=t.offset||0;let f=3;t.isInterleavedBufferAttribute&&(f=t.data.stride);const u=["getX","getY","getZ"];for(let d=0;d<i;d++){const a=d*3,h=d*6;let P,g,m;r?(P=s[a+0],g=s[a+1],m=s[a+2]):(P=s[a+0]*f+c,g=s[a+1]*f+c,m=s[a+2]*f+c);for(let p=0;p<3;p++){let x,y,b;r?(x=t[u[p]](P),y=t[u[p]](g),b=t[u[p]](m)):(x=l[P+p],y=l[g+p],b=l[m+p]);let w=x;y<w&&(w=y),b<w&&(w=b);let A=x;y>A&&(A=y),b>A&&(A=b);const v=(A-w)/2,B=p*2;o[h+B+0]=w+v,o[h+B+1]=v+(Math.abs(w)+v)*En,w<n[p]&&(n[p]=w),A>n[p+3]&&(n[p+3]=A)}}return o}function qn(e,n){function t(p){a&&a(p/h)}function s(p,x,y,b=null,w=0){if(!P&&w>=c&&(P=!0,f&&(console.warn(`MeshBVH: Max depth of ${c} reached when generating BVH. Consider increasing maxDepth.`),console.warn(e))),y<=u||w>=c)return t(x+y),p.offset=x,p.count=y,p;const A=Rn(p.boundingData,b,r,x,y,d);if(A.axis===-1)return t(x+y),p.offset=x,p.count=y,p;const v=Dn(l,r,x,y,A);if(v===x||v===x+y)t(x+y),p.offset=x,p.count=y;else{p.splitAxis=A.axis;const B=new wt,T=x,S=v-x;p.left=B,B.boundingData=new Float32Array(6),zt(r,T,S,B.boundingData,o),s(B,T,S,o,w+1);const M=new wt,C=v,E=y-S;p.right=M,M.boundingData=new Float32Array(6),zt(r,C,E,M.boundingData,o),s(M,C,E,o,w+1)}return p}Ln(e,n);const i=new Float32Array(6),o=new Float32Array(6),r=Vn(e,i),l=e.index.array,c=n.maxDepth,f=n.verbose,u=n.maxLeafTris,d=n.strategy,a=n.onProgress,h=e.index.count/3;let P=!1;const g=[],m=zn(e);if(m.length===1){const p=m[0],x=new wt;x.boundingData=i,Un(r,p.offset,p.count,o),s(x,p.offset,p.count,o),g.push(x)}else for(let p of m){const x=new wt;x.boundingData=new Float32Array(6),zt(r,p.offset,p.count,x.boundingData,o),s(x,p.offset,p.count,o),g.push(x)}return g}function On(e,n){const t=qn(e,n);let s,i,o;const r=[],l=n.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;for(let u=0;u<t.length;u++){const d=t[u];let a=c(d);const h=new l(It*a);s=new Float32Array(h),i=new Uint32Array(h),o=new Uint16Array(h),f(0,d),r.push(h)}return r;function c(u){return u.count?1:1+c(u.left)+c(u.right)}function f(u,d){const a=u/4,h=u/2,P=!!d.count,g=d.boundingData;for(let m=0;m<6;m++)s[a+m]=g[m];if(P){const m=d.offset,p=d.count;return i[a+6]=m,o[h+14]=p,o[h+15]=Vt,u+It}else{const m=d.left,p=d.right,x=d.splitAxis;let y;if(y=f(u+It,m),y/4>Math.pow(2,32))throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return i[a+6]=y/4,y=f(y,p),i[a+7]=x,y}}}class j{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(n,t){let s=1/0,i=-1/0;for(let o=0,r=n.length;o<r;o++){const c=n[o][t];s=c<s?c:s,i=c>i?c:i}this.min=s,this.max=i}setFromPoints(n,t){let s=1/0,i=-1/0;for(let o=0,r=t.length;o<r;o++){const l=t[o],c=n.dot(l);s=c<s?c:s,i=c>i?c:i}this.min=s,this.max=i}isSeparated(n){return this.min>n.max||n.min>this.max}}j.prototype.setFromBox=function(){const e=new I;return function(t,s){const i=s.min,o=s.max;let r=1/0,l=-1/0;for(let c=0;c<=1;c++)for(let f=0;f<=1;f++)for(let u=0;u<=1;u++){e.x=i.x*c+o.x*(1-c),e.y=i.y*f+o.y*(1-f),e.z=i.z*u+o.z*(1-u);const d=t.dot(e);r=Math.min(d,r),l=Math.max(d,l)}this.min=r,this.max=l}}();const kn=function(){const e=new I,n=new I,t=new I;return function(i,o,r){const l=i.start,c=e,f=o.start,u=n;t.subVectors(l,f),e.subVectors(i.end,i.start),n.subVectors(o.end,o.start);const d=t.dot(u),a=u.dot(c),h=u.dot(u),P=t.dot(c),m=c.dot(c)*h-a*a;let p,x;m!==0?p=(d*a-P*h)/m:p=0,x=(d+p*a)/h,r.x=p,r.y=x}}(),jt=function(){const e=new O,n=new I,t=new I;return function(i,o,r,l){kn(i,o,e);let c=e.x,f=e.y;if(c>=0&&c<=1&&f>=0&&f<=1){i.at(c,r),o.at(f,l);return}else if(c>=0&&c<=1){f<0?o.at(0,l):o.at(1,l),i.closestPointToPoint(l,!0,r);return}else if(f>=0&&f<=1){c<0?i.at(0,r):i.at(1,r),o.closestPointToPoint(r,!0,l);return}else{let u;c<0?u=i.start:u=i.end;let d;f<0?d=o.start:d=o.end;const a=n,h=t;if(i.closestPointToPoint(d,!0,n),o.closestPointToPoint(u,!0,t),a.distanceToSquared(d)<=h.distanceToSquared(u)){r.copy(a),l.copy(d);return}else{r.copy(u),l.copy(h);return}}}}(),jn=function(){const e=new I,n=new I,t=new un,s=new k;return function(o,r){const{radius:l,center:c}=o,{a:f,b:u,c:d}=r;if(s.start=f,s.end=u,s.closestPointToPoint(c,!0,e).distanceTo(c)<=l||(s.start=f,s.end=d,s.closestPointToPoint(c,!0,e).distanceTo(c)<=l)||(s.start=u,s.end=d,s.closestPointToPoint(c,!0,e).distanceTo(c)<=l))return!0;const g=r.getPlane(t);if(Math.abs(g.distanceToPoint(c))<=l){const p=g.projectPoint(c,n);if(r.containsPoint(p))return!0}return!1}}(),Hn=1e-15;function Ut(e){return Math.abs(e)<Hn}class H extends ft{constructor(...n){super(...n),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new I),this.satBounds=new Array(4).fill().map(()=>new j),this.points=[this.a,this.b,this.c],this.sphere=new An,this.plane=new un,this.needsUpdate=!0}intersectsSphere(n){return jn(n,this)}update(){const n=this.a,t=this.b,s=this.c,i=this.points,o=this.satAxes,r=this.satBounds,l=o[0],c=r[0];this.getNormal(l),c.setFromPoints(l,i);const f=o[1],u=r[1];f.subVectors(n,t),u.setFromPoints(f,i);const d=o[2],a=r[2];d.subVectors(t,s),a.setFromPoints(d,i);const h=o[3],P=r[3];h.subVectors(s,n),P.setFromPoints(h,i),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(l,n),this.needsUpdate=!1}}H.prototype.closestPointToSegment=function(){const e=new I,n=new I,t=new k;return function(i,o=null,r=null){const{start:l,end:c}=i,f=this.points;let u,d=1/0;for(let a=0;a<3;a++){const h=(a+1)%3;t.start.copy(f[a]),t.end.copy(f[h]),jt(t,i,e,n),u=e.distanceToSquared(n),u<d&&(d=u,o&&o.copy(e),r&&r.copy(n))}return this.closestPointToPoint(l,e),u=l.distanceToSquared(e),u<d&&(d=u,o&&o.copy(e),r&&r.copy(l)),this.closestPointToPoint(c,e),u=c.distanceToSquared(e),u<d&&(d=u,o&&o.copy(e),r&&r.copy(c)),Math.sqrt(d)}}();H.prototype.intersectsTriangle=function(){const e=new H,n=new Array(3),t=new Array(3),s=new j,i=new j,o=new I,r=new I,l=new I,c=new I,f=new I,u=new k,d=new k,a=new k,h=new I;function P(g,m,p){const x=g.points;let y=0,b=-1;for(let w=0;w<3;w++){const{start:A,end:v}=u;A.copy(x[w]),v.copy(x[(w+1)%3]),u.delta(r);const B=Ut(m.distanceToPoint(A));if(Ut(m.normal.dot(r))&&B){p.copy(u),y=2;break}const T=m.intersectLine(u,h);if(!T&&B&&h.copy(A),(T||B)&&!Ut(h.distanceTo(v))){if(y<=1)(y===1?p.start:p.end).copy(h),B&&(b=y);else if(y>=2){(b===1?p.start:p.end).copy(h),y=2;break}if(y++,y===2&&b===-1)break}}return y}return function(m,p=null,x=!1){this.needsUpdate&&this.update(),m.isExtendedTriangle?m.needsUpdate&&m.update():(e.copy(m),e.update(),m=e);const y=this.plane,b=m.plane;if(Math.abs(y.normal.dot(b.normal))>1-1e-10){const w=this.satBounds,A=this.satAxes;t[0]=m.a,t[1]=m.b,t[2]=m.c;for(let T=0;T<4;T++){const S=w[T],M=A[T];if(s.setFromPoints(M,t),S.isSeparated(s))return!1}const v=m.satBounds,B=m.satAxes;n[0]=this.a,n[1]=this.b,n[2]=this.c;for(let T=0;T<4;T++){const S=v[T],M=B[T];if(s.setFromPoints(M,n),S.isSeparated(s))return!1}for(let T=0;T<4;T++){const S=A[T];for(let M=0;M<4;M++){const C=B[M];if(o.crossVectors(S,C),s.setFromPoints(o,n),i.setFromPoints(o,t),s.isSeparated(i))return!1}}return p&&(x||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),p.start.set(0,0,0),p.end.set(0,0,0)),!0}else{const w=P(this,b,d);if(w===1&&m.containsPoint(d.end))return p&&(p.start.copy(d.end),p.end.copy(d.end)),!0;if(w!==2)return!1;const A=P(m,y,a);if(A===1&&this.containsPoint(a.end))return p&&(p.start.copy(a.end),p.end.copy(a.end)),!0;if(A!==2)return!1;if(d.delta(l),a.delta(c),l.dot(c)<0){let E=a.start;a.start=a.end,a.end=E}const v=d.start.dot(l),B=d.end.dot(l),T=a.start.dot(l),S=a.end.dot(l),M=B<T,C=v<S;return v!==S&&T!==B&&M===C?!1:(p&&(f.subVectors(d.start,a.start),f.dot(l)>0?p.start.copy(d.start):p.start.copy(a.start),f.subVectors(d.end,a.end),f.dot(l)<0?p.end.copy(d.end):p.end.copy(a.end)),!0)}}}();H.prototype.distanceToPoint=function(){const e=new I;return function(t){return this.closestPointToPoint(t,e),t.distanceTo(e)}}();H.prototype.distanceToTriangle=function(){const e=new I,n=new I,t=["a","b","c"],s=new k,i=new k;return function(r,l=null,c=null){const f=l||c?s:null;if(this.intersectsTriangle(r,f))return(l||c)&&(l&&f.getCenter(l),c&&f.getCenter(c)),0;let u=1/0;for(let d=0;d<3;d++){let a;const h=t[d],P=r[h];this.closestPointToPoint(P,e),a=P.distanceToSquared(e),a<u&&(u=a,l&&l.copy(e),c&&c.copy(P));const g=this[h];r.closestPointToPoint(g,e),a=g.distanceToSquared(e),a<u&&(u=a,l&&l.copy(g),c&&c.copy(e))}for(let d=0;d<3;d++){const a=t[d],h=t[(d+1)%3];s.set(this[a],this[h]);for(let P=0;P<3;P++){const g=t[P],m=t[(P+1)%3];i.set(r[g],r[m]),jt(s,i,e,n);const p=e.distanceToSquared(n);p<u&&(u=p,l&&l.copy(e),c&&c.copy(n))}}return Math.sqrt(u)}}();class N{constructor(n,t,s){this.isOrientedBox=!0,this.min=new I,this.max=new I,this.matrix=new dt,this.invMatrix=new dt,this.points=new Array(8).fill().map(()=>new I),this.satAxes=new Array(3).fill().map(()=>new I),this.satBounds=new Array(3).fill().map(()=>new j),this.alignedSatBounds=new Array(3).fill().map(()=>new j),this.needsUpdate=!1,n&&this.min.copy(n),t&&this.max.copy(t),s&&this.matrix.copy(s)}set(n,t,s){this.min.copy(n),this.max.copy(t),this.matrix.copy(s),this.needsUpdate=!0}copy(n){this.min.copy(n.min),this.max.copy(n.max),this.matrix.copy(n.matrix),this.needsUpdate=!0}}N.prototype.update=function(){return function(){const n=this.matrix,t=this.min,s=this.max,i=this.points;for(let f=0;f<=1;f++)for(let u=0;u<=1;u++)for(let d=0;d<=1;d++){const a=1*f|2*u|4*d,h=i[a];h.x=f?s.x:t.x,h.y=u?s.y:t.y,h.z=d?s.z:t.z,h.applyMatrix4(n)}const o=this.satBounds,r=this.satAxes,l=i[0];for(let f=0;f<3;f++){const u=r[f],d=o[f],a=1<<f,h=i[a];u.subVectors(l,h),d.setFromPoints(u,i)}const c=this.alignedSatBounds;c[0].setFromPointsField(i,"x"),c[1].setFromPointsField(i,"y"),c[2].setFromPointsField(i,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();N.prototype.intersectsBox=function(){const e=new j;return function(t){this.needsUpdate&&this.update();const s=t.min,i=t.max,o=this.satBounds,r=this.satAxes,l=this.alignedSatBounds;if(e.min=s.x,e.max=i.x,l[0].isSeparated(e)||(e.min=s.y,e.max=i.y,l[1].isSeparated(e))||(e.min=s.z,e.max=i.z,l[2].isSeparated(e)))return!1;for(let c=0;c<3;c++){const f=r[c],u=o[c];if(e.setFromBox(f,t),u.isSeparated(e))return!1}return!0}}();N.prototype.intersectsTriangle=function(){const e=new H,n=new Array(3),t=new j,s=new j,i=new I;return function(r){this.needsUpdate&&this.update(),r.isExtendedTriangle?r.needsUpdate&&r.update():(e.copy(r),e.update(),r=e);const l=this.satBounds,c=this.satAxes;n[0]=r.a,n[1]=r.b,n[2]=r.c;for(let a=0;a<3;a++){const h=l[a],P=c[a];if(t.setFromPoints(P,n),h.isSeparated(t))return!1}const f=r.satBounds,u=r.satAxes,d=this.points;for(let a=0;a<3;a++){const h=f[a],P=u[a];if(t.setFromPoints(P,d),h.isSeparated(t))return!1}for(let a=0;a<3;a++){const h=c[a];for(let P=0;P<4;P++){const g=u[P];if(i.crossVectors(h,g),t.setFromPoints(i,n),s.setFromPoints(i,d),t.isSeparated(s))return!1}}return!0}}();N.prototype.closestPointToPoint=function(){return function(n,t){return this.needsUpdate&&this.update(),t.copy(n).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),t}}();N.prototype.distanceToPoint=function(){const e=new I;return function(t){return this.closestPointToPoint(t,e),t.distanceTo(e)}}();N.prototype.distanceToBox=function(){const e=["x","y","z"],n=new Array(12).fill().map(()=>new k),t=new Array(12).fill().map(()=>new k),s=new I,i=new I;return function(r,l=0,c=null,f=null){if(this.needsUpdate&&this.update(),this.intersectsBox(r))return(c||f)&&(r.getCenter(i),this.closestPointToPoint(i,s),r.closestPointToPoint(s,i),c&&c.copy(s),f&&f.copy(i)),0;const u=l*l,d=r.min,a=r.max,h=this.points;let P=1/0;for(let m=0;m<8;m++){const p=h[m];i.copy(p).clamp(d,a);const x=p.distanceToSquared(i);if(x<P&&(P=x,c&&c.copy(p),f&&f.copy(i),x<u))return Math.sqrt(x)}let g=0;for(let m=0;m<3;m++)for(let p=0;p<=1;p++)for(let x=0;x<=1;x++){const y=(m+1)%3,b=(m+2)%3,w=p<<y|x<<b,A=1<<m|p<<y|x<<b,v=h[w],B=h[A];n[g].set(v,B);const S=e[m],M=e[y],C=e[b],E=t[g],F=E.start,L=E.end;F[S]=d[S],F[M]=p?d[M]:a[M],F[C]=x?d[C]:a[M],L[S]=a[S],L[M]=p?d[M]:a[M],L[C]=x?d[C]:a[M],g++}for(let m=0;m<=1;m++)for(let p=0;p<=1;p++)for(let x=0;x<=1;x++){i.x=m?a.x:d.x,i.y=p?a.y:d.y,i.z=x?a.z:d.z,this.closestPointToPoint(i,s);const y=i.distanceToSquared(s);if(y<P&&(P=y,c&&c.copy(s),f&&f.copy(i),y<u))return Math.sqrt(y)}for(let m=0;m<12;m++){const p=n[m];for(let x=0;x<12;x++){const y=t[x];jt(p,y,s,i);const b=s.distanceToSquared(i);if(b<P&&(P=b,c&&c.copy(s),f&&f.copy(i),b<u))return Math.sqrt(b)}}return Math.sqrt(P)}}();const Q=new I,tt=new I,nt=new I,Pt=new O,Tt=new O,vt=new O,Gt=new I,Qt=new I,tn=new I,Bt=new I;function Xn(e,n,t,s,i,o){let r;return o===Pn?r=e.intersectTriangle(s,t,n,!0,i):r=e.intersectTriangle(n,t,s,o!==Tn,i),r===null?null:{distance:e.origin.distanceTo(i),point:i.clone()}}function Yn(e,n,t,s,i,o,r,l,c){Q.fromBufferAttribute(n,o),tt.fromBufferAttribute(n,r),nt.fromBufferAttribute(n,l);const f=Xn(e,Q,tt,nt,Bt,c);if(f){s&&(Pt.fromBufferAttribute(s,o),Tt.fromBufferAttribute(s,r),vt.fromBufferAttribute(s,l),f.uv=ft.getInterpolation(Bt,Q,tt,nt,Pt,Tt,vt,new O)),i&&(Pt.fromBufferAttribute(i,o),Tt.fromBufferAttribute(i,r),vt.fromBufferAttribute(i,l),f.uv1=ft.getInterpolation(Bt,Q,tt,nt,Pt,Tt,vt,new O)),t&&(Gt.fromBufferAttribute(t,o),Qt.fromBufferAttribute(t,r),tn.fromBufferAttribute(t,l),f.normal=ft.getInterpolation(Bt,Q,tt,nt,Gt,Qt,tn,new I),f.normal.dot(e.direction)>0&&f.normal.multiplyScalar(-1));const u={a:o,b:r,c:l,normal:new I,materialIndex:0};ft.getNormal(Q,tt,nt,u.normal),f.face=u,f.faceIndex=o}return f}function hn(e,n,t,s,i){const o=s*3,r=e.index.getX(o),l=e.index.getX(o+1),c=e.index.getX(o+2),{position:f,normal:u,uv:d,uv1:a}=e.attributes,h=Yn(t,f,u,d,a,r,l,c,n);return h?(h.faceIndex=s,i&&i.push(h),h):null}function Zn(e,n,t,s,i,o){for(let r=s,l=s+i;r<l;r++)hn(e,n,t,r,o)}function Wn(e,n,t,s,i){let o=1/0,r=null;for(let l=s,c=s+i;l<c;l++){const f=hn(e,n,t,l);f&&f.distance<o&&(r=f,o=f.distance)}return r}function nn(e,n,t){return e===null||(e.point.applyMatrix4(n.matrixWorld),e.distance=e.point.distanceTo(t.ray.origin),e.object=n,e.distance<t.near||e.distance>t.far)?null:e}function _(e,n,t,s){const i=e.a,o=e.b,r=e.c;let l=n,c=n+1,f=n+2;t&&(l=t.getX(n),c=t.getX(n+1),f=t.getX(n+2)),i.x=s.getX(l),i.y=s.getY(l),i.z=s.getZ(l),o.x=s.getX(c),o.y=s.getY(c),o.z=s.getZ(c),r.x=s.getX(f),r.y=s.getY(f),r.z=s.getZ(f)}function en(e,n,t,s,i,o,r){const l=t.index,c=t.attributes.position;for(let f=e,u=n+e;f<u;f++)if(_(r,f*3,l,c),r.needsUpdate=!0,s(r,f,i,o))return!0;return!1}class yn{constructor(n){this._getNewPrimitive=n,this._primitives=[]}getPrimitive(){const n=this._primitives;return n.length===0?this._getNewPrimitive():n.pop()}releasePrimitive(n){this._primitives.push(n)}}function Y(e,n){return n[e+15]===65535}function it(e,n){return n[e+6]}function ht(e,n){return n[e+14]}function yt(e){return e+8}function mt(e,n){return n[e+6]}function Kn(e,n){return n[e+7]}const st=new ot,Et=new I,$n=["x","y","z"];function qt(e,n,t,s,i){let o=e*2,r=rt,l=Z,c=W;if(Y(o,l)){const u=it(e,c),d=ht(o,l);Zn(n,t,s,u,d,i)}else{const u=yt(e);Ft(u,r,s,Et)&&qt(u,n,t,s,i);const d=mt(e,c);Ft(d,r,s,Et)&&qt(d,n,t,s,i)}}function Ot(e,n,t,s){let i=e*2,o=rt,r=Z,l=W;if(Y(i,r)){const f=it(e,l),u=ht(i,r);return Wn(n,t,s,f,u)}else{const f=Kn(e,l),u=$n[f],a=s.direction[u]>=0;let h,P;a?(h=yt(e),P=mt(e,l)):(h=mt(e,l),P=yt(e));const m=Ft(h,o,s,Et)?Ot(h,n,t,s):null;if(m){const y=m.point[u];if(a?y<=o[P+f]:y>=o[P+f+3])return m}const x=Ft(P,o,s,Et)?Ot(P,n,t,s):null;return m&&x?m.distance<=x.distance?m:x:m||x||null}}const Jn=function(){let e,n;const t=[],s=new yn(()=>new ot);return function(...r){e=s.getPrimitive(),n=s.getPrimitive(),t.push(e,n);const l=i(...r);s.releasePrimitive(e),s.releasePrimitive(n),t.pop(),t.pop();const c=t.length;return c>0&&(n=t[c-1],e=t[c-2]),l};function i(o,r,l,c,f=null,u=0,d=0){function a(y){let b=y*2,w=Z,A=W;for(;!Y(b,w);)y=yt(y),b=y*2;return it(y,A)}function h(y){let b=y*2,w=Z,A=W;for(;!Y(b,w);)y=mt(y,A),b=y*2;return it(y,A)+ht(b,w)}let P=o*2,g=rt,m=Z,p=W;if(Y(P,m)){const y=it(o,p),b=ht(P,m);return R(o,g,e),c(y,b,!1,d,u+o,e)}else{const y=yt(o),b=mt(o,p);let w=y,A=b,v,B,T,S;if(f&&(T=e,S=n,R(w,g,T),R(A,g,S),v=f(T),B=f(S),B<v)){w=b,A=y;const U=v;v=B,B=U,T=S}T||(T=e,R(w,g,T));const M=Y(w*2,m),C=l(T,M,v,d+1,u+w);let E;if(C===Zt){const U=a(w),G=h(w)-U;E=c(U,G,!0,d+1,u+w,T)}else E=C&&i(w,r,l,c,f,u,d+1);if(E)return!0;S=n,R(A,g,S);const F=Y(A*2,m),L=l(S,F,B,d+1,u+A);let J;if(L===Zt){const U=a(A),G=h(A)-U;J=c(U,G,!0,d+1,u+A,S)}else J=L&&i(A,r,l,c,f,u,d+1);return!!J}}}(),Gn=function(){const e=new H,n=new H,t=new dt,s=new N,i=new N;return function o(r,l,c,f,u=null){let d=r*2,a=rt,h=Z,P=W;if(u===null&&(c.boundingBox||c.computeBoundingBox(),s.set(c.boundingBox.min,c.boundingBox.max,f),u=s),Y(d,h)){const m=l,p=m.index,x=m.attributes.position,y=c.index,b=c.attributes.position,w=it(r,P),A=ht(d,h);if(t.copy(f).invert(),c.boundsTree)return R(r,a,i),i.matrix.copy(t),i.needsUpdate=!0,c.boundsTree.shapecast({intersectsBounds:B=>i.intersectsBox(B),intersectsTriangle:B=>{B.a.applyMatrix4(f),B.b.applyMatrix4(f),B.c.applyMatrix4(f),B.needsUpdate=!0;for(let T=w*3,S=(A+w)*3;T<S;T+=3)if(_(n,T,p,x),n.needsUpdate=!0,B.intersectsTriangle(n))return!0;return!1}});for(let v=w*3,B=A+w*3;v<B;v+=3){_(e,v,p,x),e.a.applyMatrix4(t),e.b.applyMatrix4(t),e.c.applyMatrix4(t),e.needsUpdate=!0;for(let T=0,S=y.count;T<S;T+=3)if(_(n,T,y,b),n.needsUpdate=!0,e.intersectsTriangle(n))return!0}}else{const m=r+8,p=P[r+6];return R(m,a,st),!!(u.intersectsBox(st)&&o(m,l,c,f,u)||(R(p,a,st),u.intersectsBox(st)&&o(p,l,c,f,u)))}}}();function Ft(e,n,t,s){return R(e,n,st),t.intersectBox(st,s)}const kt=[];let Ct,rt,Z,W;function ut(e){Ct&&kt.push(Ct),Ct=e,rt=new Float32Array(e),Z=new Uint16Array(e),W=new Uint32Array(e)}function gt(){Ct=null,rt=null,Z=null,W=null,kt.length&&ut(kt.pop())}const Dt=Symbol("skip tree generation"),_t=new ot,Rt=new ot,et=new dt,$=new N,at=new N,lt=new I,St=new I,Qn=new I,te=new I,ne=new I,sn=new ot,D=new yn(()=>new H);class pt{static serialize(n,t={}){if(t.isBufferGeometry)return console.warn("MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature."),pt.serialize(arguments[0],{cloneBuffers:arguments[2]===void 0?!0:arguments[2]});t={cloneBuffers:!0,...t};const s=n.geometry,i=n._roots,o=s.getIndex();let r;return t.cloneBuffers?r={roots:i.map(l=>l.slice()),index:o.array.slice()}:r={roots:i,index:o.array},r}static deserialize(n,t,s={}){if(typeof s=="boolean")return console.warn("MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature."),pt.deserialize(arguments[0],arguments[1],{setIndex:arguments[2]===void 0?!0:arguments[2]});s={setIndex:!0,...s};const{index:i,roots:o}=n,r=new pt(t,{...s,[Dt]:!0});if(r._roots=o,s.setIndex){const l=t.getIndex();if(l===null){const c=new fn(n.index,1,!1);t.setIndex(c)}else l.array!==i&&(l.array.set(i),l.needsUpdate=!0)}return r}constructor(n,t={}){if(n.isBufferGeometry){if(n.index&&n.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t=Object.assign({strategy:dn,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,[Dt]:!1},t),t.useSharedArrayBuffer&&typeof SharedArrayBuffer>"u")throw new Error("MeshBVH: SharedArrayBuffer is not available.");this._roots=null,t[Dt]||(this._roots=On(n,t),!n.boundingBox&&t.setBoundingBox&&(n.boundingBox=this.getBoundingBox(new ot))),this.geometry=n}refit(n=null){n&&Array.isArray(n)&&(n=new Set(n));const t=this.geometry,s=t.index.array,i=t.attributes.position;let o,r,l,c,f=0;const u=this._roots;for(let a=0,h=u.length;a<h;a++)o=u[a],r=new Uint32Array(o),l=new Uint16Array(o),c=new Float32Array(o),d(0,f),f+=o.byteLength;function d(a,h,P=!1){const g=a*2;if(l[g+15]===Vt){const p=r[a+6],x=l[g+14];let y=1/0,b=1/0,w=1/0,A=-1/0,v=-1/0,B=-1/0;for(let T=3*p,S=3*(p+x);T<S;T++){const M=s[T],C=i.getX(M),E=i.getY(M),F=i.getZ(M);C<y&&(y=C),C>A&&(A=C),E<b&&(b=E),E>v&&(v=E),F<w&&(w=F),F>B&&(B=F)}return c[a+0]!==y||c[a+1]!==b||c[a+2]!==w||c[a+3]!==A||c[a+4]!==v||c[a+5]!==B?(c[a+0]=y,c[a+1]=b,c[a+2]=w,c[a+3]=A,c[a+4]=v,c[a+5]=B,!0):!1}else{const p=a+8,x=r[a+6],y=p+h,b=x+h;let w=P,A=!1,v=!1;n?w||(A=n.has(y),v=n.has(b),w=!A&&!v):(A=!0,v=!0);const B=w||A,T=w||v;let S=!1;B&&(S=d(p,h,w));let M=!1;T&&(M=d(x,h,w));const C=S||M;if(C)for(let E=0;E<3;E++){const F=p+E,L=x+E,J=c[F],U=c[F+3],xt=c[L],G=c[L+3];c[a+E]=J<xt?J:xt,c[a+E+3]=U>G?U:G}return C}}}traverse(n,t=0){const s=this._roots[t],i=new Uint32Array(s),o=new Uint16Array(s);r(0);function r(l,c=0){const f=l*2,u=o[f+15]===Vt;if(u){const d=i[l+6],a=o[f+14];n(c,u,new Float32Array(s,l*4,6),d,a)}else{const d=l+It/4,a=i[l+6],h=i[l+7];n(c,u,new Float32Array(s,l*4,6),h)||(r(d,c+1),r(a,c+1))}}}raycast(n,t=Xt){const s=this._roots,i=this.geometry,o=[],r=t.isMaterial,l=Array.isArray(t),c=i.groups,f=r?t.side:t;for(let u=0,d=s.length;u<d;u++){const a=l?t[c[u].materialIndex].side:f,h=o.length;if(ut(s[u]),qt(0,i,a,n,o),gt(),l){const P=c[u].materialIndex;for(let g=h,m=o.length;g<m;g++)o[g].face.materialIndex=P}}return o}raycastFirst(n,t=Xt){const s=this._roots,i=this.geometry,o=t.isMaterial,r=Array.isArray(t);let l=null;const c=i.groups,f=o?t.side:t;for(let u=0,d=s.length;u<d;u++){const a=r?t[c[u].materialIndex].side:f;ut(s[u]);const h=Ot(0,i,a,n);gt(),h!=null&&(l==null||h.distance<l.distance)&&(l=h,r&&(h.face.materialIndex=c[u].materialIndex))}return l}intersectsGeometry(n,t){const s=this.geometry;let i=!1;for(const o of this._roots)if(ut(o),i=Gn(0,s,n,t),gt(),i)break;return i}shapecast(n,t,s){const i=this.geometry;if(n instanceof Function){if(t){const a=t;t=(h,P,g,m)=>{const p=P*3;return a(h,p,p+1,p+2,g,m)}}n={boundsTraverseOrder:s,intersectsBounds:n,intersectsTriangle:t,intersectsRange:null},console.warn("MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.")}const o=D.getPrimitive();let{boundsTraverseOrder:r,intersectsBounds:l,intersectsRange:c,intersectsTriangle:f}=n;if(c&&f){const a=c;c=(h,P,g,m,p)=>a(h,P,g,m,p)?!0:en(h,P,i,f,g,m,o)}else c||(f?c=(a,h,P,g)=>en(a,h,i,f,P,g,o):c=(a,h,P)=>P);let u=!1,d=0;for(const a of this._roots){if(ut(a),u=Jn(0,i,l,c,r,d),gt(),u)break;d+=a.byteLength}return D.releasePrimitive(o),u}bvhcast(n,t,s){let{intersectsRanges:i,intersectsTriangles:o}=s;const r=this.geometry.index,l=this.geometry.attributes.position,c=n.geometry.index,f=n.geometry.attributes.position;et.copy(t).invert();const u=D.getPrimitive(),d=D.getPrimitive();if(o){let h=function(P,g,m,p,x,y,b,w){for(let A=m,v=m+p;A<v;A++){_(d,A*3,c,f),d.a.applyMatrix4(t),d.b.applyMatrix4(t),d.c.applyMatrix4(t),d.needsUpdate=!0;for(let B=P,T=P+g;B<T;B++)if(_(u,B*3,r,l),u.needsUpdate=!0,o(u,d,B,A,x,y,b,w))return!0}return!1};if(i){const P=i;i=function(g,m,p,x,y,b,w,A){return P(g,m,p,x,y,b,w,A)?!0:h(g,m,p,x,y,b,w,A)}}else i=h}n.getBoundingBox(Rt),Rt.applyMatrix4(t);const a=this.shapecast({intersectsBounds:h=>Rt.intersectsBox(h),intersectsRange:(h,P,g,m,p,x)=>(_t.copy(x),_t.applyMatrix4(et),n.shapecast({intersectsBounds:y=>_t.intersectsBox(y),intersectsRange:(y,b,w,A,v)=>i(h,P,y,b,m,p,A,v)}))});return D.releasePrimitive(u),D.releasePrimitive(d),a}intersectsBox(n,t){return $.set(n.min,n.max,t),$.needsUpdate=!0,this.shapecast({intersectsBounds:s=>$.intersectsBox(s),intersectsTriangle:s=>$.intersectsTriangle(s)})}intersectsSphere(n){return this.shapecast({intersectsBounds:t=>n.intersectsBox(t),intersectsTriangle:t=>t.intersectsSphere(n)})}closestPointToGeometry(n,t,s={},i={},o=0,r=1/0){n.boundingBox||n.computeBoundingBox(),$.set(n.boundingBox.min,n.boundingBox.max,t),$.needsUpdate=!0;const l=this.geometry,c=l.attributes.position,f=l.index,u=n.attributes.position,d=n.index,a=D.getPrimitive(),h=D.getPrimitive();let P=St,g=Qn,m=null,p=null;i&&(m=te,p=ne);let x=1/0,y=null,b=null;return et.copy(t).invert(),at.matrix.copy(et),this.shapecast({boundsTraverseOrder:w=>$.distanceToBox(w),intersectsBounds:(w,A,v)=>v<x&&v<r?(A&&(at.min.copy(w.min),at.max.copy(w.max),at.needsUpdate=!0),!0):!1,intersectsRange:(w,A)=>{if(n.boundsTree)return n.boundsTree.shapecast({boundsTraverseOrder:v=>at.distanceToBox(v),intersectsBounds:(v,B,T)=>T<x&&T<r,intersectsRange:(v,B)=>{for(let T=v*3,S=(v+B)*3;T<S;T+=3){_(h,T,d,u),h.a.applyMatrix4(t),h.b.applyMatrix4(t),h.c.applyMatrix4(t),h.needsUpdate=!0;for(let M=w*3,C=(w+A)*3;M<C;M+=3){_(a,M,f,c),a.needsUpdate=!0;const E=a.distanceToTriangle(h,P,m);if(E<x&&(g.copy(P),p&&p.copy(m),x=E,y=M/3,b=T/3),E<o)return!0}}}});{const v=d?d.count:u.count;for(let B=0,T=v;B<T;B+=3){_(h,B,d,u),h.a.applyMatrix4(t),h.b.applyMatrix4(t),h.c.applyMatrix4(t),h.needsUpdate=!0;for(let S=w*3,M=(w+A)*3;S<M;S+=3){_(a,S,f,c),a.needsUpdate=!0;const C=a.distanceToTriangle(h,P,m);if(C<x&&(g.copy(P),p&&p.copy(m),x=C,y=S/3,b=B/3),C<o)return!0}}}}}),D.releasePrimitive(a),D.releasePrimitive(h),x===1/0?null:(s.point?s.point.copy(g):s.point=g.clone(),s.distance=x,s.faceIndex=y,i&&(i.point?i.point.copy(p):i.point=p.clone(),i.point.applyMatrix4(et),g.applyMatrix4(et),i.distance=g.sub(i.point).length(),i.faceIndex=b),s)}closestPointToPoint(n,t={},s=0,i=1/0){const o=s*s,r=i*i;let l=1/0,c=null;if(this.shapecast({boundsTraverseOrder:u=>(lt.copy(n).clamp(u.min,u.max),lt.distanceToSquared(n)),intersectsBounds:(u,d,a)=>a<l&&a<r,intersectsTriangle:(u,d)=>{u.closestPointToPoint(n,lt);const a=n.distanceToSquared(lt);return a<l&&(St.copy(lt),l=a,c=d),a<o}}),l===1/0)return null;const f=Math.sqrt(l);return t.point?t.point.copy(St):t.point=St.clone(),t.distance=f,t.faceIndex=c,t}getBoundingBox(n){return n.makeEmpty(),this._roots.forEach(s=>{R(0,new Float32Array(s),sn),n.union(sn)}),n}}const Nt=new vn,on=new dt,ee=pn.prototype.raycast;function se(e,n){if(this.geometry.boundsTree){if(this.material===void 0)return;on.copy(this.matrixWorld).invert(),Nt.copy(e.ray).applyMatrix4(on);const t=this.geometry.boundsTree;if(e.firstHitOnly===!0){const s=nn(t.raycastFirst(Nt,this.material),this,e);s&&n.push(s)}else{const s=t.raycast(Nt,this.material);for(let i=0,o=s.length;i<o;i++){const r=nn(s[i],this,e);r&&n.push(r)}}}else ee.call(this,e,n)}function ie(e){return this.boundsTree=new pt(this,e),this.boundsTree}function oe(){this.boundsTree=null}const re=()=>{Yt.prototype.computeBoundsTree=ie,Yt.prototype.disposeBoundsTree=oe,pn.prototype.raycast=se,ln.prototype.firstHitOnly=!0},ce=`import { MouseRaycaster } from 'trzy'

const raycaster = new MouseRaycaster({
  scene, // alternatively, pass objects: THREE.Object3D[]
  camera,
  renderer,
  recursive: true,
})

raycaster.on('move', (event) => console.log(event.intersections))
raycaster.on('click', (event) => console.log(event.intersections))

// later
raycaster.dispose()
`,ue={title:"Mouse Raycaster",parameters:{docs:{source:{code:ce}}}},ae=()=>{re();const{scene:e,camera:n,renderer:t}=Bn();return gn().then(()=>{const s=new I(1,1,1);let i=!1,o=.1;const r=e.getObjectByName("Strawberry");r.traverse(c=>{var f,u;return(u=(f=c.geometry)==null?void 0:f.computeBoundsTree)==null?void 0:u.call(f)});const l=new Mn({renderer:t});l.recursive=!0,l.objects=[r],l.camera=n.current,l.on("move",c=>{c.intersections.length>0?(o=.1,s.setScalar(.12)):(o=.1,s.setScalar(.1)),i=c.intersections.length>0}),l.on("click",c=>{c.intersections.length!==0&&(o=.2,s.setScalar(s.x===.17?i?.12:.1:.17))}),Sn(()=>r.scale.lerp(s,o))}),t.domElement},Mt={render:ae};var rn,cn,an;Mt.parameters={...Mt.parameters,docs:{...(rn=Mt.parameters)==null?void 0:rn.docs,source:{originalSource:`{
  render
}`,...(an=(cn=Mt.parameters)==null?void 0:cn.docs)==null?void 0:an.source}}};const pe=["Primary"];export{Mt as Primary,pe as __namedExportsOrder,ue as default};
//# sourceMappingURL=index.stories-63f44d20.js.map
