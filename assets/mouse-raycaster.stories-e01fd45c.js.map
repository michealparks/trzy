{"version":3,"file":"mouse-raycaster.stories-e01fd45c.js","sources":["../../src/components/mouse-raycaster/index.ts","../../node_modules/three-mesh-bvh/src/core/Constants.js","../../node_modules/three-mesh-bvh/src/core/MeshBVHNode.js","../../node_modules/three-mesh-bvh/src/utils/ArrayBoxUtilities.js","../../node_modules/three-mesh-bvh/src/core/buildFunctions.js","../../node_modules/three-mesh-bvh/src/math/SeparatingAxisBounds.js","../../node_modules/three-mesh-bvh/src/math/MathUtilities.js","../../node_modules/three-mesh-bvh/src/math/ExtendedTriangle.js","../../node_modules/three-mesh-bvh/src/math/OrientedBox.js","../../node_modules/three-mesh-bvh/src/utils/ThreeRayIntersectUtilities.js","../../node_modules/three-mesh-bvh/src/utils/GeometryRayIntersectUtilities.js","../../node_modules/three-mesh-bvh/src/utils/TriangleUtilities.js","../../node_modules/three-mesh-bvh/src/utils/PrimitivePool.js","../../node_modules/three-mesh-bvh/src/core/nodeBufferFunctions.js","../../node_modules/three-mesh-bvh/src/core/castFunctions.js","../../node_modules/three-mesh-bvh/src/core/MeshBVH.js","../../node_modules/three-mesh-bvh/src/utils/ExtensionUtilities.js","../../src/components/bvh/index.ts","../../src/stories/mouse-raycaster/code.js?raw"],"sourcesContent":["import {\n  type Object3D,\n  type OrthographicCamera,\n  type PerspectiveCamera,\n  type Scene,\n  type WebGLRenderer,\n  Raycaster,\n  Vector2,\n  EventDispatcher,\n  Event,\n  EventListener,\n} from 'three'\n\ntype Events = 'click' | 'move'\n\nexport class MouseRaycaster extends EventDispatcher {\n  camera: PerspectiveCamera | OrthographicCamera\n  \n  raycaster: Raycaster\n  objects: Object3D[] = []\n  pointerDown = new Vector2()\n  pointerUp = new Vector2()\n  pointerMove = new Vector2()\n  recursive = true\n\n  renderer: WebGLRenderer\n  #events = { click: 0, move: 0 }\n\n  constructor (props: {\n    scene?: Scene\n    camera: PerspectiveCamera | OrthographicCamera\n    renderer: WebGLRenderer\n    raycaster?: Raycaster\n    objects?: Object3D[]\n    recursive?: boolean\n  }) {\n    super()\n    this.camera = props.camera\n    this.renderer = props.renderer\n    this.raycaster = props.raycaster ?? new Raycaster()\n    this.objects = props.objects ?? (props.scene ? [props.scene] : [])\n    this.recursive = props.recursive ?? true\n  }\n\n  on(type: Events, listener: EventListener<Event, Events, this>): void {\n    super.addEventListener<Events>(type, listener)\n\n    const canvas = this.renderer.domElement\n\n    if (type === 'move' && this.#events.move === 0) {\n      canvas.addEventListener('pointermove', this.onPointerMove, { passive: true })\n    } else if (type === 'click' && this.#events.click === 0) {\n      canvas.addEventListener('pointerdown', this.onPointerDown, { passive: true })\n      canvas.addEventListener('pointerup', this.onPointerUp, { passive: true })\n    }\n\n    this.#events[type] += 1\n  }\n\n  off(type: Events, listener: EventListener<Event, Events, this>): void {\n    super.removeEventListener<Events>(type, listener)\n\n    const canvas = this.renderer.domElement\n\n    this.#events[type] -= 1\n\n    if (type === 'move' && this.#events.move <= 0) {\n      canvas.removeEventListener('pointermove', this.onPointerMove)\n    } else if (type === 'click' && this.#events.click <= 0) {\n      canvas.addEventListener('pointerdown', this.onPointerDown, { passive: true })\n      canvas.addEventListener('pointerup', this.onPointerUp, { passive: true })\n    }\n  }\n\n  getNormalizedCoordinates (event: PointerEvent, vec: Vector2): void {\n    const canvas = this.renderer.domElement\n    const rect = canvas.getBoundingClientRect()\n\n    /*\n     * Calculate pointer position in normalized device coordinates\n     * (-1 to +1) for both components\n     */\n    vec.x = (((event.clientX - rect.x) / canvas.clientWidth) * 2) - 1\n    vec.y = -(((event.clientY - rect.y) / canvas.clientHeight) * 2) + 1\n  }\n\n  onPointerDown = (event: PointerEvent): void => {\n    this.getNormalizedCoordinates(event, this.pointerDown)\n  }\n\n  onPointerUp = (event: PointerEvent): void => {\n    this.getNormalizedCoordinates(event, this.pointerUp)\n\n    if (this.pointerDown.sub(this.pointerUp).lengthSq() > 0.001) {\n      return\n    }\n\n    // Update the picking ray with the camera and pointer position\n    this.raycaster.setFromCamera(this.pointerUp, this.camera)\n\n    const intersections = this.raycaster.intersectObjects(this.objects, this.recursive)\n\n    this.dispatchEvent({ type: 'click', intersections })\n  }\n\n  onPointerMove = (event: PointerEvent): void => {\n    this.getNormalizedCoordinates(event, this.pointerMove)\n\n    this.raycaster.setFromCamera(this.pointerMove, this.camera)\n\n    const intersections = this.raycaster.intersectObjects(this.objects, this.recursive)\n\n    this.dispatchEvent({ type: 'move', intersections })\n  }\n\n  dispose (): void {\n    const canvas = this.renderer.domElement\n\n    canvas.removeEventListener('pointerdown', this.onPointerDown)\n    canvas.removeEventListener('pointerup', this.onPointerUp)\n    canvas.removeEventListener('pointermove', this.onPointerMove)\n  }\n}\n","// Split strategy constants\nexport const CENTER = 0;\nexport const AVERAGE = 1;\nexport const SAH = 2;\n\n// Traversal constants\nexport const NOT_INTERSECTED = 0;\nexport const INTERSECTED = 1;\nexport const CONTAINED = 2;\n\n// SAH cost constants\n// TODO: hone these costs more. The relative difference between them should be the\n// difference in measured time to perform a triangle intersection vs traversing\n// bounds.\nexport const TRIANGLE_INTERSECT_COST = 1.25;\nexport const TRAVERSAL_COST = 1;\n\n\n// Build constants\nexport const BYTES_PER_NODE = 6 * 4 + 4 + 4;\nexport const IS_LEAFNODE_FLAG = 0xFFFF;\n\n// EPSILON for computing floating point error during build\n// https://en.wikipedia.org/wiki/Machine_epsilon#Values_for_standard_hardware_floating_point_arithmetics\nexport const FLOAT32_EPSILON = Math.pow( 2, - 24 );\n\n","export class MeshBVHNode {\n\n\tconstructor() {\n\n\t\t// internal nodes have boundingData, left, right, and splitAxis\n\t\t// leaf nodes have offset and count (referring to primitives in the mesh geometry)\n\n\t}\n\n}\n","export function arrayToBox( nodeIndex32, array, target ) {\n\n\ttarget.min.x = array[ nodeIndex32 ];\n\ttarget.min.y = array[ nodeIndex32 + 1 ];\n\ttarget.min.z = array[ nodeIndex32 + 2 ];\n\n\ttarget.max.x = array[ nodeIndex32 + 3 ];\n\ttarget.max.y = array[ nodeIndex32 + 4 ];\n\ttarget.max.z = array[ nodeIndex32 + 5 ];\n\n\treturn target;\n\n}\n\nexport function getLongestEdgeIndex( bounds ) {\n\n\tlet splitDimIdx = - 1;\n\tlet splitDist = - Infinity;\n\n\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\tconst dist = bounds[ i + 3 ] - bounds[ i ];\n\t\tif ( dist > splitDist ) {\n\n\t\t\tsplitDist = dist;\n\t\t\tsplitDimIdx = i;\n\n\t\t}\n\n\t}\n\n\treturn splitDimIdx;\n\n}\n\n// copies bounds a into bounds b\nexport function copyBounds( source, target ) {\n\n\ttarget.set( source );\n\n}\n\n// sets bounds target to the union of bounds a and b\nexport function unionBounds( a, b, target ) {\n\n\tlet aVal, bVal;\n\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\tconst d3 = d + 3;\n\n\t\t// set the minimum values\n\t\taVal = a[ d ];\n\t\tbVal = b[ d ];\n\t\ttarget[ d ] = aVal < bVal ? aVal : bVal;\n\n\t\t// set the max values\n\t\taVal = a[ d3 ];\n\t\tbVal = b[ d3 ];\n\t\ttarget[ d3 ] = aVal > bVal ? aVal : bVal;\n\n\t}\n\n}\n\n// expands the given bounds by the provided triangle bounds\nexport function expandByTriangleBounds( startIndex, triangleBounds, bounds ) {\n\n\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\tconst tCenter = triangleBounds[ startIndex + 2 * d ];\n\t\tconst tHalf = triangleBounds[ startIndex + 2 * d + 1 ];\n\n\t\tconst tMin = tCenter - tHalf;\n\t\tconst tMax = tCenter + tHalf;\n\n\t\tif ( tMin < bounds[ d ] ) {\n\n\t\t\tbounds[ d ] = tMin;\n\n\t\t}\n\n\t\tif ( tMax > bounds[ d + 3 ] ) {\n\n\t\t\tbounds[ d + 3 ] = tMax;\n\n\t\t}\n\n\t}\n\n}\n\n// compute bounds surface area\nexport function computeSurfaceArea( bounds ) {\n\n\tconst d0 = bounds[ 3 ] - bounds[ 0 ];\n\tconst d1 = bounds[ 4 ] - bounds[ 1 ];\n\tconst d2 = bounds[ 5 ] - bounds[ 2 ];\n\n\treturn 2 * ( d0 * d1 + d1 * d2 + d2 * d0 );\n\n}\n","import { BufferAttribute } from 'three';\nimport { MeshBVHNode } from './MeshBVHNode.js';\nimport { getLongestEdgeIndex, computeSurfaceArea, copyBounds, unionBounds, expandByTriangleBounds } from '../utils/ArrayBoxUtilities.js';\nimport {\n\tCENTER, AVERAGE, SAH, TRIANGLE_INTERSECT_COST, TRAVERSAL_COST,\n\tBYTES_PER_NODE, FLOAT32_EPSILON, IS_LEAFNODE_FLAG,\n} from './Constants.js';\n\nfunction ensureIndex( geo, options ) {\n\n\tif ( ! geo.index ) {\n\n\t\tconst vertexCount = geo.attributes.position.count;\n\t\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\t\tlet index;\n\t\tif ( vertexCount > 65535 ) {\n\n\t\t\tindex = new Uint32Array( new BufferConstructor( 4 * vertexCount ) );\n\n\t\t} else {\n\n\t\t\tindex = new Uint16Array( new BufferConstructor( 2 * vertexCount ) );\n\n\t\t}\n\n\t\tgeo.setIndex( new BufferAttribute( index, 1 ) );\n\n\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\t\tindex[ i ] = i;\n\n\t\t}\n\n\t}\n\n}\n\n// Computes the set of { offset, count } ranges which need independent BVH roots. Each\n// region in the geometry index that belongs to a different set of material groups requires\n// a separate BVH root, so that triangles indices belonging to one group never get swapped\n// with triangle indices belongs to another group. For example, if the groups were like this:\n//\n// [-------------------------------------------------------------]\n// |__________________|\n//   g0 = [0, 20]  |______________________||_____________________|\n//                      g1 = [16, 40]           g2 = [41, 60]\n//\n// we would need four BVH roots: [0, 15], [16, 20], [21, 40], [41, 60].\nfunction getRootIndexRanges( geo ) {\n\n\tif ( ! geo.groups || ! geo.groups.length ) {\n\n\t\treturn [ { offset: 0, count: geo.index.count / 3 } ];\n\n\t}\n\n\tconst ranges = [];\n\tconst rangeBoundaries = new Set();\n\tfor ( const group of geo.groups ) {\n\n\t\trangeBoundaries.add( group.start );\n\t\trangeBoundaries.add( group.start + group.count );\n\n\t}\n\n\t// note that if you don't pass in a comparator, it sorts them lexicographically as strings :-(\n\tconst sortedBoundaries = Array.from( rangeBoundaries.values() ).sort( ( a, b ) => a - b );\n\tfor ( let i = 0; i < sortedBoundaries.length - 1; i ++ ) {\n\n\t\tconst start = sortedBoundaries[ i ], end = sortedBoundaries[ i + 1 ];\n\t\tranges.push( { offset: ( start / 3 ), count: ( end - start ) / 3 } );\n\n\t}\n\n\treturn ranges;\n\n}\n\n// computes the union of the bounds of all of the given triangles and puts the resulting box in target. If\n// centroidTarget is provided then a bounding box is computed for the centroids of the triangles, as well.\n// These are computed together to avoid redundant accesses to bounds array.\nfunction getBounds( triangleBounds, offset, count, target, centroidTarget = null ) {\n\n\tlet minx = Infinity;\n\tlet miny = Infinity;\n\tlet minz = Infinity;\n\tlet maxx = - Infinity;\n\tlet maxy = - Infinity;\n\tlet maxz = - Infinity;\n\n\tlet cminx = Infinity;\n\tlet cminy = Infinity;\n\tlet cminz = Infinity;\n\tlet cmaxx = - Infinity;\n\tlet cmaxy = - Infinity;\n\tlet cmaxz = - Infinity;\n\n\tconst includeCentroid = centroidTarget !== null;\n\tfor ( let i = offset * 6, end = ( offset + count ) * 6; i < end; i += 6 ) {\n\n\t\tconst cx = triangleBounds[ i + 0 ];\n\t\tconst hx = triangleBounds[ i + 1 ];\n\t\tconst lx = cx - hx;\n\t\tconst rx = cx + hx;\n\t\tif ( lx < minx ) minx = lx;\n\t\tif ( rx > maxx ) maxx = rx;\n\t\tif ( includeCentroid && cx < cminx ) cminx = cx;\n\t\tif ( includeCentroid && cx > cmaxx ) cmaxx = cx;\n\n\t\tconst cy = triangleBounds[ i + 2 ];\n\t\tconst hy = triangleBounds[ i + 3 ];\n\t\tconst ly = cy - hy;\n\t\tconst ry = cy + hy;\n\t\tif ( ly < miny ) miny = ly;\n\t\tif ( ry > maxy ) maxy = ry;\n\t\tif ( includeCentroid && cy < cminy ) cminy = cy;\n\t\tif ( includeCentroid && cy > cmaxy ) cmaxy = cy;\n\n\t\tconst cz = triangleBounds[ i + 4 ];\n\t\tconst hz = triangleBounds[ i + 5 ];\n\t\tconst lz = cz - hz;\n\t\tconst rz = cz + hz;\n\t\tif ( lz < minz ) minz = lz;\n\t\tif ( rz > maxz ) maxz = rz;\n\t\tif ( includeCentroid && cz < cminz ) cminz = cz;\n\t\tif ( includeCentroid && cz > cmaxz ) cmaxz = cz;\n\n\t}\n\n\ttarget[ 0 ] = minx;\n\ttarget[ 1 ] = miny;\n\ttarget[ 2 ] = minz;\n\n\ttarget[ 3 ] = maxx;\n\ttarget[ 4 ] = maxy;\n\ttarget[ 5 ] = maxz;\n\n\tif ( includeCentroid ) {\n\n\t\tcentroidTarget[ 0 ] = cminx;\n\t\tcentroidTarget[ 1 ] = cminy;\n\t\tcentroidTarget[ 2 ] = cminz;\n\n\t\tcentroidTarget[ 3 ] = cmaxx;\n\t\tcentroidTarget[ 4 ] = cmaxy;\n\t\tcentroidTarget[ 5 ] = cmaxz;\n\n\t}\n\n}\n\n// A stand alone function for retrieving the centroid bounds.\nfunction getCentroidBounds( triangleBounds, offset, count, centroidTarget ) {\n\n\tlet cminx = Infinity;\n\tlet cminy = Infinity;\n\tlet cminz = Infinity;\n\tlet cmaxx = - Infinity;\n\tlet cmaxy = - Infinity;\n\tlet cmaxz = - Infinity;\n\n\tfor ( let i = offset * 6, end = ( offset + count ) * 6; i < end; i += 6 ) {\n\n\t\tconst cx = triangleBounds[ i + 0 ];\n\t\tif ( cx < cminx ) cminx = cx;\n\t\tif ( cx > cmaxx ) cmaxx = cx;\n\n\t\tconst cy = triangleBounds[ i + 2 ];\n\t\tif ( cy < cminy ) cminy = cy;\n\t\tif ( cy > cmaxy ) cmaxy = cy;\n\n\t\tconst cz = triangleBounds[ i + 4 ];\n\t\tif ( cz < cminz ) cminz = cz;\n\t\tif ( cz > cmaxz ) cmaxz = cz;\n\n\t}\n\n\tcentroidTarget[ 0 ] = cminx;\n\tcentroidTarget[ 1 ] = cminy;\n\tcentroidTarget[ 2 ] = cminz;\n\n\tcentroidTarget[ 3 ] = cmaxx;\n\tcentroidTarget[ 4 ] = cmaxy;\n\tcentroidTarget[ 5 ] = cmaxz;\n\n}\n\n\n// reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\n// will be on the left and elements on the right side of the split will be on the right. returns the index\n// of the first element on the right side, or offset + count if there are no elements on the right side.\nfunction partition( index, triangleBounds, offset, count, split ) {\n\n\tlet left = offset;\n\tlet right = offset + count - 1;\n\tconst pos = split.pos;\n\tconst axisOffset = split.axis * 2;\n\n\t// hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n\twhile ( true ) {\n\n\t\twhile ( left <= right && triangleBounds[ left * 6 + axisOffset ] < pos ) {\n\n\t\t\tleft ++;\n\n\t\t}\n\n\n\t\t// if a triangle center lies on the partition plane it is considered to be on the right side\n\t\twhile ( left <= right && triangleBounds[ right * 6 + axisOffset ] >= pos ) {\n\n\t\t\tright --;\n\n\t\t}\n\n\t\tif ( left < right ) {\n\n\t\t\t// we need to swap all of the information associated with the triangles at index\n\t\t\t// left and right; that's the verts in the geometry index, the bounds,\n\t\t\t// and perhaps the SAH planes\n\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tlet t0 = index[ left * 3 + i ];\n\t\t\t\tindex[ left * 3 + i ] = index[ right * 3 + i ];\n\t\t\t\tindex[ right * 3 + i ] = t0;\n\n\t\t\t\tlet t1 = triangleBounds[ left * 6 + i * 2 + 0 ];\n\t\t\t\ttriangleBounds[ left * 6 + i * 2 + 0 ] = triangleBounds[ right * 6 + i * 2 + 0 ];\n\t\t\t\ttriangleBounds[ right * 6 + i * 2 + 0 ] = t1;\n\n\t\t\t\tlet t2 = triangleBounds[ left * 6 + i * 2 + 1 ];\n\t\t\t\ttriangleBounds[ left * 6 + i * 2 + 1 ] = triangleBounds[ right * 6 + i * 2 + 1 ];\n\t\t\t\ttriangleBounds[ right * 6 + i * 2 + 1 ] = t2;\n\n\t\t\t}\n\n\t\t\tleft ++;\n\t\t\tright --;\n\n\t\t} else {\n\n\t\t\treturn left;\n\n\t\t}\n\n\t}\n\n}\n\nconst BIN_COUNT = 32;\nconst binsSort = ( a, b ) => a.candidate - b.candidate;\nconst sahBins = new Array( BIN_COUNT ).fill().map( () => {\n\n\treturn {\n\n\t\tcount: 0,\n\t\tbounds: new Float32Array( 6 ),\n\t\trightCacheBounds: new Float32Array( 6 ),\n\t\tleftCacheBounds: new Float32Array( 6 ),\n\t\tcandidate: 0,\n\n\t};\n\n} );\nconst leftBounds = new Float32Array( 6 );\n\nfunction getOptimalSplit( nodeBoundingData, centroidBoundingData, triangleBounds, offset, count, strategy ) {\n\n\tlet axis = - 1;\n\tlet pos = 0;\n\n\t// Center\n\tif ( strategy === CENTER ) {\n\n\t\taxis = getLongestEdgeIndex( centroidBoundingData );\n\t\tif ( axis !== - 1 ) {\n\n\t\t\tpos = ( centroidBoundingData[ axis ] + centroidBoundingData[ axis + 3 ] ) / 2;\n\n\t\t}\n\n\t} else if ( strategy === AVERAGE ) {\n\n\t\taxis = getLongestEdgeIndex( nodeBoundingData );\n\t\tif ( axis !== - 1 ) {\n\n\t\t\tpos = getAverage( triangleBounds, offset, count, axis );\n\n\t\t}\n\n\t} else if ( strategy === SAH ) {\n\n\t\tconst rootSurfaceArea = computeSurfaceArea( nodeBoundingData );\n\t\tlet bestCost = TRIANGLE_INTERSECT_COST * count;\n\n\t\t// iterate over all axes\n\t\tconst cStart = offset * 6;\n\t\tconst cEnd = ( offset + count ) * 6;\n\t\tfor ( let a = 0; a < 3; a ++ ) {\n\n\t\t\tconst axisLeft = centroidBoundingData[ a ];\n\t\t\tconst axisRight = centroidBoundingData[ a + 3 ];\n\t\t\tconst axisLength = axisRight - axisLeft;\n\t\t\tconst binWidth = axisLength / BIN_COUNT;\n\n\t\t\t// If we have fewer triangles than we're planning to split then just check all\n\t\t\t// the triangle positions because it will be faster.\n\t\t\tif ( count < BIN_COUNT / 4 ) {\n\n\t\t\t\t// initialize the bin candidates\n\t\t\t\tconst truncatedBins = [ ...sahBins ];\n\t\t\t\ttruncatedBins.length = count;\n\n\t\t\t\t// set the candidates\n\t\t\t\tlet b = 0;\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6, b ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ b ];\n\t\t\t\t\tbin.candidate = triangleBounds[ c + 2 * a ];\n\t\t\t\t\tbin.count = 0;\n\n\t\t\t\t\tconst {\n\t\t\t\t\t\tbounds,\n\t\t\t\t\t\tleftCacheBounds,\n\t\t\t\t\t\trightCacheBounds,\n\t\t\t\t\t} = bin;\n\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\t\t\t\trightCacheBounds[ d ] = Infinity;\n\t\t\t\t\t\trightCacheBounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\tleftCacheBounds[ d ] = Infinity;\n\t\t\t\t\t\tleftCacheBounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\tbounds[ d ] = Infinity;\n\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t}\n\n\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bounds );\n\n\t\t\t\t}\n\n\t\t\t\ttruncatedBins.sort( binsSort );\n\n\t\t\t\t// remove redundant splits\n\t\t\t\tlet splitCount = count;\n\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\twhile ( bi + 1 < splitCount && truncatedBins[ bi + 1 ].candidate === bin.candidate ) {\n\n\t\t\t\t\t\ttruncatedBins.splice( bi + 1, 1 );\n\t\t\t\t\t\tsplitCount --;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// find the appropriate bin for each triangle and expand the bounds.\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\n\n\t\t\t\t\tconst center = triangleBounds[ c + 2 * a ];\n\t\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\t\tif ( center >= bin.candidate ) {\n\n\t\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.rightCacheBounds );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.leftCacheBounds );\n\t\t\t\t\t\t\tbin.count ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// expand all the bounds\n\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\tconst leftCount = bin.count;\n\t\t\t\t\tconst rightCount = count - bin.count;\n\n\t\t\t\t\t// check the cost of this split\n\t\t\t\t\tconst leftBounds = bin.leftCacheBounds;\n\t\t\t\t\tconst rightBounds = bin.rightCacheBounds;\n\n\t\t\t\t\tlet leftProb = 0;\n\t\t\t\t\tif ( leftCount !== 0 ) {\n\n\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet rightProb = 0;\n\t\t\t\t\tif ( rightCount !== 0 ) {\n\n\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (\n\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\n\t\t\t\t\t);\n\n\t\t\t\t\tif ( cost < bestCost ) {\n\n\t\t\t\t\t\taxis = a;\n\t\t\t\t\t\tbestCost = cost;\n\t\t\t\t\t\tpos = bin.candidate;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// reset the bins\n\t\t\t\tfor ( let i = 0; i < BIN_COUNT; i ++ ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tbin.count = 0;\n\t\t\t\t\tbin.candidate = axisLeft + binWidth + i * binWidth;\n\n\t\t\t\t\tconst bounds = bin.bounds;\n\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\t\t\t\tbounds[ d ] = Infinity;\n\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// iterate over all center positions\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\n\n\t\t\t\t\tconst triCenter = triangleBounds[ c + 2 * a ];\n\t\t\t\t\tconst relativeCenter = triCenter - axisLeft;\n\n\t\t\t\t\t// in the partition function if the centroid lies on the split plane then it is\n\t\t\t\t\t// considered to be on the right side of the split\n\t\t\t\t\tlet binIndex = ~ ~ ( relativeCenter / binWidth );\n\t\t\t\t\tif ( binIndex >= BIN_COUNT ) binIndex = BIN_COUNT - 1;\n\n\t\t\t\t\tconst bin = sahBins[ binIndex ];\n\t\t\t\t\tbin.count ++;\n\n\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.bounds );\n\n\t\t\t\t}\n\n\t\t\t\t// cache the unioned bounds from right to left so we don't have to regenerate them each time\n\t\t\t\tconst lastBin = sahBins[ BIN_COUNT - 1 ];\n\t\t\t\tcopyBounds( lastBin.bounds, lastBin.rightCacheBounds );\n\t\t\t\tfor ( let i = BIN_COUNT - 2; i >= 0; i -- ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\n\t\t\t\t\tunionBounds( bin.bounds, nextBin.rightCacheBounds, bin.rightCacheBounds );\n\n\t\t\t\t}\n\n\t\t\t\tlet leftCount = 0;\n\t\t\t\tfor ( let i = 0; i < BIN_COUNT - 1; i ++ ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tconst binCount = bin.count;\n\t\t\t\t\tconst bounds = bin.bounds;\n\n\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\n\t\t\t\t\tconst rightBounds = nextBin.rightCacheBounds;\n\n\t\t\t\t\t// don't do anything with the bounds if the new bounds have no triangles\n\t\t\t\t\tif ( binCount !== 0 ) {\n\n\t\t\t\t\t\tif ( leftCount === 0 ) {\n\n\t\t\t\t\t\t\tcopyBounds( bounds, leftBounds );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tunionBounds( bounds, leftBounds, leftBounds );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tleftCount += binCount;\n\n\t\t\t\t\t// check the cost of this split\n\t\t\t\t\tlet leftProb = 0;\n\t\t\t\t\tlet rightProb = 0;\n\n\t\t\t\t\tif ( leftCount !== 0 ) {\n\n\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst rightCount = count - leftCount;\n\t\t\t\t\tif ( rightCount !== 0 ) {\n\n\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (\n\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\n\t\t\t\t\t);\n\n\t\t\t\t\tif ( cost < bestCost ) {\n\n\t\t\t\t\t\taxis = a;\n\t\t\t\t\t\tbestCost = cost;\n\t\t\t\t\t\tpos = bin.candidate;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\tconsole.warn( `MeshBVH: Invalid build strategy value ${ strategy } used.` );\n\n\t}\n\n\treturn { axis, pos };\n\n}\n\n// returns the average coordinate on the specified axis of the all the provided triangles\nfunction getAverage( triangleBounds, offset, count, axis ) {\n\n\tlet avg = 0;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tavg += triangleBounds[ i * 6 + axis * 2 ];\n\n\t}\n\n\treturn avg / count;\n\n}\n\n// precomputes the bounding box for each triangle; required for quickly calculating tree splits.\n// result is an array of size tris.length * 6 where triangle i maps to a\n// [x_center, x_delta, y_center, y_delta, z_center, z_delta] tuple starting at index i * 6,\n// representing the center and half-extent in each dimension of triangle i\nfunction computeTriangleBounds( geo, fullBounds ) {\n\n\tconst posAttr = geo.attributes.position;\n\tconst index = geo.index.array;\n\tconst triCount = index.length / 3;\n\tconst triangleBounds = new Float32Array( triCount * 6 );\n\tconst normalized = posAttr.normalized;\n\n\t// used for non-normalized positions\n\tconst posArr = posAttr.array;\n\n\t// support for an interleaved position buffer\n\tconst bufferOffset = posAttr.offset || 0;\n\tlet stride = 3;\n\tif ( posAttr.isInterleavedBufferAttribute ) {\n\n\t\tstride = posAttr.data.stride;\n\n\t}\n\n\t// used for normalized positions\n\tconst getters = [ 'getX', 'getY', 'getZ' ];\n\n\tfor ( let tri = 0; tri < triCount; tri ++ ) {\n\n\t\tconst tri3 = tri * 3;\n\t\tconst tri6 = tri * 6;\n\n\t\tlet ai, bi, ci;\n\n\t\tif ( normalized ) {\n\n\t\t\tai = index[ tri3 + 0 ];\n\t\t\tbi = index[ tri3 + 1 ];\n\t\t\tci = index[ tri3 + 2 ];\n\n\t\t} else {\n\n\t\t\tai = index[ tri3 + 0 ] * stride + bufferOffset;\n\t\t\tbi = index[ tri3 + 1 ] * stride + bufferOffset;\n\t\t\tci = index[ tri3 + 2 ] * stride + bufferOffset;\n\n\t\t}\n\n\t\tfor ( let el = 0; el < 3; el ++ ) {\n\n\t\t\tlet a, b, c;\n\n\t\t\tif ( normalized ) {\n\n\t\t\t\ta = posAttr[ getters[ el ] ]( ai );\n\t\t\t\tb = posAttr[ getters[ el ] ]( bi );\n\t\t\t\tc = posAttr[ getters[ el ] ]( ci );\n\n\t\t\t} else {\n\n\t\t\t\ta = posArr[ ai + el ];\n\t\t\t\tb = posArr[ bi + el ];\n\t\t\t\tc = posArr[ ci + el ];\n\n\t\t\t}\n\n\t\t\tlet min = a;\n\t\t\tif ( b < min ) min = b;\n\t\t\tif ( c < min ) min = c;\n\n\t\t\tlet max = a;\n\t\t\tif ( b > max ) max = b;\n\t\t\tif ( c > max ) max = c;\n\n\t\t\t// Increase the bounds size by float32 epsilon to avoid precision errors when\n\t\t\t// converting to 32 bit float. Scale the epsilon by the size of the numbers being\n\t\t\t// worked with.\n\t\t\tconst halfExtents = ( max - min ) / 2;\n\t\t\tconst el2 = el * 2;\n\t\t\ttriangleBounds[ tri6 + el2 + 0 ] = min + halfExtents;\n\t\t\ttriangleBounds[ tri6 + el2 + 1 ] = halfExtents + ( Math.abs( min ) + halfExtents ) * FLOAT32_EPSILON;\n\n\t\t\tif ( min < fullBounds[ el ] ) fullBounds[ el ] = min;\n\t\t\tif ( max > fullBounds[ el + 3 ] ) fullBounds[ el + 3 ] = max;\n\n\t\t}\n\n\t}\n\n\treturn triangleBounds;\n\n}\n\nexport function buildTree( geo, options ) {\n\n\tfunction triggerProgress( trianglesProcessed ) {\n\n\t\tif ( onProgress ) {\n\n\t\t\tonProgress( trianglesProcessed / totalTriangles );\n\n\t\t}\n\n\t}\n\n\t// either recursively splits the given node, creating left and right subtrees for it, or makes it a leaf node,\n\t// recording the offset and count of its triangles and writing them into the reordered geometry index.\n\tfunction splitNode( node, offset, count, centroidBoundingData = null, depth = 0 ) {\n\n\t\tif ( ! reachedMaxDepth && depth >= maxDepth ) {\n\n\t\t\treachedMaxDepth = true;\n\t\t\tif ( verbose ) {\n\n\t\t\t\tconsole.warn( `MeshBVH: Max depth of ${ maxDepth } reached when generating BVH. Consider increasing maxDepth.` );\n\t\t\t\tconsole.warn( geo );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// early out if we've met our capacity\n\t\tif ( count <= maxLeafTris || depth >= maxDepth ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\t\t\treturn node;\n\n\t\t}\n\n\t\t// Find where to split the volume\n\t\tconst split = getOptimalSplit( node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy );\n\t\tif ( split.axis === - 1 ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\t\t\treturn node;\n\n\t\t}\n\n\t\tconst splitOffset = partition( indexArray, triangleBounds, offset, count, split );\n\n\t\t// create the two new child nodes\n\t\tif ( splitOffset === offset || splitOffset === offset + count ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\n\t\t} else {\n\n\t\t\tnode.splitAxis = split.axis;\n\n\t\t\t// create the left child and compute its bounding box\n\t\t\tconst left = new MeshBVHNode();\n\t\t\tconst lstart = offset;\n\t\t\tconst lcount = splitOffset - offset;\n\t\t\tnode.left = left;\n\t\t\tleft.boundingData = new Float32Array( 6 );\n\n\t\t\tgetBounds( triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData );\n\t\t\tsplitNode( left, lstart, lcount, cacheCentroidBoundingData, depth + 1 );\n\n\t\t\t// repeat for right\n\t\t\tconst right = new MeshBVHNode();\n\t\t\tconst rstart = splitOffset;\n\t\t\tconst rcount = count - lcount;\n\t\t\tnode.right = right;\n\t\t\tright.boundingData = new Float32Array( 6 );\n\n\t\t\tgetBounds( triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData );\n\t\t\tsplitNode( right, rstart, rcount, cacheCentroidBoundingData, depth + 1 );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n\tensureIndex( geo, options );\n\n\t// Compute the full bounds of the geometry at the same time as triangle bounds because\n\t// we'll need it for the root bounds in the case with no groups and it should be fast here.\n\t// We can't use the geometrying bounding box if it's available because it may be out of date.\n\tconst fullBounds = new Float32Array( 6 );\n\tconst cacheCentroidBoundingData = new Float32Array( 6 );\n\tconst triangleBounds = computeTriangleBounds( geo, fullBounds );\n\tconst indexArray = geo.index.array;\n\tconst maxDepth = options.maxDepth;\n\tconst verbose = options.verbose;\n\tconst maxLeafTris = options.maxLeafTris;\n\tconst strategy = options.strategy;\n\tconst onProgress = options.onProgress;\n\tconst totalTriangles = geo.index.count / 3;\n\tlet reachedMaxDepth = false;\n\n\tconst roots = [];\n\tconst ranges = getRootIndexRanges( geo );\n\n\tif ( ranges.length === 1 ) {\n\n\t\tconst range = ranges[ 0 ];\n\t\tconst root = new MeshBVHNode();\n\t\troot.boundingData = fullBounds;\n\t\tgetCentroidBounds( triangleBounds, range.offset, range.count, cacheCentroidBoundingData );\n\n\t\tsplitNode( root, range.offset, range.count, cacheCentroidBoundingData );\n\t\troots.push( root );\n\n\t} else {\n\n\t\tfor ( let range of ranges ) {\n\n\t\t\tconst root = new MeshBVHNode();\n\t\t\troot.boundingData = new Float32Array( 6 );\n\t\t\tgetBounds( triangleBounds, range.offset, range.count, root.boundingData, cacheCentroidBoundingData );\n\n\t\t\tsplitNode( root, range.offset, range.count, cacheCentroidBoundingData );\n\t\t\troots.push( root );\n\n\t\t}\n\n\t}\n\n\treturn roots;\n\n}\n\nexport function buildPackedTree( geo, options ) {\n\n\t// boundingData  \t\t\t\t: 6 float32\n\t// right / offset \t\t\t\t: 1 uint32\n\t// splitAxis / isLeaf + count \t: 1 uint32 / 2 uint16\n\tconst roots = buildTree( geo, options );\n\n\tlet float32Array;\n\tlet uint32Array;\n\tlet uint16Array;\n\tconst packedRoots = [];\n\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\tfor ( let i = 0; i < roots.length; i ++ ) {\n\n\t\tconst root = roots[ i ];\n\t\tlet nodeCount = countNodes( root );\n\n\t\tconst buffer = new BufferConstructor( BYTES_PER_NODE * nodeCount );\n\t\tfloat32Array = new Float32Array( buffer );\n\t\tuint32Array = new Uint32Array( buffer );\n\t\tuint16Array = new Uint16Array( buffer );\n\t\tpopulateBuffer( 0, root );\n\t\tpackedRoots.push( buffer );\n\n\t}\n\n\treturn packedRoots;\n\n\tfunction countNodes( node ) {\n\n\t\tif ( node.count ) {\n\n\t\t\treturn 1;\n\n\t\t} else {\n\n\t\t\treturn 1 + countNodes( node.left ) + countNodes( node.right );\n\n\t\t}\n\n\t}\n\n\tfunction populateBuffer( byteOffset, node ) {\n\n\t\tconst stride4Offset = byteOffset / 4;\n\t\tconst stride2Offset = byteOffset / 2;\n\t\tconst isLeaf = ! ! node.count;\n\t\tconst boundingData = node.boundingData;\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tfloat32Array[ stride4Offset + i ] = boundingData[ i ];\n\n\t\t}\n\n\t\tif ( isLeaf ) {\n\n\t\t\tconst offset = node.offset;\n\t\t\tconst count = node.count;\n\t\t\tuint32Array[ stride4Offset + 6 ] = offset;\n\t\t\tuint16Array[ stride2Offset + 14 ] = count;\n\t\t\tuint16Array[ stride2Offset + 15 ] = IS_LEAFNODE_FLAG;\n\t\t\treturn byteOffset + BYTES_PER_NODE;\n\n\t\t} else {\n\n\t\t\tconst left = node.left;\n\t\t\tconst right = node.right;\n\t\t\tconst splitAxis = node.splitAxis;\n\n\t\t\tlet nextUnusedPointer;\n\t\t\tnextUnusedPointer = populateBuffer( byteOffset + BYTES_PER_NODE, left );\n\n\t\t\tif ( ( nextUnusedPointer / 4 ) > Math.pow( 2, 32 ) ) {\n\n\t\t\t\tthrow new Error( 'MeshBVH: Cannot store child pointer greater than 32 bits.' );\n\n\t\t\t}\n\n\t\t\tuint32Array[ stride4Offset + 6 ] = nextUnusedPointer / 4;\n\t\t\tnextUnusedPointer = populateBuffer( nextUnusedPointer, right );\n\n\t\t\tuint32Array[ stride4Offset + 7 ] = splitAxis;\n\t\t\treturn nextUnusedPointer;\n\n\t\t}\n\n\t}\n\n}\n","import { Vector3 } from 'three';\n\nexport class SeparatingAxisBounds {\n\n\tconstructor() {\n\n\t\tthis.min = Infinity;\n\t\tthis.max = - Infinity;\n\n\t}\n\n\tsetFromPointsField( points, field ) {\n\n\t\tlet min = Infinity;\n\t\tlet max = - Infinity;\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tconst p = points[ i ];\n\t\t\tconst val = p[ field ];\n\t\t\tmin = val < min ? val : min;\n\t\t\tmax = val > max ? val : max;\n\n\t\t}\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t}\n\n\tsetFromPoints( axis, points ) {\n\n\t\tlet min = Infinity;\n\t\tlet max = - Infinity;\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tconst p = points[ i ];\n\t\t\tconst val = axis.dot( p );\n\t\t\tmin = val < min ? val : min;\n\t\t\tmax = val > max ? val : max;\n\n\t\t}\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t}\n\n\tisSeparated( other ) {\n\n\t\treturn this.min > other.max || other.min > this.max;\n\n\t}\n\n}\n\nSeparatingAxisBounds.prototype.setFromBox = ( function () {\n\n\tconst p = new Vector3();\n\treturn function setFromBox( axis, box ) {\n\n\t\tconst boxMin = box.min;\n\t\tconst boxMax = box.max;\n\t\tlet min = Infinity;\n\t\tlet max = - Infinity;\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tp.x = boxMin.x * x + boxMax.x * ( 1 - x );\n\t\t\t\t\tp.y = boxMin.y * y + boxMax.y * ( 1 - y );\n\t\t\t\t\tp.z = boxMin.z * z + boxMax.z * ( 1 - z );\n\n\t\t\t\t\tconst val = axis.dot( p );\n\t\t\t\t\tmin = Math.min( val, min );\n\t\t\t\t\tmax = Math.max( val, max );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t};\n\n} )();\n\nexport const areIntersecting = ( function () {\n\n\tconst cacheSatBounds = new SeparatingAxisBounds();\n\treturn function areIntersecting( shape1, shape2 ) {\n\n\t\tconst points1 = shape1.points;\n\t\tconst satAxes1 = shape1.satAxes;\n\t\tconst satBounds1 = shape1.satBounds;\n\n\t\tconst points2 = shape2.points;\n\t\tconst satAxes2 = shape2.satAxes;\n\t\tconst satBounds2 = shape2.satBounds;\n\n\t\t// check axes of the first shape\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = satBounds1[ i ];\n\t\t\tconst sa = satAxes1[ i ];\n\t\t\tcacheSatBounds.setFromPoints( sa, points2 );\n\t\t\tif ( sb.isSeparated( cacheSatBounds ) ) return false;\n\n\t\t}\n\n\t\t// check axes of the second shape\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = satBounds2[ i ];\n\t\t\tconst sa = satAxes2[ i ];\n\t\t\tcacheSatBounds.setFromPoints( sa, points1 );\n\t\t\tif ( sb.isSeparated( cacheSatBounds ) ) return false;\n\n\t\t}\n\n\t};\n\n} )();\n","import { Vector3, Vector2, Plane, Line3 } from 'three';\n\nexport const closestPointLineToLine = ( function () {\n\n\t// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/Line.cpp#L56\n\tconst dir1 = new Vector3();\n\tconst dir2 = new Vector3();\n\tconst v02 = new Vector3();\n\treturn function closestPointLineToLine( l1, l2, result ) {\n\n\t\tconst v0 = l1.start;\n\t\tconst v10 = dir1;\n\t\tconst v2 = l2.start;\n\t\tconst v32 = dir2;\n\n\t\tv02.subVectors( v0, v2 );\n\t\tdir1.subVectors( l1.end, l1.start );\n\t\tdir2.subVectors( l2.end, l2.start );\n\n\t\t// float d0232 = v02.Dot(v32);\n\t\tconst d0232 = v02.dot( v32 );\n\n\t\t// float d3210 = v32.Dot(v10);\n\t\tconst d3210 = v32.dot( v10 );\n\n\t\t// float d3232 = v32.Dot(v32);\n\t\tconst d3232 = v32.dot( v32 );\n\n\t\t// float d0210 = v02.Dot(v10);\n\t\tconst d0210 = v02.dot( v10 );\n\n\t\t// float d1010 = v10.Dot(v10);\n\t\tconst d1010 = v10.dot( v10 );\n\n\t\t// float denom = d1010*d3232 - d3210*d3210;\n\t\tconst denom = d1010 * d3232 - d3210 * d3210;\n\n\t\tlet d, d2;\n\t\tif ( denom !== 0 ) {\n\n\t\t\td = ( d0232 * d3210 - d0210 * d3232 ) / denom;\n\n\t\t} else {\n\n\t\t\td = 0;\n\n\t\t}\n\n\t\td2 = ( d0232 + d * d3210 ) / d3232;\n\n\t\tresult.x = d;\n\t\tresult.y = d2;\n\n\t};\n\n} )();\n\nexport const closestPointsSegmentToSegment = ( function () {\n\n\t// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/LineSegment.cpp#L187\n\tconst paramResult = new Vector2();\n\tconst temp1 = new Vector3();\n\tconst temp2 = new Vector3();\n\treturn function closestPointsSegmentToSegment( l1, l2, target1, target2 ) {\n\n\t\tclosestPointLineToLine( l1, l2, paramResult );\n\n\t\tlet d = paramResult.x;\n\t\tlet d2 = paramResult.y;\n\t\tif ( d >= 0 && d <= 1 && d2 >= 0 && d2 <= 1 ) {\n\n\t\t\tl1.at( d, target1 );\n\t\t\tl2.at( d2, target2 );\n\n\t\t\treturn;\n\n\t\t} else if ( d >= 0 && d <= 1 ) {\n\n\t\t\t// Only d2 is out of bounds.\n\t\t\tif ( d2 < 0 ) {\n\n\t\t\t\tl2.at( 0, target2 );\n\n\t\t\t} else {\n\n\t\t\t\tl2.at( 1, target2 );\n\n\t\t\t}\n\n\t\t\tl1.closestPointToPoint( target2, true, target1 );\n\t\t\treturn;\n\n\t\t} else if ( d2 >= 0 && d2 <= 1 ) {\n\n\t\t\t// Only d is out of bounds.\n\t\t\tif ( d < 0 ) {\n\n\t\t\t\tl1.at( 0, target1 );\n\n\t\t\t} else {\n\n\t\t\t\tl1.at( 1, target1 );\n\n\t\t\t}\n\n\t\t\tl2.closestPointToPoint( target1, true, target2 );\n\t\t\treturn;\n\n\t\t} else {\n\n\t\t\t// Both u and u2 are out of bounds.\n\t\t\tlet p;\n\t\t\tif ( d < 0 ) {\n\n\t\t\t\tp = l1.start;\n\n\t\t\t} else {\n\n\t\t\t\tp = l1.end;\n\n\t\t\t}\n\n\t\t\tlet p2;\n\t\t\tif ( d2 < 0 ) {\n\n\t\t\t\tp2 = l2.start;\n\n\t\t\t} else {\n\n\t\t\t\tp2 = l2.end;\n\n\t\t\t}\n\n\t\t\tconst closestPoint = temp1;\n\t\t\tconst closestPoint2 = temp2;\n\t\t\tl1.closestPointToPoint( p2, true, temp1 );\n\t\t\tl2.closestPointToPoint( p, true, temp2 );\n\n\t\t\tif ( closestPoint.distanceToSquared( p2 ) <= closestPoint2.distanceToSquared( p ) ) {\n\n\t\t\t\ttarget1.copy( closestPoint );\n\t\t\t\ttarget2.copy( p2 );\n\t\t\t\treturn;\n\n\t\t\t} else {\n\n\t\t\t\ttarget1.copy( p );\n\t\t\t\ttarget2.copy( closestPoint2 );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n} )();\n\n\nexport const sphereIntersectTriangle = ( function () {\n\n\t// https://stackoverflow.com/questions/34043955/detect-collision-between-sphere-and-triangle-in-three-js\n\tconst closestPointTemp = new Vector3();\n\tconst projectedPointTemp = new Vector3();\n\tconst planeTemp = new Plane();\n\tconst lineTemp = new Line3();\n\treturn function sphereIntersectTriangle( sphere, triangle ) {\n\n\t\tconst { radius, center } = sphere;\n\t\tconst { a, b, c } = triangle;\n\n\t\t// phase 1\n\t\tlineTemp.start = a;\n\t\tlineTemp.end = b;\n\t\tconst closestPoint1 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\tif ( closestPoint1.distanceTo( center ) <= radius ) return true;\n\n\t\tlineTemp.start = a;\n\t\tlineTemp.end = c;\n\t\tconst closestPoint2 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\tif ( closestPoint2.distanceTo( center ) <= radius ) return true;\n\n\t\tlineTemp.start = b;\n\t\tlineTemp.end = c;\n\t\tconst closestPoint3 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\tif ( closestPoint3.distanceTo( center ) <= radius ) return true;\n\n\t\t// phase 2\n\t\tconst plane = triangle.getPlane( planeTemp );\n\t\tconst dp = Math.abs( plane.distanceToPoint( center ) );\n\t\tif ( dp <= radius ) {\n\n\t\t\tconst pp = plane.projectPoint( center, projectedPointTemp );\n\t\t\tconst cp = triangle.containsPoint( pp );\n\t\t\tif ( cp ) return true;\n\n\t\t}\n\n\t\treturn false;\n\n\t};\n\n} )();\n","import { Triangle, Vector3, Line3, Sphere, Plane } from 'three';\nimport { SeparatingAxisBounds } from './SeparatingAxisBounds.js';\nimport { closestPointsSegmentToSegment, sphereIntersectTriangle } from './MathUtilities.js';\n\nconst DIST_EPSILON = 1e-15;\nfunction isNearZero( value ) {\n\n\treturn Math.abs( value ) < DIST_EPSILON;\n\n}\n\nexport class ExtendedTriangle extends Triangle {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tthis.isExtendedTriangle = true;\n\t\tthis.satAxes = new Array( 4 ).fill().map( () => new Vector3() );\n\t\tthis.satBounds = new Array( 4 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.points = [ this.a, this.b, this.c ];\n\t\tthis.sphere = new Sphere();\n\t\tthis.plane = new Plane();\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn sphereIntersectTriangle( sphere, this );\n\n\t}\n\n\tupdate() {\n\n\t\tconst a = this.a;\n\t\tconst b = this.b;\n\t\tconst c = this.c;\n\t\tconst points = this.points;\n\n\t\tconst satAxes = this.satAxes;\n\t\tconst satBounds = this.satBounds;\n\n\t\tconst axis0 = satAxes[ 0 ];\n\t\tconst sab0 = satBounds[ 0 ];\n\t\tthis.getNormal( axis0 );\n\t\tsab0.setFromPoints( axis0, points );\n\n\t\tconst axis1 = satAxes[ 1 ];\n\t\tconst sab1 = satBounds[ 1 ];\n\t\taxis1.subVectors( a, b );\n\t\tsab1.setFromPoints( axis1, points );\n\n\t\tconst axis2 = satAxes[ 2 ];\n\t\tconst sab2 = satBounds[ 2 ];\n\t\taxis2.subVectors( b, c );\n\t\tsab2.setFromPoints( axis2, points );\n\n\t\tconst axis3 = satAxes[ 3 ];\n\t\tconst sab3 = satBounds[ 3 ];\n\t\taxis3.subVectors( c, a );\n\t\tsab3.setFromPoints( axis3, points );\n\n\t\tthis.sphere.setFromPoints( this.points );\n\t\tthis.plane.setFromNormalAndCoplanarPoint( axis0, a );\n\t\tthis.needsUpdate = false;\n\n\t}\n\n}\n\nExtendedTriangle.prototype.closestPointToSegment = ( function () {\n\n\tconst point1 = new Vector3();\n\tconst point2 = new Vector3();\n\tconst edge = new Line3();\n\n\treturn function distanceToSegment( segment, target1 = null, target2 = null ) {\n\n\t\tconst { start, end } = segment;\n\t\tconst points = this.points;\n\t\tlet distSq;\n\t\tlet closestDistanceSq = Infinity;\n\n\t\t// check the triangle edges\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst nexti = ( i + 1 ) % 3;\n\t\t\tedge.start.copy( points[ i ] );\n\t\t\tedge.end.copy( points[ nexti ] );\n\n\t\t\tclosestPointsSegmentToSegment( edge, segment, point1, point2 );\n\n\t\t\tdistSq = point1.distanceToSquared( point2 );\n\t\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = distSq;\n\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check end points\n\t\tthis.closestPointToPoint( start, point1 );\n\t\tdistSq = start.distanceToSquared( point1 );\n\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\tclosestDistanceSq = distSq;\n\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\tif ( target2 ) target2.copy( start );\n\n\t\t}\n\n\t\tthis.closestPointToPoint( end, point1 );\n\t\tdistSq = end.distanceToSquared( point1 );\n\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\tclosestDistanceSq = distSq;\n\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\tif ( target2 ) target2.copy( end );\n\n\t\t}\n\n\t\treturn Math.sqrt( closestDistanceSq );\n\n\t};\n\n} )();\n\nExtendedTriangle.prototype.intersectsTriangle = ( function () {\n\n\tconst saTri2 = new ExtendedTriangle();\n\tconst arr1 = new Array( 3 );\n\tconst arr2 = new Array( 3 );\n\tconst cachedSatBounds = new SeparatingAxisBounds();\n\tconst cachedSatBounds2 = new SeparatingAxisBounds();\n\tconst cachedAxis = new Vector3();\n\tconst dir1 = new Vector3();\n\tconst dir2 = new Vector3();\n\tconst tempDir = new Vector3();\n\tconst edge = new Line3();\n\tconst edge1 = new Line3();\n\tconst edge2 = new Line3();\n\n\t// TODO: If the triangles are coplanar and intersecting the target is nonsensical. It should at least\n\t// be a line contained by both triangles if not a different special case somehow represented in the return result.\n\treturn function intersectsTriangle( other, target = null, suppressLog = false ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tif ( ! other.isExtendedTriangle ) {\n\n\t\t\tsaTri2.copy( other );\n\t\t\tsaTri2.update();\n\t\t\tother = saTri2;\n\n\t\t} else if ( other.needsUpdate ) {\n\n\t\t\tother.update();\n\n\t\t}\n\n\t\tconst plane1 = this.plane;\n\t\tconst plane2 = other.plane;\n\n\t\tif ( Math.abs( plane1.normal.dot( plane2.normal ) ) > 1.0 - 1e-10 ) {\n\n\t\t\t// perform separating axis intersection test only for coplanar triangles\n\t\t\tconst satBounds1 = this.satBounds;\n\t\t\tconst satAxes1 = this.satAxes;\n\t\t\tarr2[ 0 ] = other.a;\n\t\t\tarr2[ 1 ] = other.b;\n\t\t\tarr2[ 2 ] = other.c;\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\tconst sb = satBounds1[ i ];\n\t\t\t\tconst sa = satAxes1[ i ];\n\t\t\t\tcachedSatBounds.setFromPoints( sa, arr2 );\n\t\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t\t}\n\n\t\t\tconst satBounds2 = other.satBounds;\n\t\t\tconst satAxes2 = other.satAxes;\n\t\t\tarr1[ 0 ] = this.a;\n\t\t\tarr1[ 1 ] = this.b;\n\t\t\tarr1[ 2 ] = this.c;\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\tconst sb = satBounds2[ i ];\n\t\t\t\tconst sa = satAxes2[ i ];\n\t\t\t\tcachedSatBounds.setFromPoints( sa, arr1 );\n\t\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t\t}\n\n\t\t\t// check crossed axes\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\tconst sa1 = satAxes1[ i ];\n\t\t\t\tfor ( let i2 = 0; i2 < 4; i2 ++ ) {\n\n\t\t\t\t\tconst sa2 = satAxes2[ i2 ];\n\t\t\t\t\tcachedAxis.crossVectors( sa1, sa2 );\n\t\t\t\t\tcachedSatBounds.setFromPoints( cachedAxis, arr1 );\n\t\t\t\t\tcachedSatBounds2.setFromPoints( cachedAxis, arr2 );\n\t\t\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( target ) {\n\n\t\t\t\t// TODO find two points that intersect on the edges and make that the result\n\t\t\t\tif ( ! suppressLog ) {\n\n\t\t\t\t\tconsole.warn( 'ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0.' );\n\n\t\t\t\t}\n\n\t\t\t\ttarget.start.set( 0, 0, 0 );\n\t\t\t\ttarget.end.set( 0, 0, 0 );\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t} else {\n\n\t\t\t// find the edge that intersects the other triangle plane\n\t\t\tconst points1 = this.points;\n\t\t\tlet found1 = false;\n\t\t\tlet count1 = 0;\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst p = points1[ i ];\n\t\t\t\tconst pNext = points1[ ( i + 1 ) % 3 ];\n\n\t\t\t\tedge.start.copy( p );\n\t\t\t\tedge.end.copy( pNext );\n\t\t\t\tedge.delta( dir1 );\n\n\t\t\t\tconst targetPoint = found1 ? edge1.start : edge1.end;\n\t\t\t\tconst startIntersects = isNearZero( plane2.distanceToPoint( p ) );\n\t\t\t\tif ( isNearZero( plane2.normal.dot( dir1 ) ) && startIntersects ) {\n\n\t\t\t\t\t// if the edge lies on the plane then take the line\n\t\t\t\t\tedge1.copy( edge );\n\t\t\t\t\tcount1 = 2;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\t// check if the start point is near the plane because \"intersectLine\" is not robust to that case\n\t\t\t\tconst doesIntersect = plane2.intersectLine( edge, targetPoint ) || startIntersects;\n\t\t\t\tif ( doesIntersect && ! isNearZero( targetPoint.distanceTo( pNext ) ) ) {\n\n\t\t\t\t\tcount1 ++;\n\t\t\t\t\tif ( found1 ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfound1 = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( count1 === 1 && other.containsPoint( edge1.end ) ) {\n\n\t\t\t\tif ( target ) {\n\n\t\t\t\t\ttarget.start.copy( edge1.end );\n\t\t\t\t\ttarget.end.copy( edge1.end );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t} else if ( count1 !== 2 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\t// find the other triangles edge that intersects this plane\n\t\t\tconst points2 = other.points;\n\t\t\tlet found2 = false;\n\t\t\tlet count2 = 0;\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst p = points2[ i ];\n\t\t\t\tconst pNext = points2[ ( i + 1 ) % 3 ];\n\n\t\t\t\tedge.start.copy( p );\n\t\t\t\tedge.end.copy( pNext );\n\t\t\t\tedge.delta( dir2 );\n\n\t\t\t\tconst targetPoint = found2 ? edge2.start : edge2.end;\n\t\t\t\tconst startIntersects = isNearZero( plane1.distanceToPoint( p ) );\n\t\t\t\tif ( isNearZero( plane1.normal.dot( dir2 ) ) && startIntersects ) {\n\n\t\t\t\t\t// if the edge lies on the plane then take the line\n\t\t\t\t\tedge2.copy( edge );\n\t\t\t\t\tcount2 = 2;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\t// check if the start point is near the plane because \"intersectLine\" is not robust to that case\n\t\t\t\tconst doesIntersect = plane1.intersectLine( edge, targetPoint ) || startIntersects;\n\t\t\t\tif ( doesIntersect && ! isNearZero( targetPoint.distanceTo( pNext ) ) ) {\n\n\t\t\t\t\tcount2 ++;\n\t\t\t\t\tif ( found2 ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfound2 = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( count2 === 1 && this.containsPoint( edge2.end ) ) {\n\n\t\t\t\tif ( target ) {\n\n\t\t\t\t\ttarget.start.copy( edge2.end );\n\t\t\t\t\ttarget.end.copy( edge2.end );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t} else if ( count2 !== 2 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\t// find swap the second edge so both lines are running the same direction\n\t\t\tedge1.delta( dir1 );\n\t\t\tedge2.delta( dir2 );\n\n\t\t\tif ( dir1.dot( dir2 ) < 0 ) {\n\n\t\t\t\tlet tmp = edge2.start;\n\t\t\t\tedge2.start = edge2.end;\n\t\t\t\tedge2.end = tmp;\n\n\t\t\t}\n\n\t\t\t// check if the edges are overlapping\n\t\t\tconst s1 = edge1.start.dot( dir1 );\n\t\t\tconst e1 = edge1.end.dot( dir1 );\n\t\t\tconst s2 = edge2.start.dot( dir1 );\n\t\t\tconst e2 = edge2.end.dot( dir1 );\n\t\t\tconst separated1 = e1 < s2;\n\t\t\tconst separated2 = s1 < e2;\n\n\t\t\tif ( s1 !== e2 && s2 !== e1 && separated1 === separated2 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\t// assign the target output\n\t\t\tif ( target ) {\n\n\t\t\t\ttempDir.subVectors( edge1.start, edge2.start );\n\t\t\t\tif ( tempDir.dot( dir1 ) > 0 ) {\n\n\t\t\t\t\ttarget.start.copy( edge1.start );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttarget.start.copy( edge2.start );\n\n\t\t\t\t}\n\n\t\t\t\ttempDir.subVectors( edge1.end, edge2.end );\n\t\t\t\tif ( tempDir.dot( dir1 ) < 0 ) {\n\n\t\t\t\t\ttarget.end.copy( edge1.end );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttarget.end.copy( edge2.end );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t};\n\n} )();\n\n\nExtendedTriangle.prototype.distanceToPoint = ( function () {\n\n\tconst target = new Vector3();\n\treturn function distanceToPoint( point ) {\n\n\t\tthis.closestPointToPoint( point, target );\n\t\treturn point.distanceTo( target );\n\n\t};\n\n} )();\n\n\nExtendedTriangle.prototype.distanceToTriangle = ( function () {\n\n\tconst point = new Vector3();\n\tconst point2 = new Vector3();\n\tconst cornerFields = [ 'a', 'b', 'c' ];\n\tconst line1 = new Line3();\n\tconst line2 = new Line3();\n\n\treturn function distanceToTriangle( other, target1 = null, target2 = null ) {\n\n\t\tconst lineTarget = target1 || target2 ? line1 : null;\n\t\tif ( this.intersectsTriangle( other, lineTarget ) ) {\n\n\t\t\tif ( target1 || target2 ) {\n\n\t\t\t\tif ( target1 ) lineTarget.getCenter( target1 );\n\t\t\t\tif ( target2 ) lineTarget.getCenter( target2 );\n\n\t\t\t}\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tlet closestDistanceSq = Infinity;\n\n\t\t// check all point distances\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tlet dist;\n\t\t\tconst field = cornerFields[ i ];\n\t\t\tconst otherVec = other[ field ];\n\t\t\tthis.closestPointToPoint( otherVec, point );\n\n\t\t\tdist = otherVec.distanceToSquared( point );\n\n\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\tif ( target1 ) target1.copy( point );\n\t\t\t\tif ( target2 ) target2.copy( otherVec );\n\n\t\t\t}\n\n\n\t\t\tconst thisVec = this[ field ];\n\t\t\tother.closestPointToPoint( thisVec, point );\n\n\t\t\tdist = thisVec.distanceToSquared( point );\n\n\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\tif ( target1 ) target1.copy( thisVec );\n\t\t\t\tif ( target2 ) target2.copy( point );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst f11 = cornerFields[ i ];\n\t\t\tconst f12 = cornerFields[ ( i + 1 ) % 3 ];\n\t\t\tline1.set( this[ f11 ], this[ f12 ] );\n\t\t\tfor ( let i2 = 0; i2 < 3; i2 ++ ) {\n\n\t\t\t\tconst f21 = cornerFields[ i2 ];\n\t\t\t\tconst f22 = cornerFields[ ( i2 + 1 ) % 3 ];\n\t\t\t\tline2.set( other[ f21 ], other[ f22 ] );\n\n\t\t\t\tclosestPointsSegmentToSegment( line1, line2, point, point2 );\n\n\t\t\t\tconst dist = point.distanceToSquared( point2 );\n\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\tif ( target1 ) target1.copy( point );\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Math.sqrt( closestDistanceSq );\n\n\t};\n\n} )();\n","import { Vector3, Matrix4, Line3 } from 'three';\nimport { SeparatingAxisBounds } from './SeparatingAxisBounds.js';\nimport { ExtendedTriangle } from './ExtendedTriangle.js';\nimport { closestPointsSegmentToSegment } from './MathUtilities.js';\n\nexport class OrientedBox {\n\n\tconstructor( min, max, matrix ) {\n\n\t\tthis.isOrientedBox = true;\n\t\tthis.min = new Vector3();\n\t\tthis.max = new Vector3();\n\t\tthis.matrix = new Matrix4();\n\t\tthis.invMatrix = new Matrix4();\n\t\tthis.points = new Array( 8 ).fill().map( () => new Vector3() );\n\t\tthis.satAxes = new Array( 3 ).fill().map( () => new Vector3() );\n\t\tthis.satBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.alignedSatBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.needsUpdate = false;\n\n\t\tif ( min ) this.min.copy( min );\n\t\tif ( max ) this.max.copy( max );\n\t\tif ( matrix ) this.matrix.copy( matrix );\n\n\t}\n\n\tset( min, max, matrix ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\t\tthis.matrix.copy( matrix );\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\tcopy( other ) {\n\n\t\tthis.min.copy( other.min );\n\t\tthis.max.copy( other.max );\n\t\tthis.matrix.copy( other.matrix );\n\t\tthis.needsUpdate = true;\n\n\t}\n\n}\n\nOrientedBox.prototype.update = ( function () {\n\n\treturn function update() {\n\n\t\tconst matrix = this.matrix;\n\t\tconst min = this.min;\n\t\tconst max = this.max;\n\n\t\tconst points = this.points;\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tconst i = ( ( 1 << 0 ) * x ) | ( ( 1 << 1 ) * y ) | ( ( 1 << 2 ) * z );\n\t\t\t\t\tconst v = points[ i ];\n\t\t\t\t\tv.x = x ? max.x : min.x;\n\t\t\t\t\tv.y = y ? max.y : min.y;\n\t\t\t\t\tv.z = z ? max.z : min.z;\n\n\t\t\t\t\tv.applyMatrix4( matrix );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\t\tconst minVec = points[ 0 ];\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst axis = satAxes[ i ];\n\t\t\tconst sb = satBounds[ i ];\n\t\t\tconst index = 1 << i;\n\t\t\tconst pi = points[ index ];\n\n\t\t\taxis.subVectors( minVec, pi );\n\t\t\tsb.setFromPoints( axis, points );\n\n\t\t}\n\n\t\tconst alignedSatBounds = this.alignedSatBounds;\n\t\talignedSatBounds[ 0 ].setFromPointsField( points, 'x' );\n\t\talignedSatBounds[ 1 ].setFromPointsField( points, 'y' );\n\t\talignedSatBounds[ 2 ].setFromPointsField( points, 'z' );\n\n\t\tthis.invMatrix.copy( this.matrix ).invert();\n\t\tthis.needsUpdate = false;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.intersectsBox = ( function () {\n\n\tconst aabbBounds = new SeparatingAxisBounds();\n\treturn function intersectsBox( box ) {\n\n\t\t// TODO: should this be doing SAT against the AABB?\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tconst min = box.min;\n\t\tconst max = box.max;\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\t\tconst alignedSatBounds = this.alignedSatBounds;\n\n\t\taabbBounds.min = min.x;\n\t\taabbBounds.max = max.x;\n\t\tif ( alignedSatBounds[ 0 ].isSeparated( aabbBounds ) ) return false;\n\n\t\taabbBounds.min = min.y;\n\t\taabbBounds.max = max.y;\n\t\tif ( alignedSatBounds[ 1 ].isSeparated( aabbBounds ) ) return false;\n\n\t\taabbBounds.min = min.z;\n\t\taabbBounds.max = max.z;\n\t\tif ( alignedSatBounds[ 2 ].isSeparated( aabbBounds ) ) return false;\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst axis = satAxes[ i ];\n\t\t\tconst sb = satBounds[ i ];\n\t\t\taabbBounds.setFromBox( axis, box );\n\t\t\tif ( sb.isSeparated( aabbBounds ) ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.intersectsTriangle = ( function () {\n\n\tconst saTri = new ExtendedTriangle();\n\tconst pointsArr = new Array( 3 );\n\tconst cachedSatBounds = new SeparatingAxisBounds();\n\tconst cachedSatBounds2 = new SeparatingAxisBounds();\n\tconst cachedAxis = new Vector3();\n\treturn function intersectsTriangle( triangle ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tif ( ! triangle.isExtendedTriangle ) {\n\n\t\t\tsaTri.copy( triangle );\n\t\t\tsaTri.update();\n\t\t\ttriangle = saTri;\n\n\t\t} else if ( triangle.needsUpdate ) {\n\n\t\t\ttriangle.update();\n\n\t\t}\n\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\n\t\tpointsArr[ 0 ] = triangle.a;\n\t\tpointsArr[ 1 ] = triangle.b;\n\t\tpointsArr[ 2 ] = triangle.c;\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = satBounds[ i ];\n\t\t\tconst sa = satAxes[ i ];\n\t\t\tcachedSatBounds.setFromPoints( sa, pointsArr );\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t}\n\n\t\tconst triSatBounds = triangle.satBounds;\n\t\tconst triSatAxes = triangle.satAxes;\n\t\tconst points = this.points;\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = triSatBounds[ i ];\n\t\t\tconst sa = triSatAxes[ i ];\n\t\t\tcachedSatBounds.setFromPoints( sa, points );\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t}\n\n\t\t// check crossed axes\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sa1 = satAxes[ i ];\n\t\t\tfor ( let i2 = 0; i2 < 4; i2 ++ ) {\n\n\t\t\t\tconst sa2 = triSatAxes[ i2 ];\n\t\t\t\tcachedAxis.crossVectors( sa1, sa2 );\n\t\t\t\tcachedSatBounds.setFromPoints( cachedAxis, pointsArr );\n\t\t\t\tcachedSatBounds2.setFromPoints( cachedAxis, points );\n\t\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.closestPointToPoint = ( function () {\n\n\treturn function closestPointToPoint( point, target1 ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\ttarget1\n\t\t\t.copy( point )\n\t\t\t.applyMatrix4( this.invMatrix )\n\t\t\t.clamp( this.min, this.max )\n\t\t\t.applyMatrix4( this.matrix );\n\n\t\treturn target1;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.distanceToPoint = ( function () {\n\n\tconst target = new Vector3();\n\treturn function distanceToPoint( point ) {\n\n\t\tthis.closestPointToPoint( point, target );\n\t\treturn point.distanceTo( target );\n\n\t};\n\n} )();\n\nOrientedBox.prototype.distanceToBox = ( function () {\n\n\tconst xyzFields = [ 'x', 'y', 'z' ];\n\tconst segments1 = new Array( 12 ).fill().map( () => new Line3() );\n\tconst segments2 = new Array( 12 ).fill().map( () => new Line3() );\n\n\tconst point1 = new Vector3();\n\tconst point2 = new Vector3();\n\n\t// early out if we find a value below threshold\n\treturn function distanceToBox( box, threshold = 0, target1 = null, target2 = null ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tif ( this.intersectsBox( box ) ) {\n\n\t\t\tif ( target1 || target2 ) {\n\n\t\t\t\tbox.getCenter( point2 );\n\t\t\t\tthis.closestPointToPoint( point2, point1 );\n\t\t\t\tbox.closestPointToPoint( point1, point2 );\n\n\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t}\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tconst threshold2 = threshold * threshold;\n\t\tconst min = box.min;\n\t\tconst max = box.max;\n\t\tconst points = this.points;\n\n\n\t\t// iterate over every edge and compare distances\n\t\tlet closestDistanceSq = Infinity;\n\n\t\t// check over all these points\n\t\tfor ( let i = 0; i < 8; i ++ ) {\n\n\t\t\tconst p = points[ i ];\n\t\t\tpoint2.copy( p ).clamp( min, max );\n\n\t\t\tconst dist = p.distanceToSquared( point2 );\n\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\tif ( target1 ) target1.copy( p );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate and check all line segment distances\n\t\tlet count = 0;\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tfor ( let i1 = 0; i1 <= 1; i1 ++ ) {\n\n\t\t\t\tfor ( let i2 = 0; i2 <= 1; i2 ++ ) {\n\n\t\t\t\t\tconst nextIndex = ( i + 1 ) % 3;\n\t\t\t\t\tconst nextIndex2 = ( i + 2 ) % 3;\n\n\t\t\t\t\t// get obb line segments\n\t\t\t\t\tconst index = i1 << nextIndex | i2 << nextIndex2;\n\t\t\t\t\tconst index2 = 1 << i | i1 << nextIndex | i2 << nextIndex2;\n\t\t\t\t\tconst p1 = points[ index ];\n\t\t\t\t\tconst p2 = points[ index2 ];\n\t\t\t\t\tconst line1 = segments1[ count ];\n\t\t\t\t\tline1.set( p1, p2 );\n\n\n\t\t\t\t\t// get aabb line segments\n\t\t\t\t\tconst f1 = xyzFields[ i ];\n\t\t\t\t\tconst f2 = xyzFields[ nextIndex ];\n\t\t\t\t\tconst f3 = xyzFields[ nextIndex2 ];\n\t\t\t\t\tconst line2 = segments2[ count ];\n\t\t\t\t\tconst start = line2.start;\n\t\t\t\t\tconst end = line2.end;\n\n\t\t\t\t\tstart[ f1 ] = min[ f1 ];\n\t\t\t\t\tstart[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\n\t\t\t\t\tstart[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\n\n\t\t\t\t\tend[ f1 ] = max[ f1 ];\n\t\t\t\t\tend[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\n\t\t\t\t\tend[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\n\n\t\t\t\t\tcount ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check all the other boxes point\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tpoint2.x = x ? max.x : min.x;\n\t\t\t\t\tpoint2.y = y ? max.y : min.y;\n\t\t\t\t\tpoint2.z = z ? max.z : min.z;\n\n\t\t\t\t\tthis.closestPointToPoint( point2, point1 );\n\t\t\t\t\tconst dist = point2.distanceToSquared( point1 );\n\t\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < 12; i ++ ) {\n\n\t\t\tconst l1 = segments1[ i ];\n\t\t\tfor ( let i2 = 0; i2 < 12; i2 ++ ) {\n\n\t\t\t\tconst l2 = segments2[ i2 ];\n\t\t\t\tclosestPointsSegmentToSegment( l1, l2, point1, point2 );\n\t\t\t\tconst dist = point1.distanceToSquared( point2 );\n\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Math.sqrt( closestDistanceSq );\n\n\t};\n\n} )();\n","import { Vector3, Vector2, Triangle, DoubleSide, BackSide } from 'three';\n\n// Ripped and modified From THREE.js Mesh raycast\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L115\nconst vA = /* @__PURE__ */ new Vector3();\nconst vB = /* @__PURE__ */ new Vector3();\nconst vC = /* @__PURE__ */ new Vector3();\n\nconst uvA = /* @__PURE__ */ new Vector2();\nconst uvB = /* @__PURE__ */ new Vector2();\nconst uvC = /* @__PURE__ */ new Vector2();\n\nconst intersectionPoint = /* @__PURE__ */ new Vector3();\nfunction checkIntersection( ray, pA, pB, pC, point, side ) {\n\n\tlet intersect;\n\tif ( side === BackSide ) {\n\n\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\n\n\t} else {\n\n\t\tintersect = ray.intersectTriangle( pA, pB, pC, side !== DoubleSide, point );\n\n\t}\n\n\tif ( intersect === null ) return null;\n\n\tconst distance = ray.origin.distanceTo( point );\n\n\treturn {\n\n\t\tdistance: distance,\n\t\tpoint: point.clone(),\n\n\t};\n\n}\n\nfunction checkBufferGeometryIntersection( ray, position, uv, a, b, c, side ) {\n\n\tvA.fromBufferAttribute( position, a );\n\tvB.fromBufferAttribute( position, b );\n\tvC.fromBufferAttribute( position, c );\n\n\tconst intersection = checkIntersection( ray, vA, vB, vC, intersectionPoint, side );\n\n\tif ( intersection ) {\n\n\t\tif ( uv ) {\n\n\t\t\tuvA.fromBufferAttribute( uv, a );\n\t\t\tuvB.fromBufferAttribute( uv, b );\n\t\t\tuvC.fromBufferAttribute( uv, c );\n\n\t\t\tintersection.uv = Triangle.getUV( intersectionPoint, vA, vB, vC, uvA, uvB, uvC, new Vector2( ) );\n\n\t\t}\n\n\t\tconst face = {\n\t\t\ta: a,\n\t\t\tb: b,\n\t\t\tc: c,\n\t\t\tnormal: new Vector3(),\n\t\t\tmaterialIndex: 0\n\t\t};\n\n\t\tTriangle.getNormal( vA, vB, vC, face.normal );\n\n\t\tintersection.face = face;\n\t\tintersection.faceIndex = a;\n\n\t}\n\n\treturn intersection;\n\n}\n\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L258\nfunction intersectTri( geo, side, ray, tri, intersections ) {\n\n\tconst triOffset = tri * 3;\n\tconst a = geo.index.getX( triOffset );\n\tconst b = geo.index.getX( triOffset + 1 );\n\tconst c = geo.index.getX( triOffset + 2 );\n\n\tconst intersection = checkBufferGeometryIntersection( ray, geo.attributes.position, geo.attributes.uv, a, b, c, side );\n\n\tif ( intersection ) {\n\n\t\tintersection.faceIndex = tri;\n\t\tif ( intersections ) intersections.push( intersection );\n\t\treturn intersection;\n\n\t}\n\n\treturn null;\n\n}\n\nexport { intersectTri };\n","import { intersectTri } from './ThreeRayIntersectUtilities.js';\n\nexport function intersectTris( geo, side, ray, offset, count, intersections ) {\n\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tintersectTri( geo, side, ray, i, intersections );\n\n\t}\n\n}\n\nexport function intersectClosestTri( geo, side, ray, offset, count ) {\n\n\tlet dist = Infinity;\n\tlet res = null;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tconst intersection = intersectTri( geo, side, ray, i );\n\t\tif ( intersection && intersection.distance < dist ) {\n\n\t\t\tres = intersection;\n\t\t\tdist = intersection.distance;\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\n// converts the given BVH raycast intersection to align with the three.js raycast\n// structure (include object, world space distance and point).\nexport function convertRaycastIntersect( hit, object, raycaster ) {\n\n\tif ( hit === null ) {\n\n\t\treturn null;\n\n\t}\n\n\thit.point.applyMatrix4( object.matrixWorld );\n\thit.distance = hit.point.distanceTo( raycaster.ray.origin );\n\thit.object = object;\n\n\tif ( hit.distance < raycaster.near || hit.distance > raycaster.far ) {\n\n\t\treturn null;\n\n\t} else {\n\n\t\treturn hit;\n\n\t}\n\n}\n","\nimport { Vector2, Vector3, Triangle } from 'three';\n\n// sets the vertices of triangle `tri` with the 3 vertices after i\nexport function setTriangle( tri, i, index, pos ) {\n\n\tconst ta = tri.a;\n\tconst tb = tri.b;\n\tconst tc = tri.c;\n\n\tlet i0 = i;\n\tlet i1 = i + 1;\n\tlet i2 = i + 2;\n\tif ( index ) {\n\n\t\ti0 = index.getX( i );\n\t\ti1 = index.getX( i + 1 );\n\t\ti2 = index.getX( i + 2 );\n\n\t}\n\n\tta.x = pos.getX( i0 );\n\tta.y = pos.getY( i0 );\n\tta.z = pos.getZ( i0 );\n\n\ttb.x = pos.getX( i1 );\n\ttb.y = pos.getY( i1 );\n\ttb.z = pos.getZ( i1 );\n\n\ttc.x = pos.getX( i2 );\n\ttc.y = pos.getY( i2 );\n\ttc.z = pos.getZ( i2 );\n\n}\n\nexport function iterateOverTriangles(\n\toffset,\n\tcount,\n\tgeometry,\n\tintersectsTriangleFunc,\n\tcontained,\n\tdepth,\n\ttriangle\n) {\n\n\tconst index = geometry.index;\n\tconst pos = geometry.attributes.position;\n\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\tsetTriangle( triangle, i * 3, index, pos );\n\t\ttriangle.needsUpdate = true;\n\n\t\tif ( intersectsTriangleFunc( triangle, i, contained, depth ) ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t}\n\n\treturn false;\n\n}\n\nconst tempV1 = /* @__PURE__ */ new Vector3();\nconst tempV2 = /* @__PURE__ */ new Vector3();\nconst tempV3 = /* @__PURE__ */ new Vector3();\nconst tempUV1 = /* @__PURE__ */ new Vector2();\nconst tempUV2 = /* @__PURE__ */ new Vector2();\nconst tempUV3 = /* @__PURE__ */ new Vector2();\n\nexport function getTriangleHitPointInfo( point, geometry, triangleIndex, target ) {\n\n\tconst indices = geometry.getIndex().array;\n\tconst positions = geometry.getAttribute( 'position' );\n\tconst uvs = geometry.getAttribute( 'uv' );\n\n\tconst a = indices[ triangleIndex * 3 ];\n\tconst b = indices[ triangleIndex * 3 + 1 ];\n\tconst c = indices[ triangleIndex * 3 + 2 ];\n\n\ttempV1.fromBufferAttribute( positions, a );\n\ttempV2.fromBufferAttribute( positions, b );\n\ttempV3.fromBufferAttribute( positions, c );\n\n\t// find the associated material index\n\tlet materialIndex = 0;\n\tconst groups = geometry.groups;\n\tconst firstVertexIndex = triangleIndex * 3;\n\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\t\tconst { start, count } = group;\n\t\tif ( firstVertexIndex >= start && firstVertexIndex < start + count ) {\n\n\t\t\tmaterialIndex = group.materialIndex;\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\t// extract uvs\n\tlet uv = null;\n\tif ( uvs ) {\n\n\t\ttempUV1.fromBufferAttribute( uvs, a );\n\t\ttempUV2.fromBufferAttribute( uvs, b );\n\t\ttempUV3.fromBufferAttribute( uvs, c );\n\n\t\tif ( target && target.uv ) uv = target.uv;\n\t\telse uv = new Vector2();\n\n\t\tTriangle.getUV( point, tempV1, tempV2, tempV3, tempUV1, tempUV2, tempUV3, uv );\n\n\t}\n\n\t// adjust the provided target or create a new one\n\tif ( target ) {\n\n\t\tif ( ! target.face ) target.face = { };\n\t\ttarget.face.a = a;\n\t\ttarget.face.b = b;\n\t\ttarget.face.c = c;\n\t\ttarget.face.materialIndex = materialIndex;\n\t\tif ( ! target.face.normal ) target.face.normal = new Vector3();\n\t\tTriangle.getNormal( tempV1, tempV2, tempV3, target.face.normal );\n\n\t\tif ( uv ) target.uv = uv;\n\n\t\treturn target;\n\n\t} else {\n\n\t\treturn {\n\t\t\tface: {\n\t\t\t\ta: a,\n\t\t\t\tb: b,\n\t\t\t\tc: c,\n\t\t\t\tmaterialIndex: materialIndex,\n\t\t\t\tnormal: Triangle.getNormal( tempV1, tempV2, tempV3, new Vector3() )\n\t\t\t},\n\t\t\tuv: uv\n\t\t};\n\n\t}\n\n}\n","export class PrimitivePool {\n\n\tconstructor( getNewPrimitive ) {\n\n\t\tthis._getNewPrimitive = getNewPrimitive;\n\t\tthis._primitives = [];\n\n\t}\n\n\tgetPrimitive() {\n\n\t\tconst primitives = this._primitives;\n\t\tif ( primitives.length === 0 ) {\n\n\t\t\treturn this._getNewPrimitive();\n\n\t\t} else {\n\n\t\t\treturn primitives.pop();\n\n\t\t}\n\n\t}\n\n\treleasePrimitive( primitive ) {\n\n\t\tthis._primitives.push( primitive );\n\n\t}\n\n}\n","export function IS_LEAF( n16, uint16Array ) {\n\n\treturn uint16Array[ n16 + 15 ] === 0xFFFF;\n\n}\n\nexport function OFFSET( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 6 ];\n\n}\n\nexport function COUNT( n16, uint16Array ) {\n\n\treturn uint16Array[ n16 + 14 ];\n\n}\n\nexport function LEFT_NODE( n32 ) {\n\n\treturn n32 + 8;\n\n}\n\nexport function RIGHT_NODE( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 6 ];\n\n}\n\nexport function SPLIT_AXIS( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 7 ];\n\n}\n\nexport function BOUNDING_DATA_INDEX( n32 ) {\n\n\treturn n32;\n\n}\n","import { Box3, Vector3, Matrix4 } from 'three';\nimport { CONTAINED } from './Constants.js';\n\nimport { OrientedBox } from '../math/OrientedBox.js';\nimport { ExtendedTriangle } from '../math/ExtendedTriangle.js';\nimport { intersectTris, intersectClosestTri } from '../utils/GeometryRayIntersectUtilities.js';\nimport { setTriangle } from '../utils/TriangleUtilities.js';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { PrimitivePool } from '../utils/PrimitivePool.js';\nimport { COUNT, OFFSET, LEFT_NODE, RIGHT_NODE, IS_LEAF, BOUNDING_DATA_INDEX, SPLIT_AXIS } from './nodeBufferFunctions.js';\n\nconst boundingBox = new Box3();\nconst boxIntersection = new Vector3();\nconst xyzFields = [ 'x', 'y', 'z' ];\n\nexport function raycast( nodeIndex32, geometry, side, ray, intersects ) {\n\n\tlet nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\tintersectTris( geometry, side, ray, offset, count, intersects );\n\n\t} else {\n\n\t\tconst leftIndex = LEFT_NODE( nodeIndex32 );\n\t\tif ( intersectRay( leftIndex, float32Array, ray, boxIntersection ) ) {\n\n\t\t\traycast( leftIndex, geometry, side, ray, intersects );\n\n\t\t}\n\n\t\tconst rightIndex = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\tif ( intersectRay( rightIndex, float32Array, ray, boxIntersection ) ) {\n\n\t\t\traycast( rightIndex, geometry, side, ray, intersects );\n\n\t\t}\n\n\t}\n\n}\n\nexport function raycastFirst( nodeIndex32, geometry, side, ray ) {\n\n\tlet nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\t\treturn intersectClosestTri( geometry, side, ray, offset, count );\n\n\t} else {\n\n\t\t// consider the position of the split plane with respect to the oncoming ray; whichever direction\n\t\t// the ray is coming from, look for an intersection among that side of the tree first\n\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\n\t\tconst xyzAxis = xyzFields[ splitAxis ];\n\t\tconst rayDir = ray.direction[ xyzAxis ];\n\t\tconst leftToRight = rayDir >= 0;\n\n\t\t// c1 is the child to check first\n\t\tlet c1, c2;\n\t\tif ( leftToRight ) {\n\n\t\t\tc1 = LEFT_NODE( nodeIndex32 );\n\t\t\tc2 = RIGHT_NODE( nodeIndex32, uint32Array );\n\n\t\t} else {\n\n\t\t\tc1 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\tc2 = LEFT_NODE( nodeIndex32 );\n\n\t\t}\n\n\t\tconst c1Intersection = intersectRay( c1, float32Array, ray, boxIntersection );\n\t\tconst c1Result = c1Intersection ? raycastFirst( c1, geometry, side, ray ) : null;\n\n\t\t// if we got an intersection in the first node and it's closer than the second node's bounding\n\t\t// box, we don't need to consider the second node because it couldn't possibly be a better result\n\t\tif ( c1Result ) {\n\n\t\t\t// check if the point is within the second bounds\n\t\t\t// \"point\" is in the local frame of the bvh\n\t\t\tconst point = c1Result.point[ xyzAxis ];\n\t\t\tconst isOutside = leftToRight ?\n\t\t\t\tpoint <= float32Array[ c2 + splitAxis ] : // min bounding data\n\t\t\t\tpoint >= float32Array[ c2 + splitAxis + 3 ]; // max bounding data\n\n\t\t\tif ( isOutside ) {\n\n\t\t\t\treturn c1Result;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// either there was no intersection in the first node, or there could still be a closer\n\t\t// intersection in the second, so check the second node and then take the better of the two\n\t\tconst c2Intersection = intersectRay( c2, float32Array, ray, boxIntersection );\n\t\tconst c2Result = c2Intersection ? raycastFirst( c2, geometry, side, ray ) : null;\n\n\t\tif ( c1Result && c2Result ) {\n\n\t\t\treturn c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n\n\t\t} else {\n\n\t\t\treturn c1Result || c2Result || null;\n\n\t\t}\n\n\t}\n\n}\n\nexport const shapecast = ( function () {\n\n\tlet _box1, _box2;\n\tconst boxStack = [];\n\tconst boxPool = new PrimitivePool( () => new Box3() );\n\n\treturn function shapecast( ...args ) {\n\n\t\t_box1 = boxPool.getPrimitive();\n\t\t_box2 = boxPool.getPrimitive();\n\t\tboxStack.push( _box1, _box2 );\n\n\t\tconst result = shapecastTraverse( ...args );\n\n\t\tboxPool.releasePrimitive( _box1 );\n\t\tboxPool.releasePrimitive( _box2 );\n\t\tboxStack.pop();\n\t\tboxStack.pop();\n\n\t\tconst length = boxStack.length;\n\t\tif ( length > 0 ) {\n\n\t\t\t_box2 = boxStack[ length - 1 ];\n\t\t\t_box1 = boxStack[ length - 2 ];\n\n\t\t}\n\n\t\treturn result;\n\n\t};\n\n\tfunction shapecastTraverse(\n\t\tnodeIndex32,\n\t\tgeometry,\n\t\tintersectsBoundsFunc,\n\t\tintersectsRangeFunc,\n\t\tnodeScoreFunc = null,\n\t\tnodeIndexByteOffset = 0, // offset for unique node identifier\n\t\tdepth = 0\n\t) {\n\n\t\t// Define these inside the function so it has access to the local variables needed\n\t\t// when converting to the buffer equivalents\n\t\tfunction getLeftOffset( nodeIndex32 ) {\n\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2, uint16Array = _uint16Array, uint32Array = _uint32Array;\n\n\t\t\t// traverse until we find a leaf\n\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\t\tnodeIndex32 = LEFT_NODE( nodeIndex32 );\n\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t}\n\n\t\t\treturn OFFSET( nodeIndex32, uint32Array );\n\n\t\t}\n\n\t\tfunction getRightEndOffset( nodeIndex32 ) {\n\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2, uint16Array = _uint16Array, uint32Array = _uint32Array;\n\n\t\t\t// traverse until we find a leaf\n\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\t\t// adjust offset to point to the right node\n\t\t\t\tnodeIndex32 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t}\n\n\t\t\t// return the end offset of the triangle range\n\t\t\treturn OFFSET( nodeIndex32, uint32Array ) + COUNT( nodeIndex16, uint16Array );\n\n\t\t}\n\n\t\tlet nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;\n\n\t\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\t\tif ( isLeaf ) {\n\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, _box1 );\n\t\t\treturn intersectsRangeFunc( offset, count, false, depth, nodeIndexByteOffset + nodeIndex32, _box1 );\n\n\t\t} else {\n\n\t\t\tconst left = LEFT_NODE( nodeIndex32 );\n\t\t\tconst right = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\tlet c1 = left;\n\t\t\tlet c2 = right;\n\n\t\t\tlet score1, score2;\n\t\t\tlet box1, box2;\n\t\t\tif ( nodeScoreFunc ) {\n\n\t\t\t\tbox1 = _box1;\n\t\t\t\tbox2 = _box2;\n\n\t\t\t\t// bounding data is not offset\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\n\n\t\t\t\tscore1 = nodeScoreFunc( box1 );\n\t\t\t\tscore2 = nodeScoreFunc( box2 );\n\n\t\t\t\tif ( score2 < score1 ) {\n\n\t\t\t\t\tc1 = right;\n\t\t\t\t\tc2 = left;\n\n\t\t\t\t\tconst temp = score1;\n\t\t\t\t\tscore1 = score2;\n\t\t\t\t\tscore2 = temp;\n\n\t\t\t\t\tbox1 = box2;\n\t\t\t\t\t// box2 is always set before use below\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Check box 1 intersection\n\t\t\tif ( ! box1 ) {\n\n\t\t\t\tbox1 = _box1;\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\n\n\t\t\t}\n\n\t\t\tconst isC1Leaf = IS_LEAF( c1 * 2, uint16Array );\n\t\t\tconst c1Intersection = intersectsBoundsFunc( box1, isC1Leaf, score1, depth + 1, nodeIndexByteOffset + c1 );\n\n\t\t\tlet c1StopTraversal;\n\t\t\tif ( c1Intersection === CONTAINED ) {\n\n\t\t\t\tconst offset = getLeftOffset( c1 );\n\t\t\t\tconst end = getRightEndOffset( c1 );\n\t\t\t\tconst count = end - offset;\n\n\t\t\t\tc1StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c1, box1 );\n\n\t\t\t} else {\n\n\t\t\t\tc1StopTraversal =\n\t\t\t\t\tc1Intersection &&\n\t\t\t\t\tshapecastTraverse(\n\t\t\t\t\t\tc1,\n\t\t\t\t\t\tgeometry,\n\t\t\t\t\t\tintersectsBoundsFunc,\n\t\t\t\t\t\tintersectsRangeFunc,\n\t\t\t\t\t\tnodeScoreFunc,\n\t\t\t\t\t\tnodeIndexByteOffset,\n\t\t\t\t\t\tdepth + 1\n\t\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tif ( c1StopTraversal ) return true;\n\n\t\t\t// Check box 2 intersection\n\t\t\t// cached box2 will have been overwritten by previous traversal\n\t\t\tbox2 = _box2;\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\n\n\t\t\tconst isC2Leaf = IS_LEAF( c2 * 2, uint16Array );\n\t\t\tconst c2Intersection = intersectsBoundsFunc( box2, isC2Leaf, score2, depth + 1, nodeIndexByteOffset + c2 );\n\n\t\t\tlet c2StopTraversal;\n\t\t\tif ( c2Intersection === CONTAINED ) {\n\n\t\t\t\tconst offset = getLeftOffset( c2 );\n\t\t\t\tconst end = getRightEndOffset( c2 );\n\t\t\t\tconst count = end - offset;\n\n\t\t\t\tc2StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c2, box2 );\n\n\t\t\t} else {\n\n\t\t\t\tc2StopTraversal =\n\t\t\t\t\tc2Intersection &&\n\t\t\t\t\tshapecastTraverse(\n\t\t\t\t\t\tc2,\n\t\t\t\t\t\tgeometry,\n\t\t\t\t\t\tintersectsBoundsFunc,\n\t\t\t\t\t\tintersectsRangeFunc,\n\t\t\t\t\t\tnodeScoreFunc,\n\t\t\t\t\t\tnodeIndexByteOffset,\n\t\t\t\t\t\tdepth + 1\n\t\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tif ( c2StopTraversal ) return true;\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n} )();\n\nexport const intersectsGeometry = ( function () {\n\n\tconst triangle = new ExtendedTriangle();\n\tconst triangle2 = new ExtendedTriangle();\n\tconst invertedMat = new Matrix4();\n\n\tconst obb = new OrientedBox();\n\tconst obb2 = new OrientedBox();\n\n\treturn function intersectsGeometry( nodeIndex32, geometry, otherGeometry, geometryToBvh, cachedObb = null ) {\n\n\t\tlet nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;\n\n\t\tif ( cachedObb === null ) {\n\n\t\t\tif ( ! otherGeometry.boundingBox ) {\n\n\t\t\t\totherGeometry.computeBoundingBox();\n\n\t\t\t}\n\n\t\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\t\t\tcachedObb = obb;\n\n\t\t}\n\n\t\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\t\tif ( isLeaf ) {\n\n\t\t\tconst thisGeometry = geometry;\n\t\t\tconst thisIndex = thisGeometry.index;\n\t\t\tconst thisPos = thisGeometry.attributes.position;\n\n\t\t\tconst index = otherGeometry.index;\n\t\t\tconst pos = otherGeometry.attributes.position;\n\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\t\t// get the inverse of the geometry matrix so we can transform our triangles into the\n\t\t\t// geometry space we're trying to test. We assume there are fewer triangles being checked\n\t\t\t// here.\n\t\t\tinvertedMat.copy( geometryToBvh ).invert();\n\n\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, obb2 );\n\t\t\t\tobb2.matrix.copy( invertedMat );\n\t\t\t\tobb2.needsUpdate = true;\n\n\t\t\t\tconst res = otherGeometry.boundsTree.shapecast( {\n\n\t\t\t\t\tintersectsBounds: box => obb2.intersectsBox( box ),\n\n\t\t\t\t\tintersectsTriangle: tri => {\n\n\t\t\t\t\t\ttri.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttri.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttri.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttri.needsUpdate = true;\n\n\t\t\t\t\t\tfor ( let i = offset * 3, l = ( count + offset ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\t\t\t\tsetTriangle( triangle2, i, thisIndex, thisPos );\n\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\t\t\t\t\t\t\tif ( tri.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\treturn res;\n\n\t\t\t} else {\n\n\t\t\t\tfor ( let i = offset * 3, l = ( count + offset * 3 ); i < l; i += 3 ) {\n\n\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\t\tsetTriangle( triangle, i, thisIndex, thisPos );\n\t\t\t\t\ttriangle.a.applyMatrix4( invertedMat );\n\t\t\t\t\ttriangle.b.applyMatrix4( invertedMat );\n\t\t\t\t\ttriangle.c.applyMatrix4( invertedMat );\n\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\tfor ( let i2 = 0, l2 = index.count; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\t\tsetTriangle( triangle2, i2, index, pos );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\tif ( triangle.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst left = nodeIndex32 + 8;\n\t\t\tconst right = uint32Array[ nodeIndex32 + 6 ];\n\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( left ), float32Array, boundingBox );\n\t\t\tconst leftIntersection =\n\t\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t\tintersectsGeometry( left, geometry, otherGeometry, geometryToBvh, cachedObb );\n\n\t\t\tif ( leftIntersection ) return true;\n\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( right ), float32Array, boundingBox );\n\t\t\tconst rightIntersection =\n\t\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t\tintersectsGeometry( right, geometry, otherGeometry, geometryToBvh, cachedObb );\n\n\t\t\tif ( rightIntersection ) return true;\n\n\t\t\treturn false;\n\n\t\t}\n\n\t};\n\n} )();\n\nfunction intersectRay( nodeIndex32, array, ray, target ) {\n\n\tarrayToBox( nodeIndex32, array, boundingBox );\n\treturn ray.intersectBox( boundingBox, target );\n\n}\n\nconst bufferStack = [];\nlet _prevBuffer;\nlet _float32Array;\nlet _uint16Array;\nlet _uint32Array;\nexport function setBuffer( buffer ) {\n\n\tif ( _prevBuffer ) {\n\n\t\tbufferStack.push( _prevBuffer );\n\n\t}\n\n\t_prevBuffer = buffer;\n\t_float32Array = new Float32Array( buffer );\n\t_uint16Array = new Uint16Array( buffer );\n\t_uint32Array = new Uint32Array( buffer );\n\n}\n\nexport function clearBuffer() {\n\n\t_prevBuffer = null;\n\t_float32Array = null;\n\t_uint16Array = null;\n\t_uint32Array = null;\n\n\tif ( bufferStack.length ) {\n\n\t\tsetBuffer( bufferStack.pop() );\n\n\t}\n\n}\n","import { Vector3, BufferAttribute, Box3, FrontSide, Matrix4 } from 'three';\nimport { CENTER, BYTES_PER_NODE, IS_LEAFNODE_FLAG } from './Constants.js';\nimport { buildPackedTree } from './buildFunctions.js';\nimport {\n\traycast,\n\traycastFirst,\n\tshapecast,\n\tintersectsGeometry,\n\tsetBuffer,\n\tclearBuffer,\n} from './castFunctions.js';\nimport { OrientedBox } from '../math/OrientedBox.js';\nimport { ExtendedTriangle } from '../math/ExtendedTriangle.js';\nimport { PrimitivePool } from '../utils/PrimitivePool.js';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { iterateOverTriangles, setTriangle } from '../utils/TriangleUtilities.js';\n\nconst SKIP_GENERATION = Symbol( 'skip tree generation' );\n\nconst aabb = /* @__PURE__ */ new Box3();\nconst aabb2 = /* @__PURE__ */ new Box3();\nconst tempMatrix = /* @__PURE__ */ new Matrix4();\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\nconst temp = /* @__PURE__ */ new Vector3();\nconst temp1 = /* @__PURE__ */ new Vector3();\nconst temp2 = /* @__PURE__ */ new Vector3();\nconst temp3 = /* @__PURE__ */ new Vector3();\nconst temp4 = /* @__PURE__ */ new Vector3();\nconst tempBox = /* @__PURE__ */ new Box3();\nconst trianglePool = /* @__PURE__ */ new PrimitivePool( () => new ExtendedTriangle() );\n\nexport class MeshBVH {\n\n\tstatic serialize( bvh, options = {} ) {\n\n\t\tif ( options.isBufferGeometry ) {\n\n\t\t\tconsole.warn( 'MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature.' );\n\n\t\t\treturn MeshBVH.serialize(\n\t\t\t\targuments[ 0 ],\n\t\t\t\t{\n\t\t\t\t\tcloneBuffers: arguments[ 2 ] === undefined ? true : arguments[ 2 ],\n\t\t\t\t}\n\t\t\t);\n\n\t\t}\n\n\t\toptions = {\n\t\t\tcloneBuffers: true,\n\t\t\t...options,\n\t\t};\n\n\t\tconst geometry = bvh.geometry;\n\t\tconst rootData = bvh._roots;\n\t\tconst indexAttribute = geometry.getIndex();\n\t\tlet result;\n\t\tif ( options.cloneBuffers ) {\n\n\t\t\tresult = {\n\t\t\t\troots: rootData.map( root => root.slice() ),\n\t\t\t\tindex: indexAttribute.array.slice(),\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tresult = {\n\t\t\t\troots: rootData,\n\t\t\t\tindex: indexAttribute.array,\n\t\t\t};\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tstatic deserialize( data, geometry, options = {} ) {\n\n\t\tif ( typeof options === 'boolean' ) {\n\n\t\t\tconsole.warn( 'MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature.' );\n\n\t\t\treturn MeshBVH.deserialize(\n\t\t\t\targuments[ 0 ],\n\t\t\t\targuments[ 1 ],\n\t\t\t\t{\n\t\t\t\t\tsetIndex: arguments[ 2 ] === undefined ? true : arguments[ 2 ],\n\t\t\t\t}\n\t\t\t);\n\n\t\t}\n\n\t\toptions = {\n\t\t\tsetIndex: true,\n\t\t\t...options,\n\t\t};\n\n\t\tconst { index, roots } = data;\n\t\tconst bvh = new MeshBVH( geometry, { ...options, [ SKIP_GENERATION ]: true } );\n\t\tbvh._roots = roots;\n\n\t\tif ( options.setIndex ) {\n\n\t\t\tconst indexAttribute = geometry.getIndex();\n\t\t\tif ( indexAttribute === null ) {\n\n\t\t\t\tconst newIndex = new BufferAttribute( data.index, 1, false );\n\t\t\t\tgeometry.setIndex( newIndex );\n\n\t\t\t} else if ( indexAttribute.array !== index ) {\n\n\t\t\t\tindexAttribute.array.set( index );\n\t\t\t\tindexAttribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bvh;\n\n\t}\n\n\tconstructor( geometry, options = {} ) {\n\n\t\tif ( ! geometry.isBufferGeometry ) {\n\n\t\t\tthrow new Error( 'MeshBVH: Only BufferGeometries are supported.' );\n\n\t\t} else if ( geometry.index && geometry.index.isInterleavedBufferAttribute ) {\n\n\t\t\tthrow new Error( 'MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.' );\n\n\t\t}\n\n\t\t// default options\n\t\toptions = Object.assign( {\n\n\t\t\tstrategy: CENTER,\n\t\t\tmaxDepth: 40,\n\t\t\tmaxLeafTris: 10,\n\t\t\tverbose: true,\n\t\t\tuseSharedArrayBuffer: false,\n\t\t\tsetBoundingBox: true,\n\t\t\tonProgress: null,\n\n\t\t\t// undocumented options\n\n\t\t\t// Whether to skip generating the tree. Used for deserialization.\n\t\t\t[ SKIP_GENERATION ]: false,\n\n\t\t}, options );\n\n\t\tif ( options.useSharedArrayBuffer && typeof SharedArrayBuffer === 'undefined' ) {\n\n\t\t\tthrow new Error( 'MeshBVH: SharedArrayBuffer is not available.' );\n\n\t\t}\n\n\t\tthis._roots = null;\n\t\tif ( ! options[ SKIP_GENERATION ] ) {\n\n\t\t\tthis._roots = buildPackedTree( geometry, options );\n\n\t\t\tif ( ! geometry.boundingBox && options.setBoundingBox ) {\n\n\t\t\t\tgeometry.boundingBox = this.getBoundingBox( new Box3() );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// retain references to the geometry so we can use them it without having to\n\t\t// take a geometry reference in every function.\n\t\tthis.geometry = geometry;\n\n\t}\n\n\trefit( nodeIndices = null ) {\n\n\t\tif ( nodeIndices && Array.isArray( nodeIndices ) ) {\n\n\t\t\tnodeIndices = new Set( nodeIndices );\n\n\t\t}\n\n\t\tconst geometry = this.geometry;\n\t\tconst indexArr = geometry.index.array;\n\t\tconst posAttr = geometry.attributes.position;\n\n\t\tlet buffer, uint32Array, uint16Array, float32Array;\n\t\tlet byteOffset = 0;\n\t\tconst roots = this._roots;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tbuffer = roots[ i ];\n\t\t\tuint32Array = new Uint32Array( buffer );\n\t\t\tuint16Array = new Uint16Array( buffer );\n\t\t\tfloat32Array = new Float32Array( buffer );\n\n\t\t\t_traverse( 0, byteOffset );\n\t\t\tbyteOffset += buffer.byteLength;\n\n\t\t}\n\n\t\tfunction _traverse( node32Index, byteOffset, force = false ) {\n\n\t\t\tconst node16Index = node32Index * 2;\n\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\t\tif ( isLeaf ) {\n\n\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\n\t\t\t\tlet minx = Infinity;\n\t\t\t\tlet miny = Infinity;\n\t\t\t\tlet minz = Infinity;\n\t\t\t\tlet maxx = - Infinity;\n\t\t\t\tlet maxy = - Infinity;\n\t\t\t\tlet maxz = - Infinity;\n\n\t\t\t\tfor ( let i = 3 * offset, l = 3 * ( offset + count ); i < l; i ++ ) {\n\n\t\t\t\t\tconst index = indexArr[ i ];\n\t\t\t\t\tconst x = posAttr.getX( index );\n\t\t\t\t\tconst y = posAttr.getY( index );\n\t\t\t\t\tconst z = posAttr.getZ( index );\n\n\t\t\t\t\tif ( x < minx ) minx = x;\n\t\t\t\t\tif ( x > maxx ) maxx = x;\n\n\t\t\t\t\tif ( y < miny ) miny = y;\n\t\t\t\t\tif ( y > maxy ) maxy = y;\n\n\t\t\t\t\tif ( z < minz ) minz = z;\n\t\t\t\t\tif ( z > maxz ) maxz = z;\n\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\tfloat32Array[ node32Index + 0 ] !== minx ||\n\t\t\t\t\tfloat32Array[ node32Index + 1 ] !== miny ||\n\t\t\t\t\tfloat32Array[ node32Index + 2 ] !== minz ||\n\n\t\t\t\t\tfloat32Array[ node32Index + 3 ] !== maxx ||\n\t\t\t\t\tfloat32Array[ node32Index + 4 ] !== maxy ||\n\t\t\t\t\tfloat32Array[ node32Index + 5 ] !== maxz\n\t\t\t\t) {\n\n\t\t\t\t\tfloat32Array[ node32Index + 0 ] = minx;\n\t\t\t\t\tfloat32Array[ node32Index + 1 ] = miny;\n\t\t\t\t\tfloat32Array[ node32Index + 2 ] = minz;\n\n\t\t\t\t\tfloat32Array[ node32Index + 3 ] = maxx;\n\t\t\t\t\tfloat32Array[ node32Index + 4 ] = maxy;\n\t\t\t\t\tfloat32Array[ node32Index + 5 ] = maxz;\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconst left = node32Index + 8;\n\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\n\t\t\t\t// the identifying node indices provided by the shapecast function include offsets of all\n\t\t\t\t// root buffers to guarantee they're unique between roots so offset left and right indices here.\n\t\t\t\tconst offsetLeft = left + byteOffset;\n\t\t\t\tconst offsetRight = right + byteOffset;\n\t\t\t\tlet forceChildren = force;\n\t\t\t\tlet includesLeft = false;\n\t\t\t\tlet includesRight = false;\n\n\t\t\t\tif ( nodeIndices ) {\n\n\t\t\t\t\t// if we see that neither the left or right child are included in the set that need to be updated\n\t\t\t\t\t// then we assume that all children need to be updated.\n\t\t\t\t\tif ( ! forceChildren ) {\n\n\t\t\t\t\t\tincludesLeft = nodeIndices.has( offsetLeft );\n\t\t\t\t\t\tincludesRight = nodeIndices.has( offsetRight );\n\t\t\t\t\t\tforceChildren = ! includesLeft && ! includesRight;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tincludesLeft = true;\n\t\t\t\t\tincludesRight = true;\n\n\t\t\t\t}\n\n\t\t\t\tconst traverseLeft = forceChildren || includesLeft;\n\t\t\t\tconst traverseRight = forceChildren || includesRight;\n\n\t\t\t\tlet leftChange = false;\n\t\t\t\tif ( traverseLeft ) {\n\n\t\t\t\t\tleftChange = _traverse( left, byteOffset, forceChildren );\n\n\t\t\t\t}\n\n\t\t\t\tlet rightChange = false;\n\t\t\t\tif ( traverseRight ) {\n\n\t\t\t\t\trightChange = _traverse( right, byteOffset, forceChildren );\n\n\t\t\t\t}\n\n\t\t\t\tconst didChange = leftChange || rightChange;\n\t\t\t\tif ( didChange ) {\n\n\t\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\tconst lefti = left + i;\n\t\t\t\t\t\tconst righti = right + i;\n\t\t\t\t\t\tconst minLeftValue = float32Array[ lefti ];\n\t\t\t\t\t\tconst maxLeftValue = float32Array[ lefti + 3 ];\n\t\t\t\t\t\tconst minRightValue = float32Array[ righti ];\n\t\t\t\t\t\tconst maxRightValue = float32Array[ righti + 3 ];\n\n\t\t\t\t\t\tfloat32Array[ node32Index + i ] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n\t\t\t\t\t\tfloat32Array[ node32Index + i + 3 ] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn didChange;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttraverse( callback, rootIndex = 0 ) {\n\n\t\tconst buffer = this._roots[ rootIndex ];\n\t\tconst uint32Array = new Uint32Array( buffer );\n\t\tconst uint16Array = new Uint16Array( buffer );\n\t\t_traverse( 0 );\n\n\t\tfunction _traverse( node32Index, depth = 0 ) {\n\n\t\t\tconst node16Index = node32Index * 2;\n\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\t\tif ( isLeaf ) {\n\n\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\t\t\t\tcallback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), offset, count );\n\n\t\t\t} else {\n\n\t\t\t\t// TODO: use node functions here\n\t\t\t\tconst left = node32Index + BYTES_PER_NODE / 4;\n\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst splitAxis = uint32Array[ node32Index + 7 ];\n\t\t\t\tconst stopTraversal = callback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), splitAxis );\n\n\t\t\t\tif ( ! stopTraversal ) {\n\n\t\t\t\t\t_traverse( left, depth + 1 );\n\t\t\t\t\t_traverse( right, depth + 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/* Core Cast Functions */\n\traycast( ray, materialOrSide = FrontSide ) {\n\n\t\tconst roots = this._roots;\n\t\tconst geometry = this.geometry;\n\t\tconst intersects = [];\n\t\tconst isMaterial = materialOrSide.isMaterial;\n\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\n\n\t\tconst groups = geometry.groups;\n\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\n\t\t\tconst startCount = intersects.length;\n\n\t\t\tsetBuffer( roots[ i ] );\n\t\t\traycast( 0, geometry, materialSide, ray, intersects );\n\t\t\tclearBuffer();\n\n\t\t\tif ( isArrayMaterial ) {\n\n\t\t\t\tconst materialIndex = groups[ i ].materialIndex;\n\t\t\t\tfor ( let j = startCount, jl = intersects.length; j < jl; j ++ ) {\n\n\t\t\t\t\tintersects[ j ].face.materialIndex = materialIndex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn intersects;\n\n\t}\n\n\traycastFirst( ray, materialOrSide = FrontSide ) {\n\n\t\tconst roots = this._roots;\n\t\tconst geometry = this.geometry;\n\t\tconst isMaterial = materialOrSide.isMaterial;\n\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\n\n\t\tlet closestResult = null;\n\n\t\tconst groups = geometry.groups;\n\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\n\n\t\t\tsetBuffer( roots[ i ] );\n\t\t\tconst result = raycastFirst( 0, geometry, materialSide, ray );\n\t\t\tclearBuffer();\n\n\t\t\tif ( result != null && ( closestResult == null || result.distance < closestResult.distance ) ) {\n\n\t\t\t\tclosestResult = result;\n\t\t\t\tif ( isArrayMaterial ) {\n\n\t\t\t\t\tresult.face.materialIndex = groups[ i ].materialIndex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn closestResult;\n\n\t}\n\n\tintersectsGeometry( otherGeometry, geomToMesh ) {\n\n\t\tconst geometry = this.geometry;\n\t\tlet result = false;\n\t\tfor ( const root of this._roots ) {\n\n\t\t\tsetBuffer( root );\n\t\t\tresult = intersectsGeometry( 0, geometry, otherGeometry, geomToMesh );\n\t\t\tclearBuffer();\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tshapecast( callbacks, _intersectsTriangleFunc, _orderNodesFunc ) {\n\n\t\tconst geometry = this.geometry;\n\t\tif ( callbacks instanceof Function ) {\n\n\t\t\tif ( _intersectsTriangleFunc ) {\n\n\t\t\t\t// Support the previous function signature that provided three sequential index buffer\n\t\t\t\t// indices here.\n\t\t\t\tconst originalTriangleFunc = _intersectsTriangleFunc;\n\t\t\t\t_intersectsTriangleFunc = ( tri, index, contained, depth ) => {\n\n\t\t\t\t\tconst i3 = index * 3;\n\t\t\t\t\treturn originalTriangleFunc( tri, i3, i3 + 1, i3 + 2, contained, depth );\n\n\t\t\t\t};\n\n\n\t\t\t}\n\n\t\t\tcallbacks = {\n\n\t\t\t\tboundsTraverseOrder: _orderNodesFunc,\n\t\t\t\tintersectsBounds: callbacks,\n\t\t\t\tintersectsTriangle: _intersectsTriangleFunc,\n\t\t\t\tintersectsRange: null,\n\n\t\t\t};\n\n\t\t\tconsole.warn( 'MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.' );\n\n\t\t}\n\n\t\tconst triangle = trianglePool.getPrimitive();\n\t\tlet {\n\t\t\tboundsTraverseOrder,\n\t\t\tintersectsBounds,\n\t\t\tintersectsRange,\n\t\t\tintersectsTriangle,\n\t\t} = callbacks;\n\n\t\tif ( intersectsRange && intersectsTriangle ) {\n\n\t\t\tconst originalIntersectsRange = intersectsRange;\n\t\t\tintersectsRange = ( offset, count, contained, depth, nodeIndex ) => {\n\n\t\t\t\tif ( ! originalIntersectsRange( offset, count, contained, depth, nodeIndex ) ) {\n\n\t\t\t\t\treturn iterateOverTriangles( offset, count, geometry, intersectsTriangle, contained, depth, triangle );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t};\n\n\t\t} else if ( ! intersectsRange ) {\n\n\t\t\tif ( intersectsTriangle ) {\n\n\t\t\t\tintersectsRange = ( offset, count, contained, depth ) => {\n\n\t\t\t\t\treturn iterateOverTriangles( offset, count, geometry, intersectsTriangle, contained, depth, triangle );\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tintersectsRange = ( offset, count, contained ) => {\n\n\t\t\t\t\treturn contained;\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet result = false;\n\t\tlet byteOffset = 0;\n\t\tfor ( const root of this._roots ) {\n\n\t\t\tsetBuffer( root );\n\t\t\tresult = shapecast( 0, geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset );\n\t\t\tclearBuffer();\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tbyteOffset += root.byteLength;\n\n\t\t}\n\n\t\ttrianglePool.releasePrimitive( triangle );\n\n\t\treturn result;\n\n\t}\n\n\tbvhcast( otherBvh, matrixToLocal, callbacks ) {\n\n\t\t// BVHCast function for intersecting two BVHs against each other. Ultimately just uses two recursive shapecast calls rather\n\t\t// than an approach that walks down the tree (see bvhcast.js file for more info).\n\n\t\tlet {\n\t\t\tintersectsRanges,\n\t\t\tintersectsTriangles,\n\t\t} = callbacks;\n\n\t\tconst indexAttr = this.geometry.index;\n\t\tconst positionAttr = this.geometry.attributes.position;\n\n\t\tconst otherIndexAttr = otherBvh.geometry.index;\n\t\tconst otherPositionAttr = otherBvh.geometry.attributes.position;\n\n\t\ttempMatrix.copy( matrixToLocal ).invert();\n\n\t\tconst triangle = trianglePool.getPrimitive();\n\t\tconst triangle2 = trianglePool.getPrimitive();\n\n\t\tif ( intersectsTriangles ) {\n\n\t\t\tfunction iterateOverDoubleTriangles( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) {\n\n\t\t\t\tfor ( let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\tsetTriangle( triangle2, i2 * 3, otherIndexAttr, otherPositionAttr );\n\t\t\t\t\ttriangle2.a.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.b.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.c.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\tfor ( let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1 ++ ) {\n\n\t\t\t\t\t\tsetTriangle( triangle, i1 * 3, indexAttr, positionAttr );\n\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\tif ( intersectsTriangles( triangle, triangle2, i1, i2, depth1, index1, depth2, index2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\tif ( intersectsRanges ) {\n\n\t\t\t\tconst originalIntersectsRanges = intersectsRanges;\n\t\t\t\tintersectsRanges = function ( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) {\n\n\t\t\t\t\tif ( ! originalIntersectsRanges( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) ) {\n\n\t\t\t\t\t\treturn iterateOverDoubleTriangles( offset1, count1, offset2, count2, depth1, index1, depth2, index2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tintersectsRanges = iterateOverDoubleTriangles;\n\n\t\t\t}\n\n\t\t}\n\n\t\totherBvh.getBoundingBox( aabb2 );\n\t\taabb2.applyMatrix4( matrixToLocal );\n\t\tconst result = this.shapecast( {\n\n\t\t\tintersectsBounds: box => aabb2.intersectsBox( box ),\n\n\t\t\tintersectsRange: ( offset1, count1, contained, depth1, nodeIndex1, box ) => {\n\n\t\t\t\taabb.copy( box );\n\t\t\t\taabb.applyMatrix4( tempMatrix );\n\t\t\t\treturn otherBvh.shapecast( {\n\n\t\t\t\t\tintersectsBounds: box => aabb.intersectsBox( box ),\n\n\t\t\t\t\tintersectsRange: ( offset2, count2, contained, depth2, nodeIndex2 ) => {\n\n\t\t\t\t\t\treturn intersectsRanges( offset1, count1, offset2, count2, depth1, nodeIndex1, depth2, nodeIndex2 );\n\n\t\t\t\t\t},\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} );\n\n\t\ttrianglePool.releasePrimitive( triangle );\n\t\ttrianglePool.releasePrimitive( triangle2 );\n\t\treturn result;\n\n\t}\n\n\t/* Derived Cast Functions */\n\tintersectsBox( box, boxToMesh ) {\n\n\t\tobb.set( box.min, box.max, boxToMesh );\n\t\tobb.needsUpdate = true;\n\n\t\treturn this.shapecast(\n\t\t\t{\n\t\t\t\tintersectsBounds: box => obb.intersectsBox( box ),\n\t\t\t\tintersectsTriangle: tri => obb.intersectsTriangle( tri )\n\t\t\t}\n\t\t);\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn this.shapecast(\n\t\t\t{\n\t\t\t\tintersectsBounds: box => sphere.intersectsBox( box ),\n\t\t\t\tintersectsTriangle: tri => tri.intersectsSphere( sphere )\n\t\t\t}\n\t\t);\n\n\t}\n\n\tclosestPointToGeometry( otherGeometry, geometryToBvh, target1 = { }, target2 = { }, minThreshold = 0, maxThreshold = Infinity ) {\n\n\t\tif ( ! otherGeometry.boundingBox ) {\n\n\t\t\totherGeometry.computeBoundingBox();\n\n\t\t}\n\n\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\t\tobb.needsUpdate = true;\n\n\t\tconst geometry = this.geometry;\n\t\tconst pos = geometry.attributes.position;\n\t\tconst index = geometry.index;\n\t\tconst otherPos = otherGeometry.attributes.position;\n\t\tconst otherIndex = otherGeometry.index;\n\t\tconst triangle = trianglePool.getPrimitive();\n\t\tconst triangle2 = trianglePool.getPrimitive();\n\n\t\tlet tempTarget1 = temp1;\n\t\tlet tempTargetDest1 = temp2;\n\t\tlet tempTarget2 = null;\n\t\tlet tempTargetDest2 = null;\n\n\t\tif ( target2 ) {\n\n\t\t\ttempTarget2 = temp3;\n\t\t\ttempTargetDest2 = temp4;\n\n\t\t}\n\n\t\tlet closestDistance = Infinity;\n\t\tlet closestDistanceTriIndex = null;\n\t\tlet closestDistanceOtherTriIndex = null;\n\t\ttempMatrix.copy( geometryToBvh ).invert();\n\t\tobb2.matrix.copy( tempMatrix );\n\t\tthis.shapecast(\n\t\t\t{\n\n\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\treturn obb.distanceToBox( box );\n\n\t\t\t\t},\n\n\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\tif ( score < closestDistance && score < maxThreshold ) {\n\n\t\t\t\t\t\t// if we know the triangles of this bounds will be intersected next then\n\t\t\t\t\t\t// save the bounds to use during triangle checks.\n\t\t\t\t\t\tif ( isLeaf ) {\n\n\t\t\t\t\t\t\tobb2.min.copy( box.min );\n\t\t\t\t\t\t\tobb2.max.copy( box.max );\n\t\t\t\t\t\t\tobb2.needsUpdate = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t},\n\n\t\t\t\tintersectsRange: ( offset, count ) => {\n\n\t\t\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\t\t\t// if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n\t\t\t\t\t\t// the closest bounds in the other geometry to check.\n\t\t\t\t\t\treturn otherGeometry.boundsTree.shapecast( {\n\t\t\t\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\t\t\t\treturn obb2.distanceToBox( box );\n\n\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\t\t\t\treturn score < closestDistance && score < maxThreshold;\n\n\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\tintersectsRange: ( otherOffset, otherCount ) => {\n\n\t\t\t\t\t\t\t\tfor ( let i2 = otherOffset * 3, l2 = ( otherOffset + otherCount ) * 3; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\t\t\t\t\tsetTriangle( triangle2, i2, otherIndex, otherPos );\n\t\t\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\tfor ( let i = offset * 3, l = ( offset + count ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\t\t\t\tsetTriangle( triangle, i, index, pos );\n\t\t\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i / 3;\n\t\t\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2 / 3;\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// If no bounds tree then we'll just check every triangle.\n\t\t\t\t\t\tconst triCount = otherIndex ? otherIndex.count : otherPos.count;\n\t\t\t\t\t\tfor ( let i2 = 0, l2 = triCount; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\t\t\tsetTriangle( triangle2, i2, otherIndex, otherPos );\n\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\tfor ( let i = offset * 3, l = ( offset + count ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\t\tsetTriangle( triangle, i, index, pos );\n\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i / 3;\n\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2 / 3;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t}\n\n\t\t);\n\n\t\ttrianglePool.releasePrimitive( triangle );\n\t\ttrianglePool.releasePrimitive( triangle2 );\n\n\t\tif ( closestDistance === Infinity ) return null;\n\n\t\tif ( ! target1.point ) target1.point = tempTargetDest1.clone();\n\t\telse target1.point.copy( tempTargetDest1 );\n\t\ttarget1.distance = closestDistance,\n\t\ttarget1.faceIndex = closestDistanceTriIndex;\n\n\t\tif ( target2 ) {\n\n\t\t\tif ( ! target2.point ) target2.point = tempTargetDest2.clone();\n\t\t\telse target2.point.copy( tempTargetDest2 );\n\t\t\ttarget2.point.applyMatrix4( tempMatrix );\n\t\t\ttempTargetDest1.applyMatrix4( tempMatrix );\n\t\t\ttarget2.distance = tempTargetDest1.sub( target2.point ).length();\n\t\t\ttarget2.faceIndex = closestDistanceOtherTriIndex;\n\n\t\t}\n\n\t\treturn target1;\n\n\t}\n\n\tclosestPointToPoint( point, target = { }, minThreshold = 0, maxThreshold = Infinity ) {\n\n\t\t// early out if under minThreshold\n\t\t// skip checking if over maxThreshold\n\t\t// set minThreshold = maxThreshold to quickly check if a point is within a threshold\n\t\t// returns Infinity if no value found\n\t\tconst minThresholdSq = minThreshold * minThreshold;\n\t\tconst maxThresholdSq = maxThreshold * maxThreshold;\n\t\tlet closestDistanceSq = Infinity;\n\t\tlet closestDistanceTriIndex = null;\n\t\tthis.shapecast(\n\n\t\t\t{\n\n\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\ttemp.copy( point ).clamp( box.min, box.max );\n\t\t\t\t\treturn temp.distanceToSquared( point );\n\n\t\t\t\t},\n\n\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\treturn score < closestDistanceSq && score < maxThresholdSq;\n\n\t\t\t\t},\n\n\t\t\t\tintersectsTriangle: ( tri, triIndex ) => {\n\n\t\t\t\t\ttri.closestPointToPoint( point, temp );\n\t\t\t\t\tconst distSq = point.distanceToSquared( temp );\n\t\t\t\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\t\t\t\ttemp1.copy( temp );\n\t\t\t\t\t\tclosestDistanceSq = distSq;\n\t\t\t\t\t\tclosestDistanceTriIndex = triIndex;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( distSq < minThresholdSq ) {\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t}\n\n\t\t);\n\n\t\tif ( closestDistanceSq === Infinity ) return null;\n\n\t\tconst closestDistance = Math.sqrt( closestDistanceSq );\n\n\t\tif ( ! target.point ) target.point = temp1.clone();\n\t\telse target.point.copy( temp1 );\n\t\ttarget.distance = closestDistance,\n\t\ttarget.faceIndex = closestDistanceTriIndex;\n\n\t\treturn target;\n\n\t}\n\n\tgetBoundingBox( target ) {\n\n\t\ttarget.makeEmpty();\n\n\t\tconst roots = this._roots;\n\t\troots.forEach( buffer => {\n\n\t\t\tarrayToBox( 0, new Float32Array( buffer ), tempBox );\n\t\t\ttarget.union( tempBox );\n\n\t\t} );\n\n\t\treturn target;\n\n\t}\n\n}\n","import { Ray, Matrix4, Mesh } from 'three';\nimport { convertRaycastIntersect } from './GeometryRayIntersectUtilities.js';\nimport { MeshBVH } from '../core/MeshBVH.js';\n\nconst ray = /* @__PURE__ */ new Ray();\nconst tmpInverseMatrix = /* @__PURE__ */ new Matrix4();\nconst origMeshRaycastFunc = Mesh.prototype.raycast;\n\nexport function acceleratedRaycast( raycaster, intersects ) {\n\n\tif ( this.geometry.boundsTree ) {\n\n\t\tif ( this.material === undefined ) return;\n\n\t\ttmpInverseMatrix.copy( this.matrixWorld ).invert();\n\t\tray.copy( raycaster.ray ).applyMatrix4( tmpInverseMatrix );\n\n\t\tconst bvh = this.geometry.boundsTree;\n\t\tif ( raycaster.firstHitOnly === true ) {\n\n\t\t\tconst hit = convertRaycastIntersect( bvh.raycastFirst( ray, this.material ), this, raycaster );\n\t\t\tif ( hit ) {\n\n\t\t\t\tintersects.push( hit );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst hits = bvh.raycast( ray, this.material );\n\t\t\tfor ( let i = 0, l = hits.length; i < l; i ++ ) {\n\n\t\t\t\tconst hit = convertRaycastIntersect( hits[ i ], this, raycaster );\n\t\t\t\tif ( hit ) {\n\n\t\t\t\t\tintersects.push( hit );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\torigMeshRaycastFunc.call( this, raycaster, intersects );\n\n\t}\n\n}\n\nexport function computeBoundsTree( options ) {\n\n\tthis.boundsTree = new MeshBVH( this, options );\n\treturn this.boundsTree;\n\n}\n\nexport function disposeBoundsTree() {\n\n\tthis.boundsTree = null;\n\n}\n","import * as THREE from 'three'\nimport { computeBoundsTree, disposeBoundsTree, acceleratedRaycast } from 'three-mesh-bvh'\n\nexport const bvhRaycast = () => {\n  THREE.BufferGeometry.prototype.computeBoundsTree = computeBoundsTree\n  THREE.BufferGeometry.prototype.disposeBoundsTree = disposeBoundsTree\n  THREE.Mesh.prototype.raycast = acceleratedRaycast\n\n  THREE.Raycaster.prototype.firstHitOnly = true\n}\n","export default \"import { MouseRaycaster } from 'trzy'\\n\\nconst raycaster = new MouseRaycaster({\\n  scene, // alternatively, pass objects: THREE.Object3D[]\\n  camera,\\n  renderer,\\n  recursive: true,\\n})\\n\\nraycaster.on('move', (event) => console.log(event.intersections))\\nraycaster.on('click', (event) => console.log(event.intersections))\\n\\n// later\\nraycaster.dispose()\\n\""],"names":["MouseRaycaster","EventDispatcher","props","__publicField","Vector2","__privateAdd","_events","event","intersections","Raycaster","type","listener","canvas","__privateGet","vec","rect","CENTER","AVERAGE","SAH","CONTAINED","TRIANGLE_INTERSECT_COST","TRAVERSAL_COST","BYTES_PER_NODE","IS_LEAFNODE_FLAG","FLOAT32_EPSILON","MeshBVHNode","arrayToBox","nodeIndex32","array","target","getLongestEdgeIndex","bounds","splitDimIdx","splitDist","i","dist","copyBounds","source","unionBounds","a","b","aVal","bVal","d","d3","expandByTriangleBounds","startIndex","triangleBounds","tCenter","tHalf","tMin","tMax","computeSurfaceArea","d0","d1","d2","ensureIndex","geo","options","vertexCount","BufferConstructor","index","BufferAttribute","getRootIndexRanges","ranges","rangeBoundaries","group","sortedBoundaries","start","end","getBounds","offset","count","centroidTarget","minx","miny","minz","maxx","maxy","maxz","cminx","cminy","cminz","cmaxx","cmaxy","cmaxz","includeCentroid","cx","hx","lx","rx","cy","hy","ly","ry","cz","hz","lz","rz","getCentroidBounds","partition","split","left","right","pos","axisOffset","t0","t1","t2","BIN_COUNT","binsSort","sahBins","leftBounds","getOptimalSplit","nodeBoundingData","centroidBoundingData","strategy","axis","getAverage","rootSurfaceArea","bestCost","cStart","cEnd","axisLeft","binWidth","truncatedBins","c","bin","leftCacheBounds","rightCacheBounds","splitCount","bi","center","leftCount","rightCount","rightBounds","leftProb","rightProb","cost","binIndex","lastBin","nextBin","binCount","avg","computeTriangleBounds","fullBounds","posAttr","triCount","normalized","posArr","bufferOffset","stride","getters","tri","tri3","tri6","ai","ci","el","min","max","halfExtents","el2","buildTree","triggerProgress","trianglesProcessed","onProgress","totalTriangles","splitNode","node","depth","reachedMaxDepth","maxDepth","verbose","maxLeafTris","splitOffset","indexArray","lstart","lcount","cacheCentroidBoundingData","rstart","rcount","roots","range","root","buildPackedTree","float32Array","uint32Array","uint16Array","packedRoots","nodeCount","countNodes","buffer","populateBuffer","byteOffset","stride4Offset","stride2Offset","isLeaf","boundingData","splitAxis","nextUnusedPointer","SeparatingAxisBounds","points","field","l","val","p","other","Vector3","box","boxMin","boxMax","x","y","z","closestPointLineToLine","dir1","dir2","v02","l1","l2","result","v0","v10","v2","v32","d0232","d3210","d3232","d0210","denom","closestPointsSegmentToSegment","paramResult","temp1","temp2","target1","target2","p2","closestPoint","closestPoint2","sphereIntersectTriangle","closestPointTemp","projectedPointTemp","planeTemp","Plane","lineTemp","Line3","sphere","triangle","radius","plane","pp","DIST_EPSILON","isNearZero","value","ExtendedTriangle","Triangle","args","Sphere","satAxes","satBounds","axis0","sab0","axis1","sab1","axis2","sab2","axis3","sab3","point1","point2","edge","segment","distSq","closestDistanceSq","nexti","saTri2","arr1","arr2","cachedSatBounds","cachedSatBounds2","cachedAxis","tempDir","edge1","edge2","suppressLog","plane1","plane2","satBounds1","satAxes1","sb","sa","satBounds2","satAxes2","sa1","i2","sa2","points1","found1","count1","pNext","targetPoint","startIntersects","points2","found2","count2","tmp","s1","e1","s2","e2","separated1","separated2","point","cornerFields","line1","line2","lineTarget","otherVec","thisVec","f11","f12","f21","f22","OrientedBox","matrix","Matrix4","v","minVec","pi","alignedSatBounds","aabbBounds","saTri","pointsArr","triSatBounds","triSatAxes","xyzFields","segments1","segments2","threshold","threshold2","i1","nextIndex","nextIndex2","index2","p1","f1","f2","f3","vA","vB","vC","uvA","uvB","uvC","intersectionPoint","checkIntersection","ray","pA","pB","pC","side","intersect","BackSide","DoubleSide","checkBufferGeometryIntersection","position","uv","intersection","face","intersectTri","triOffset","intersectTris","intersectClosestTri","res","convertRaycastIntersect","hit","object","raycaster","setTriangle","ta","tb","tc","i0","iterateOverTriangles","geometry","intersectsTriangleFunc","contained","PrimitivePool","getNewPrimitive","primitives","primitive","IS_LEAF","n16","OFFSET","n32","COUNT","LEFT_NODE","RIGHT_NODE","SPLIT_AXIS","boundingBox","Box3","boxIntersection","raycast","intersects","nodeIndex16","_float32Array","_uint16Array","_uint32Array","leftIndex","intersectRay","rightIndex","raycastFirst","xyzAxis","leftToRight","c1","c2","c1Result","c2Result","shapecast","_box1","_box2","boxStack","boxPool","shapecastTraverse","length","intersectsBoundsFunc","intersectsRangeFunc","nodeScoreFunc","nodeIndexByteOffset","getLeftOffset","getRightEndOffset","score1","score2","box1","box2","temp","isC1Leaf","c1Intersection","c1StopTraversal","isC2Leaf","c2Intersection","c2StopTraversal","intersectsGeometry","triangle2","invertedMat","obb","obb2","otherGeometry","geometryToBvh","cachedObb","thisGeometry","thisIndex","thisPos","bufferStack","_prevBuffer","setBuffer","clearBuffer","SKIP_GENERATION","aabb","aabb2","tempMatrix","temp3","temp4","tempBox","trianglePool","MeshBVH","bvh","rootData","indexAttribute","data","newIndex","nodeIndices","indexArr","_traverse","node32Index","force","node16Index","offsetLeft","offsetRight","forceChildren","includesLeft","includesRight","traverseLeft","traverseRight","leftChange","rightChange","didChange","lefti","righti","minLeftValue","maxLeftValue","minRightValue","maxRightValue","callback","rootIndex","materialOrSide","FrontSide","isMaterial","isArrayMaterial","groups","materialSide","startCount","materialIndex","j","jl","closestResult","geomToMesh","callbacks","_intersectsTriangleFunc","_orderNodesFunc","originalTriangleFunc","i3","boundsTraverseOrder","intersectsBounds","intersectsRange","intersectsTriangle","originalIntersectsRange","nodeIndex","otherBvh","matrixToLocal","intersectsRanges","intersectsTriangles","indexAttr","positionAttr","otherIndexAttr","otherPositionAttr","iterateOverDoubleTriangles","offset1","offset2","depth1","index1","depth2","originalIntersectsRanges","nodeIndex1","nodeIndex2","boxToMesh","minThreshold","maxThreshold","otherPos","otherIndex","tempTarget1","tempTargetDest1","tempTarget2","tempTargetDest2","closestDistance","closestDistanceTriIndex","closestDistanceOtherTriIndex","score","otherOffset","otherCount","minThresholdSq","maxThresholdSq","triIndex","Ray","tmpInverseMatrix","origMeshRaycastFunc","Mesh","acceleratedRaycast","hits","computeBoundsTree","disposeBoundsTree","bvhRaycast","THREE.BufferGeometry","THREE.Mesh","THREE.Raycaster","code"],"mappings":"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","x_google_ignoreList":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]}