var L=Object.defineProperty;var O=(a,s,t)=>s in a?L(a,s,{enumerable:!0,configurable:!0,writable:!0,value:t}):a[s]=t;var n=(a,s,t)=>(O(a,typeof s!="symbol"?s+"":s,t),t);import{E as I,s as U,u as X,d as B,o as J}from"./setup-bf23c97c.js";import{s as K}from"./strawberry-9ab81ec5.js";const Q=.5*(Math.sqrt(3)-1),p=(3-Math.sqrt(3))/6,M=a=>Math.floor(a)|0,T=new Float64Array([1,1,-1,1,1,-1,-1,-1,1,0,-1,0,1,0,-1,0,0,1,0,-1,0,1,0,-1]);function j(a=Math.random){const s=V(a),t=new Float64Array(s).map(i=>T[i%12*2]),e=new Float64Array(s).map(i=>T[i%12*2+1]);return function(o,w){let q=0,z=0,N=0;const P=(o+w)*Q,S=M(o+P),g=M(w+P),A=(S+g)*p,D=S-A,H=g-A,c=o-D,l=w-H;let b,f;c>l?(b=1,f=0):(b=0,f=1);const R=c-b+p,v=l-f+p,C=c-1+2*p,F=l-1+2*p,k=S&255,E=g&255;let h=.5-c*c-l*l;if(h>=0){const r=k+s[E],d=t[r],u=e[r];h*=h,q=h*h*(d*c+u*l)}let m=.5-R*R-v*v;if(m>=0){const r=k+b+s[E+f],d=t[r],u=e[r];m*=m,z=m*m*(d*R+u*v)}let y=.5-C*C-F*F;if(y>=0){const r=k+1+s[E+1],d=t[r],u=e[r];y*=y,N=y*y*(d*C+u*F)}return 70*(q+z+N)}}function V(a){const t=new Uint8Array(512);for(let e=0;e<512/2;e++)t[e]=e;for(let e=0;e<512/2-1;e++){const i=e+~~(a()*(256-e)),o=t[e];t[e]=t[i],t[i]=o}for(let e=256;e<512;e++)t[e]=t[e-256];return t}class W{constructor(s){n(this,"enabled",!1);n(this,"decay",!1);n(this,"decayRate",.65);n(this,"intensity",.5);n(this,"maxPitch",.05);n(this,"maxRoll",.05);n(this,"maxYaw",.05);n(this,"pitchFrequency",5e-4);n(this,"rollFrequency",5e-4);n(this,"yawFrequency",5e-4);n(this,"time",0);n(this,"initialRotation",new I);n(this,"object");n(this,"yawNoise",j());n(this,"pitchNoise",j());n(this,"rollNoise",j());n(this,"saveRotation",()=>{this.initialRotation.copy(this.object.rotation)});n(this,"update",s=>{this.time+=s;const t=this.intensity**2,e=this.maxYaw*t*this.yawNoise(this.time*this.yawFrequency,1),i=this.maxPitch*t*this.pitchNoise(this.time*this.pitchFrequency,1),o=this.maxRoll*t*this.rollNoise(this.time*this.rollFrequency,1);this.object.rotation.set(this.initialRotation.x+i,this.initialRotation.y+e,this.initialRotation.z+o),this.decay&&this.intensity>0&&(this.intensity-=this.decayRate*s,this.intensity<0?this.intensity=0:this.intensity>1&&(this.intensity=1))});this.object=s}enable(){this.saveRotation(),this.enabled=!0}disable(){this.enabled=!1}}class Z extends W{constructor(){super(...arguments);n(this,"activeControls")}enable(t){var e;super.enable(),this.activeControls=t,(e=this.activeControls)==null||e.addEventListener("change",this.saveRotation)}disable(){var t;super.disable(),(t=this.activeControls)==null||t.removeEventListener("change",this.saveRotation),this.activeControls=void 0}}const $=`import * as THREE from 'three'
import { CameraShake } from 'trzy'

const camera = new THREE.PerspectiveCamera()
const cameraShake = new CameraShake(camera)

// Optionally pass orbitControls if they exist
cameraShake.enable(orbitControls)

// In your game loop, before rendering your scene
cameraShake.update(delta)

cameraShake.disable()
`,at={title:"Camera Shake",parameters:{docs:{source:{code:$}}}},tt=()=>{U();const{scene:a,camera:s,renderer:t}=X(),e=new Z(s.current);return K().then(i=>a.add(i)),B((i,o)=>e.update(o)),e.enable(J),t.domElement},x={render:tt};var G,Y,_;x.parameters={...x.parameters,docs:{...(G=x.parameters)==null?void 0:G.docs,source:{originalSource:`{
  render
}`,...(_=(Y=x.parameters)==null?void 0:Y.docs)==null?void 0:_.source}}};const it=["Primary"];export{x as Primary,it as __namedExportsOrder,at as default};
//# sourceMappingURL=camera-shake.stories-cdf03ed6.js.map
