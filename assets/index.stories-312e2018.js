import{U as Xr,o as Yr,N as Kr,p as Lt,q as It,r as Ot,s as Wt,u as Dt,v as Zr,w as Jr,x as jr,y as Qr,z as en,G as tn,I as sn,J as rn,K as nn,Q as on,Z as an,W as cn,X as un,Y as ln,_ as dn,$ as hn,a0 as pn,a1 as fn,a2 as gn,a3 as mn,a4 as xn,a5 as Tn,a6 as Nn,a7 as yn,D as Sn,j as us,F as bn,a8 as Cn,a9 as vn,aa as An,ab as wn,ac as Rn,ad as Un,ae as Mn,af as Gn,ag as _n,ah as Pn,ai as En,aj as Bn,ak as Fn,al as Ln,am as In,an as On,ao as ls,C as xe,V as qe,f as ie,ap as yt,aq as ds,i as Ge,c as Wn,ar as P,as as Dn,at as Vn,au as kn,av as $n,aw as Vt,ax as zn,ay as Ie,az as qn,aA as Hn,aB as Xn,aC as Yn,S as Kn,aD as Zn,aE as Jn,aF as hs,aG as K,aH as jn,aI as Qn,aJ as ei,aK as ti,aL as si,aM as ri,aN as ni,aO as ii,aP as oi,aQ as ai,aR as ci,aS as ui,aT as li,aU as di,aV as hi,aW as pi,aX as fi,aY as gi,aZ as mi,a_ as xi,a$ as Ti,b0 as Ni,b1 as yi,b2 as Se,b3 as Si,b4 as ps,b5 as bi,b6 as Ci,b7 as vi,b8 as Qe,b9 as et,ba as Ai,bb as wi,bc as Ri,bd as Ui,be as Mi,bf as Gi,bg as _i,M as Pi,B as Ei,bh as Bi,bi as Fi,bj as Li,bk as fs,t as Ii}from"./teleport-3940721f.js";import{s as Oi}from"./lib-532181b1.js";window.GPUShaderStage===void 0&&(window.GPUShaderStage={VERTEX:1,FRAGMENT:2,COMPUTE:4});class Wi{static isAvailable(){return navigator.gpu!==void 0}static getErrorMessage(){const e='Your browser does not support <a href="https://gpuweb.github.io/gpuweb/" style="color:blue">WebGPU</a> yet',t=document.createElement("div");return t.id="webgpumessage",t.style.fontFamily="monospace",t.style.fontSize="13px",t.style.fontWeight="normal",t.style.textAlign="center",t.style.background="#fff",t.style.color="#000",t.style.padding="1.5em",t.style.maxWidth="400px",t.style.margin="5em auto 0",t.innerHTML=e,t}}const Di=Wi,ve={PointList:"point-list",LineList:"line-list",LineStrip:"line-strip",TriangleList:"triangle-list",TriangleStrip:"triangle-strip"},D={Never:"never",Less:"less",Equal:"equal",LessEqual:"less-equal",Greater:"greater",NotEqual:"not-equal",GreaterEqual:"greater-equal",Always:"always"},Y={Store:"store",Discard:"discard"},q={Load:"load",Clear:"clear"},tt={CCW:"ccw",CW:"cw"},st={None:"none",Front:"front",Back:"back"},we={Uint16:"uint16",Uint32:"uint32"},h={R8Unorm:"r8unorm",R8Snorm:"r8snorm",R8Uint:"r8uint",R8Sint:"r8sint",R16Uint:"r16uint",R16Sint:"r16sint",R16Float:"r16float",RG8Unorm:"rg8unorm",RG8Snorm:"rg8snorm",RG8Uint:"rg8uint",RG8Sint:"rg8sint",R32Uint:"r32uint",R32Sint:"r32sint",R32Float:"r32float",RG16Uint:"rg16uint",RG16Sint:"rg16sint",RG16Float:"rg16float",RGBA8Unorm:"rgba8unorm",RGBA8UnormSRGB:"rgba8unorm-srgb",RGBA8Snorm:"rgba8snorm",RGBA8Uint:"rgba8uint",RGBA8Sint:"rgba8sint",BGRA8Unorm:"bgra8unorm",BGRA8UnormSRGB:"bgra8unorm-srgb",RGB9E5UFloat:"rgb9e5ufloat",RGB10A2Unorm:"rgb10a2unorm",RG11B10uFloat:"rgb10a2unorm",RG32Uint:"rg32uint",RG32Sint:"rg32sint",RG32Float:"rg32float",RGBA16Uint:"rgba16uint",RGBA16Sint:"rgba16sint",RGBA16Float:"rgba16float",RGBA32Uint:"rgba32uint",RGBA32Sint:"rgba32sint",RGBA32Float:"rgba32float",Stencil8:"stencil8",Depth16Unorm:"depth16unorm",Depth24Plus:"depth24plus",Depth24PlusStencil8:"depth24plus-stencil8",Depth32Float:"depth32float",Depth32FloatStencil8:"depth32float-stencil8",BC1RGBAUnorm:"bc1-rgba-unorm",BC1RGBAUnormSRGB:"bc1-rgba-unorm-srgb",BC2RGBAUnorm:"bc2-rgba-unorm",BC2RGBAUnormSRGB:"bc2-rgba-unorm-srgb",BC3RGBAUnorm:"bc3-rgba-unorm",BC3RGBAUnormSRGB:"bc3-rgba-unorm-srgb",BC4RUnorm:"bc4-r-unorm",BC4RSnorm:"bc4-r-snorm",BC5RGUnorm:"bc5-rg-unorm",BC5RGSnorm:"bc5-rg-snorm",BC6HRGBUFloat:"bc6h-rgb-ufloat",BC6HRGBFloat:"bc6h-rgb-float",BC7RGBAUnorm:"bc7-rgba-unorm",BC7RGBAUnormSRGB:"bc7-rgba-srgb",ETC2RGB8Unorm:"etc2-rgb8unorm",ETC2RGB8UnormSRGB:"etc2-rgb8unorm-srgb",ETC2RGB8A1Unorm:"etc2-rgb8a1unorm",ETC2RGB8A1UnormSRGB:"etc2-rgb8a1unorm-srgb",ETC2RGBA8Unorm:"etc2-rgba8unorm",ETC2RGBA8UnormSRGB:"etc2-rgba8unorm-srgb",EACR11Unorm:"eac-r11unorm",EACR11Snorm:"eac-r11snorm",EACRG11Unorm:"eac-rg11unorm",EACRG11Snorm:"eac-rg11snorm",ASTC4x4Unorm:"astc-4x4-unorm",ASTC4x4UnormSRGB:"astc-4x4-unorm-srgb",ASTC5x4Unorm:"astc-5x4-unorm",ASTC5x4UnormSRGB:"astc-5x4-unorm-srgb",ASTC5x5Unorm:"astc-5x5-unorm",ASTC5x5UnormSRGB:"astc-5x5-unorm-srgb",ASTC6x5Unorm:"astc-6x5-unorm",ASTC6x5UnormSRGB:"astc-6x5-unorm-srgb",ASTC6x6Unorm:"astc-6x6-unorm",ASTC6x6UnormSRGB:"astc-6x6-unorm-srgb",ASTC8x5Unorm:"astc-8x5-unorm",ASTC8x5UnormSRGB:"astc-8x5-unorm-srgb",ASTC8x6Unorm:"astc-8x6-unorm",ASTC8x6UnormSRGB:"astc-8x6-unorm-srgb",ASTC8x8Unorm:"astc-8x8-unorm",ASTC8x8UnormSRGB:"astc-8x8-unorm-srgb",ASTC10x5Unorm:"astc-10x5-unorm",ASTC10x5UnormSRGB:"astc-10x5-unorm-srgb",ASTC10x6Unorm:"astc-10x6-unorm",ASTC10x6UnormSRGB:"astc-10x6-unorm-srgb",ASTC10x8Unorm:"astc-10x8-unorm",ASTC10x8UnormSRGB:"astc-10x8-unorm-srgb",ASTC10x10Unorm:"astc-10x10-unorm",ASTC10x10UnormSRGB:"astc-10x10-unorm-srgb",ASTC12x10Unorm:"astc-12x10-unorm",ASTC12x10UnormSRGB:"astc-12x10-unorm-srgb",ASTC12x12Unorm:"astc-12x12-unorm",ASTC12x12UnormSRGB:"astc-12x12-unorm-srgb"},rt={ClampToEdge:"clamp-to-edge",Repeat:"repeat",MirrorRepeat:"mirror-repeat"},dt={Linear:"linear",Nearest:"nearest"},w={Zero:"zero",One:"one",SrcColor:"src-color",OneMinusSrcColor:"one-minus-src-color",SrcAlpha:"src-alpha",OneMinusSrcAlpha:"one-minus-src-alpha",DstColor:"dst-color",OneMinusDstColor:"one-minus-dst-color",DstAlpha:"dst-alpha",OneMinusDstAlpha:"one-minus-dst-alpha",SrcAlphaSaturated:"src-alpha-saturated",BlendColor:"blend-color",OneMinusBlendColor:"one-minus-blend-color"},z={Add:"add",Subtract:"subtract",ReverseSubtract:"reverse-subtract",Min:"min",Max:"max"},kt={None:0,Red:1,Green:2,Blue:4,Alpha:8,All:15},j={Keep:"keep",Zero:"zero",Replace:"replace",Invert:"invert",IncrementClamp:"increment-clamp",DecrementClamp:"decrement-clamp",IncrementWrap:"increment-wrap",DecrementWrap:"decrement-wrap"},He={UniformBuffer:"uniform-buffer",StorageBuffer:"storage-buffer",ReadonlyStorageBuffer:"readonly-storage-buffer",Sampler:"sampler",ComparisonSampler:"comparison-sampler",SampledTexture:"sampled-texture",MultisampledTexture:"multisampled-texture",ReadonlyStorageTexture:"readonly-storage-texture",WriteonlyStorageTexture:"writeonly-storage-texture"},$t={OneD:"1d",TwoD:"2d",ThreeD:"3d"},Oe={OneD:"1d",TwoD:"2d",TwoDArray:"2d-array",Cube:"cube",CubeArray:"cube-array",ThreeD:"3d"},zt={All:"all",StencilOnly:"stencil-only",DepthOnly:"depth-only"},qt={Vertex:"vertex",Instance:"instance"},ht={DepthClipControl:"depth-clip-control",Depth32FloatStencil8:"depth32float-stencil8",TextureCompressionBC:"texture-compression-bc",TextureCompressionETC2:"texture-compression-etc2",TextureCompressionASTC:"texture-compression-astc",TimestampQuery:"timestamp-query",IndirectFirstInstance:"indirect-first-instance",ShaderF16:"shader-f16",RG11B10UFloat:"rg11b10ufloat-renderable",BGRA8UNormStorage:"bgra8unorm-storage",Float32Filterable:"float32-filterable"},Q=16,Vi=211,ki=212;class $i{constructor(){this.nodes=null,this.animationLoop=null,this.requestId=null,this.isAnimating=!1,this.context=self}start(){if(this.isAnimating===!0||this.animationLoop===null||this.nodes===null)return;this.isAnimating=!0;const e=(t,s)=>{this.requestId=self.requestAnimationFrame(e),this.nodes.nodeFrame.update(),this.animationLoop(t,s)};this.requestId=self.requestAnimationFrame(e)}stop(){self.cancelAnimationFrame(this.requestId),this.isAnimating=!1}setAnimationLoop(e){this.animationLoop=e}setNodes(e){this.nodes=e}}const zi=$i;class Re extends WeakMap{constructor(){super()}get(e){if(Array.isArray(e)){let t=this;for(let s=0;s<e.length-1;s++)if(t=t.get(e[s]),t===void 0)return;return t.get(e[e.length-1])}else return super.get(e)}set(e,t){if(Array.isArray(e)){let s=this;for(let r=0;r<e.length-1;r++){const n=e[r];s.has(n)===!1&&s.set(n,new WeakMap),s=s.get(n)}return s.set(e[e.length-1],t)}else return super.set(e,t)}delete(e){if(Array.isArray(e)){let t=this;for(let s=0;s<e.length-1;s++)if(t=t.get(e[s]),t===void 0)return!1;return t.delete(e[e.length-1])}else return super.delete(e)}}class qi{constructor(e,t,s,r,n,i,a){this.renderer=e,this.nodes=t,this.object=s,this.material=r,this.scene=n,this.camera=i,this.lightsNode=a,this.geometry=s.geometry,this._materialVersion=-1,this._materialCacheKey=""}getCacheKey(){const{material:e,scene:t,lightsNode:s}=this;e.version!==this._materialVersion&&(this._materialVersion=e.version,this._materialCacheKey=e.customProgramCacheKey());const r=[];return r.push("material:"+this._materialCacheKey),r.push("nodes:"+this.nodes.getCacheKey(t,s)),"{"+r.join(",")+"}"}}class Hi{constructor(e,t,s,r){this.renderer=e,this.nodes=t,this.geometries=s,this.info=r,this.cache=new Re}get(e,t,s,r,n){const i=[e,t,s,r,n];let a=this.cache.get(i);return a===void 0&&(a=new qi(this.renderer,this.nodes,e,t,s,r,n),this.cache.set(i,a)),a}remove(e,t,s,r,n){this.cache.delete([e,t,s,r,n])}dispose(){this.cache=new Re,this.updateMap=new WeakMap}}const Xi=Hi;class Yi{constructor(e){this.buffers=new WeakMap,this.device=e}get(e){return e=this._getAttribute(e),this.buffers.get(e)}remove(e){e=this._getAttribute(e);const t=this.buffers.get(e);t&&(this._destroyBuffers(t),this.buffers.delete(e))}update(e,t=!1,s=null){e=this._getAttribute(e);let r=this.buffers.get(e);r===void 0?(s===null&&(s=t===!0?GPUBufferUsage.INDEX:GPUBufferUsage.VERTEX),r=this._createBuffer(e,s),this.buffers.set(e,r)):s&&s!==r.usage?(this._destroyBuffers(r),r=this._createBuffer(e,s),this.buffers.set(e,r)):r.version<e.version&&(this._writeBuffer(r.buffer,e),r.version=e.version)}async getArrayBuffer(e){const t=this.get(e),s=this.device,r=t.buffer,n=r.size;let i=t.readBuffer,a=!0;i===null&&(i=s.createBuffer({label:e.name,size:n,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}),a=!1,t.readBuffer=i);const c=s.createCommandEncoder({});c.copyBufferToBuffer(r,0,i,0,n),a&&i.unmap();const l=c.finish();return s.queue.submit([l]),await i.mapAsync(GPUMapMode.READ),i.getMappedRange()}_getAttribute(e){return e.isInterleavedBufferAttribute&&(e=e.data),e}_createBuffer(e,t){const s=e.array,r=s.byteLength+(4-s.byteLength%4)%4,n=this.device.createBuffer({label:e.name,size:r,usage:t|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST,mappedAtCreation:!0});return new s.constructor(n.getMappedRange()).set(s),n.unmap(),e.onUploadCallback(),{version:e.version,buffer:n,readBuffer:null,usage:t}}_writeBuffer(e,t){const s=this.device,r=t.array,n=t.updateRange;n.count===-1?s.queue.writeBuffer(e,0,r,0):(s.queue.writeBuffer(e,0,r,n.offset*r.BYTES_PER_ELEMENT,n.count*r.BYTES_PER_ELEMENT),n.count=-1)}_destroyBuffers({buffer:e,readBuffer:t}){e.destroy(),t!==null&&t.destroy()}}const Ki=Yi;function Zi(o){for(let e=o.length-1;e>=0;--e)if(o[e]>=65535)return!0;return!1}function gs(o){return o.index!==null?o.index.version:o.attributes.position.version}function Ht(o){const e=[],t=o.index,s=o.attributes.position;if(t!==null){const n=t.array;for(let i=0,a=n.length;i<a;i+=3){const c=n[i+0],l=n[i+1],d=n[i+2];e.push(c,l,l,d,d,c)}}else{const n=s.array;for(let i=0,a=n.length/3-1;i<a;i+=3){const c=i+0,l=i+1,d=i+2;e.push(c,l,l,d,d,c)}}const r=new(Zi(e)?Xr:Yr)(e,1);return r.version=gs(o),r}class Ji{constructor(e,t,s){this.attributes=e,this.properties=t,this.info=s,this.wireframes=new WeakMap,this.geometryFrame=new WeakMap}has(e){const t=e.geometry;return this.properties.has(t)&&this.properties.get(t).initialized===!0}update(e){this.has(e)===!1&&this.initGeometry(e),this.updateFrameAttributes(e)}initGeometry(e){const t=e.geometry,s=this.properties.get(t);s.initialized=!0;const r=()=>{this.info.memory.geometries--;const n=t.index,i=t.attributes;n!==null&&this.attributes.remove(n);for(const c in i)this.attributes.remove(i[c]);const a=this.wireframes.get(t);a!==void 0&&this.attributes.remove(a),t.removeEventListener("dispose",r)};this.info.memory.geometries++,t.addEventListener("dispose",r)}updateFrameAttributes(e){const t=this.info.render.frame,s=e.geometry;this.geometryFrame.get(s)!==t&&(this.updateAttributes(e),this.geometryFrame.set(s,t))}updateAttributes(e){const s=e.geometry.attributes;for(const n in s)this.attributes.update(s[n]);const r=this.getIndex(e);r!==null&&this.attributes.update(r,!0)}getIndex(e){const{geometry:t,material:s}=e;let r=t.index;if(s.wireframe===!0){const n=this.wireframes;let i=n.get(t);i===void 0?(i=Ht(t),n.set(t,i)):i.version!==gs(t)&&(this.attributes.remove(i),i=Ht(t),n.set(t,i)),r=i}return r}}const ji=Ji;class Qi{constructor(){this.autoReset=!0,this.render={frame:0,drawCalls:0,triangles:0,points:0,lines:0},this.memory={geometries:0,textures:0}}update(e,t,s){this.render.drawCalls++,e.isMesh||e.isSprite?this.render.triangles+=s*(t/3):e.isPoints?this.render.points+=s*t:e.isLineSegments?this.render.lines+=s*(t/2):e.isLine?this.render.lines+=s*(t-1):console.error("THREE.WebGPUInfo: Unknown object type.")}reset(){this.render.frame++,this.render.drawCalls=0,this.render.triangles=0,this.render.points=0,this.render.lines=0}dispose(){this.reset(),this.render.frame=0,this.memory.geometries=0,this.memory.textures=0}}const eo=Qi;class to{constructor(){this.properties=new WeakMap}get(e){let t=this.properties.get(e);return t===void 0&&(t={},this.properties.set(e,t)),t}remove(e){this.properties.delete(e)}has(e){return this.properties.has(e)}dispose(){this.properties=new WeakMap}}const so=to,ro=new Map([[Int8Array,["sint8","snorm8"]],[Uint8Array,["uint8","unorm8"]],[Int16Array,["sint16","snorm16"]],[Uint16Array,["uint16","unorm16"]],[Int32Array,["sint32","snorm32"]],[Uint32Array,["uint32","unorm32"]],[Float32Array,["float32"]]]),no=new Map([[ls,["float16"]]]),io=new Map([[Int32Array,"sint32"],[Uint32Array,"uint32"],[Float32Array,"float32"]]);class oo{constructor(e,t){this.cacheKey=null,this.shaderAttributes=null,this.stageVertex=null,this.stageFragment=null,this.usedTimes=0,this._device=e,this._utils=t}init(e,t,s,r,n){const{object:i,material:a,geometry:c}=r,l=this._getShaderAttributes(n,c),d=[];for(const ye of l){const qr=ye.name,Ft=c.getAttribute(qr),Hr=Ft!==void 0&&Ft.isInstancedBufferAttribute?qt.Instance:qt.Vertex;d.push({arrayStride:ye.arrayStride,attributes:[{shaderLocation:ye.slot,offset:ye.offset,format:ye.format}],stepMode:Hr})}this.cacheKey=e,this.shaderAttributes=l,this.stageVertex=t,this.stageFragment=s;let f={},m={};a.transparent===!0&&a.blending!==Kr&&(f=this._getAlphaBlend(a),m=this._getColorBlend(a));let y={};a.stencilWrite===!0&&(y={compare:this._getStencilCompare(a),failOp:this._getStencilOperation(a.stencilFail),depthFailOp:this._getStencilOperation(a.stencilZFail),passOp:this._getStencilOperation(a.stencilZPass)});const A=this._getPrimitiveState(i,c,a),b=this._getColorWriteMask(a),M=this._getDepthCompare(a),G=this._utils.getCurrentColorFormat(),I=this._utils.getCurrentDepthStencilFormat(),Pe=this._utils.getSampleCount();this.pipeline=this._device.createRenderPipeline({vertex:Object.assign({},t.stage,{buffers:d}),fragment:Object.assign({},s.stage,{targets:[{format:G,blend:{alpha:f,color:m},writeMask:b}]}),primitive:A,depthStencil:{format:I,depthWriteEnabled:a.depthWrite,depthCompare:M,stencilFront:y,stencilBack:{},stencilReadMask:a.stencilFuncMask,stencilWriteMask:a.stencilWriteMask},multisample:{count:Pe},layout:"auto"})}_getAlphaBlend(e){const t=e.blending,s=e.premultipliedAlpha;let r;switch(t){case Dt:s===!1&&(r={srcFactor:w.One,dstFactor:w.OneMinusSrcAlpha,operation:z.Add});break;case Wt:r={srcFactor:w.Zero,dstFactor:w.One,operation:z.Add};break;case Ot:s===!0&&(r={srcFactor:w.OneMinusSrcColor,dstFactor:w.OneMinusSrcAlpha,operation:z.Add});break;case It:s===!0&&(r={srcFactor:w.Zero,dstFactor:w.SrcAlpha,operation:z.Add});break;case Lt:const n=e.blendSrcAlpha,i=e.blendDstAlpha,a=e.blendEquationAlpha;n!==null&&i!==null&&a!==null&&(r={srcFactor:this._getBlendFactor(n),dstFactor:this._getBlendFactor(i),operation:this._getBlendOperation(a)});break;default:console.error("THREE.WebGPURenderer: Blending not supported.",t)}return r}_getBlendFactor(e){let t;switch(e){case an:t=w.Zero;break;case on:t=w.One;break;case nn:t=w.SrcColor;break;case rn:t=w.OneMinusSrcColor;break;case sn:t=w.SrcAlpha;break;case tn:t=w.OneMinusSrcAlpha;break;case en:t=w.DstColor;break;case Qr:t=w.OneMinusDstColor;break;case jr:t=w.DstAlpha;break;case Jr:t=w.OneMinusDstAlpha;break;case Zr:t=w.SrcAlphaSaturated;break;case Vi:t=w.BlendColor;break;case ki:t=w.OneMinusBlendColor;break;default:console.error("THREE.WebGPURenderer: Blend factor not supported.",e)}return t}_getBlendOperation(e){let t;switch(e){case hn:t=z.Add;break;case dn:t=z.Subtract;break;case ln:t=z.ReverseSubtract;break;case un:t=z.Min;break;case cn:t=z.Max;break;default:console.error("THREE.WebGPURenderer: Blend equation not supported.",e)}return t}_getColorBlend(e){const t=e.blending,s=e.premultipliedAlpha,r={srcFactor:null,dstFactor:null,operation:null};switch(t){case Dt:r.srcFactor=s===!0?w.One:w.SrcAlpha,r.dstFactor=w.OneMinusSrcAlpha,r.operation=z.Add;break;case Wt:r.srcFactor=s===!0?w.One:w.SrcAlpha,r.dstFactor=w.One,r.operation=z.Add;break;case Ot:r.srcFactor=w.Zero,r.dstFactor=s===!0?w.Zero:w.OneMinusSrcColor,r.operation=z.Add;break;case It:r.srcFactor=w.Zero,r.dstFactor=w.SrcColor,r.operation=z.Add;break;case Lt:r.srcFactor=this._getBlendFactor(e.blendSrc),r.dstFactor=this._getBlendFactor(e.blendDst),r.operation=this._getBlendOperation(e.blendEquation);break;default:console.error("THREE.WebGPURenderer: Blending not supported.",t)}return r}_getColorWriteMask(e){return e.colorWrite===!0?kt.All:kt.None}_getDepthCompare(e){let t;if(e.depthTest===!1)t=D.Always;else{const s=e.depthFunc;switch(s){case yn:t=D.Never;break;case Nn:t=D.Always;break;case Tn:t=D.Less;break;case xn:t=D.LessEqual;break;case mn:t=D.Equal;break;case gn:t=D.GreaterEqual;break;case fn:t=D.Greater;break;case pn:t=D.NotEqual;break;default:console.error("THREE.WebGPURenderer: Invalid depth function.",s)}}return t}_getPrimitiveState(e,t,s){const r={};if(r.topology=this._utils.getPrimitiveTopology(e,s),e.isLine===!0&&e.isLineSegments!==!0){const n=t.index?t.index.count:t.attributes.position.count;r.stripIndexFormat=n>65535?we.Uint32:we.Uint16}switch(s.side){case bn:r.frontFace=tt.CW,r.cullMode=st.Front;break;case us:r.frontFace=tt.CW,r.cullMode=st.Back;break;case Sn:r.frontFace=tt.CW,r.cullMode=st.None;break;default:console.error("THREE.WebGPURenderer: Unknown Material.side value.",s.side);break}return r}_getStencilCompare(e){let t;const s=e.stencilFunc;switch(s){case Gn:t=D.Never;break;case Mn:t=D.Always;break;case Un:t=D.Less;break;case Rn:t=D.LessEqual;break;case wn:t=D.Equal;break;case An:t=D.GreaterEqual;break;case vn:t=D.Greater;break;case Cn:t=D.NotEqual;break;default:console.error("THREE.WebGPURenderer: Invalid stencil function.",s)}return t}_getStencilOperation(e){let t;switch(e){case On:t=j.Keep;break;case In:t=j.Zero;break;case Ln:t=j.Replace;break;case Fn:t=j.Invert;break;case Bn:t=j.IncrementClamp;break;case En:t=j.DecrementClamp;break;case Pn:t=j.IncrementWrap;break;case _n:t=j.DecrementWrap;break;default:console.error("THREE.WebGPURenderer: Invalid stencil operation.",t)}return t}_getVertexFormat(e){const{itemSize:t,normalized:s}=e,r=e.array.constructor,n=e.constructor;let i;if(t==1)i=io.get(r);else{const c=(no.get(n)||ro.get(r))[s?1:0];if(c){const l=r.BYTES_PER_ELEMENT*t,f=Math.floor((l+3)/4)*4/r.BYTES_PER_ELEMENT;if(f%1)throw new Error("THREE.WebGPURenderer: Bad vertex format item size.");i=`${c}x${f}`}}return i||console.error("THREE.WebGPURenderer: Vertex format not supported yet."),i}_getShaderAttributes(e,t){const s=e.attributes,r=[];for(let n=0;n<s.length;n++){const a=s[n].name,c=t.getAttribute(a),l=c.array.BYTES_PER_ELEMENT,d=this._getVertexFormat(c);let f=c.itemSize*l,m=0;c.isInterleavedBufferAttribute===!0&&(f=c.data.stride*l,m=c.offset*l),r.push({name:a,arrayStride:f,offset:m,format:d,slot:n})}return r}}const ao=oo;let co=0;class uo{constructor(e,t,s){this.id=co++,this.code=t,this.type=s,this.usedTimes=0,this.stage={module:e.createShaderModule({code:t,label:s}),entryPoint:"main"}}}const pt=uo;class lo{constructor(e,t,s){this.device=e,this.nodes=t,this.utils=s,this.bindings=null,this.pipelines=[],this.cache=new WeakMap,this.stages={vertex:new Map,fragment:new Map}}get(e){const t=this.device,s=this._getCache(e);let r=s.currentPipeline;if(this._needsUpdate(e)){this._releasePipeline(e);const n=this.nodes.get(e);let i=this.stages.vertex.get(n.vertexShader);i===void 0&&(i=new pt(t,n.vertexShader,"vertex"),this.stages.vertex.set(n.vertexShader,i));let a=this.stages.fragment.get(n.fragmentShader);a===void 0&&(a=new pt(t,n.fragmentShader,"fragment"),this.stages.fragment.set(n.fragmentShader,a)),r=this._acquirePipeline(i,a,e),s.currentPipeline=r,r.usedTimes++,i.usedTimes++,a.usedTimes++}return r}remove(e){this._releasePipeline(e)}dispose(){this.pipelines=[],this.cache=new WeakMap,this.shaderModules={vertex:new Map,fragment:new Map}}_acquirePipeline(e,t,s){let r;const n=this.pipelines,i=this._computeCacheKey(e,t,s);for(let a=0,c=n.length;a<c;a++){const l=n[a];if(l.cacheKey===i){r=l;break}}return r===void 0&&(r=new ao(this.device,this.utils),r.init(i,e,t,s,this.nodes.get(s)),n.push(r)),r}_computeCacheKey(e,t,s){const{object:r,material:n}=s,i=this.utils;return[e.id,t.id,n.transparent,n.blending,n.premultipliedAlpha,n.blendSrc,n.blendDst,n.blendEquation,n.blendSrcAlpha,n.blendDstAlpha,n.blendEquationAlpha,n.colorWrite,n.depthWrite,n.depthTest,n.depthFunc,n.stencilWrite,n.stencilFunc,n.stencilFail,n.stencilZFail,n.stencilZPass,n.stencilFuncMask,n.stencilWriteMask,n.side,i.getSampleCount(),i.getCurrentColorSpace(),i.getCurrentColorFormat(),i.getCurrentDepthStencilFormat(),i.getPrimitiveTopology(r,n)].join()}_getCache(e){let t=this.cache.get(e);return t===void 0&&(t={},this.cache.set(e,t)),t}_releasePipeline(e){const t=this._getCache(e),s=t.currentPipeline;if(delete t.currentPipeline,this.bindings.remove(e),s&&--s.usedTimes===0){const r=this.pipelines,n=r.indexOf(s);r[n]=r[r.length-1],r.pop(),this._releaseStage(s.stageVertex),this._releaseStage(s.stageFragment)}}_releaseStage(e){if(--e.usedTimes===0){const t=e.code,s=e.type;this.stages[s].delete(t)}}_needsUpdate(e){const t=this._getCache(e),s=e.material;let r=!1;t.currentPipeline===void 0&&(r=!0),(t.material!==s||t.materialVersion!==s.version||t.transparent!==s.transparent||t.blending!==s.blending||t.premultipliedAlpha!==s.premultipliedAlpha||t.blendSrc!==s.blendSrc||t.blendDst!==s.blendDst||t.blendEquation!==s.blendEquation||t.blendSrcAlpha!==s.blendSrcAlpha||t.blendDstAlpha!==s.blendDstAlpha||t.blendEquationAlpha!==s.blendEquationAlpha||t.colorWrite!==s.colorWrite||t.depthWrite!==s.depthWrite||t.depthTest!==s.depthTest||t.depthFunc!==s.depthFunc||t.stencilWrite!==s.stencilWrite||t.stencilFunc!==s.stencilFunc||t.stencilFail!==s.stencilFail||t.stencilZFail!==s.stencilZFail||t.stencilZPass!==s.stencilZPass||t.stencilFuncMask!==s.stencilFuncMask||t.stencilWriteMask!==s.stencilWriteMask||t.side!==s.side)&&(t.material=s,t.materialVersion=s.version,t.transparent=s.transparent,t.blending=s.blending,t.premultipliedAlpha=s.premultipliedAlpha,t.blendSrc=s.blendSrc,t.blendDst=s.blendDst,t.blendEquation=s.blendEquation,t.blendSrcAlpha=s.blendSrcAlpha,t.blendDstAlpha=s.blendDstAlpha,t.blendEquationAlpha=s.blendEquationAlpha,t.colorWrite=s.colorWrite,t.depthWrite=s.depthWrite,t.depthTest=s.depthTest,t.depthFunc=s.depthFunc,t.stencilWrite=s.stencilWrite,t.stencilFunc=s.stencilFunc,t.stencilFail=s.stencilFail,t.stencilZFail=s.stencilZFail,t.stencilZPass=s.stencilZPass,t.stencilFuncMask=s.stencilFuncMask,t.stencilWriteMask=s.stencilWriteMask,t.side=s.side,r=!0);const n=this.utils,i=n.getSampleCount(),a=n.getCurrentColorSpace(),c=n.getCurrentColorFormat(),l=n.getCurrentDepthStencilFormat();return(t.sampleCount!==i||t.colorSpace!==a||t.colorFormat!==c||t.depthStencilFormat!==l)&&(t.sampleCount=i,t.colorSpace=a,t.colorFormat=c,t.depthStencilFormat=l,r=!0),r}}const ho=lo;class po{constructor(e,t){this.device=e,this.nodes=t,this.pipelines=new WeakMap,this.stages={compute:new WeakMap}}has(e){return this.pipelines.get(e)!==void 0}get(e){let t=this.pipelines.get(e);if(t===void 0){const s=this.device,n=this.nodes.getForCompute(e).computeShader,i={computeShader:n};let a=this.stages.compute.get(i);a===void 0&&(a=new pt(s,n,"compute"),this.stages.compute.set(i,a)),t=s.createComputePipeline({compute:a.stage,layout:"auto"}),this.pipelines.set(e,t)}return t}dispose(){this.pipelines=new WeakMap,this.stages={compute:new WeakMap}}}const fo=po;class go{constructor(e,t,s,r,n,i,a,c){this.device=e,this.info=t,this.properties=s,this.textures=r,this.renderPipelines=n,this.computePipelines=i,this.attributes=a,this.nodes=c,this.uniformsData=new WeakMap,this.updateMap=new WeakMap}get(e){let t=this.uniformsData.get(e);if(t===void 0){const r=this.nodes.get(e).getBindings(),i=this.renderPipelines.get(e).pipeline.getBindGroupLayout(0),a=this._createBindGroup(r,i);t={layout:i,group:a,bindings:r},this.uniformsData.set(e,t)}return t}getForCompute(e){let t=this.uniformsData.get(e);if(t===void 0){const r=this.nodes.getForCompute(e).getBindings(),i=this.computePipelines.get(e).getBindGroupLayout(0),a=this._createBindGroup(r,i);t={layout:i,group:a,bindings:r},this.uniformsData.set(e,t)}return t}remove(e){this.uniformsData.delete(e)}update(e){const t=this.textures,s=this.get(e),r=s.bindings,n=this.updateMap,i=this.info.render.frame;let a=!1;for(const c of r){const l=c.isShared,d=n.get(c)===i;if(!(l&&d)){if(c.isUniformBuffer){const f=c.getBuffer();if(c.update()===!0){const y=c.bufferGPU;this.device.queue.writeBuffer(y,0,f,0)}}else if(c.isStorageBuffer){const f=c.attribute;this.attributes.update(f,!1,c.usage)}else if(c.isSampler){const f=c.getTexture();t.updateSampler(f);const m=t.getSampler(f);c.samplerGPU!==m&&(c.samplerGPU=m,a=!0)}else if(c.isSampledTexture){const f=c.getTexture(),m=t.updateTexture(f),y=t.getTextureGPU(f);(y!==void 0&&c.textureGPU!==y||m===!0)&&(c.textureGPU=y,a=!0)}n.set(c,i)}}a===!0&&(s.group=this._createBindGroup(r,s.layout))}dispose(){this.uniformsData=new WeakMap,this.updateMap=new WeakMap}_createBindGroup(e,t){let s=0;const r=[];for(const n of e){if(n.isUniformBuffer){if(n.bufferGPU===null){const i=n.getByteLength();n.bufferGPU=this.device.createBuffer({label:"bindingBuffer",size:i,usage:n.usage})}r.push({binding:s,resource:{buffer:n.bufferGPU}})}else if(n.isStorageBuffer){if(n.bufferGPU===null){const i=n.attribute;this.attributes.update(i,!1,n.usage),n.bufferGPU=this.attributes.get(i).buffer}r.push({binding:s,resource:{buffer:n.bufferGPU}})}else if(n.isSampler)n.samplerGPU===null&&(n.samplerGPU=this.textures.getDefaultSampler()),r.push({binding:s,resource:n.samplerGPU});else if(n.isSampledTexture){n.textureGPU===null&&(n.isSampledCubeTexture?n.textureGPU=this.textures.getDefaultCubeTexture():n.texture.isVideoTexture?n.textureGPU=this.textures.getDefaultVideoTexture():n.texture.isDepthTexture?n.textureGPU=this.textures.getDefaultDepthTexture():n.textureGPU=this.textures.getDefaultTexture());const i=n.textureGPU instanceof GPUTexture?n.textureGPU.createView({aspect:n.aspect,dimension:n.dimension}):n.textureGPU;r.push({binding:s,resource:i})}s++}return this.device.createBindGroup({layout:t,entries:r})}}const mo=go,Xt={VERTEX:"vertex",FRAGMENT:"fragment"},O={NONE:"none",FRAME:"frame",RENDER:"render",OBJECT:"object"},xo=["fragment","vertex"],To=["construct","analyze","generate"],No=[...xo,"compute"],ms=["x","y","z","w"];function St(o){let e="{";o.isNode===!0&&(e+=`uuid:"${o.uuid}"`);for(const{property:t,index:s,childNode:r}of We(o)){let n=St(r);n.includes(",")||(n=n.slice(n.indexOf('"'),n.indexOf("}"))),e+=`,${t}${s!==void 0?"/"+s:""}:${n}`}return e+="}",e}function*We(o,e=!1){for(const t in o){if(t.startsWith("_")===!0)continue;const s=o[t];if(Array.isArray(s)===!0)for(let r=0;r<s.length;r++){const n=s[r];n&&(n.isNode===!0||e&&typeof n.toJSON=="function")&&(yield{property:t,index:r,childNode:n})}else if(s&&s.isNode===!0)yield{property:t,childNode:s};else if(typeof s=="object")for(const r in s){const n=s[r];n&&(n.isNode===!0||e&&typeof n.toJSON=="function")&&(yield{property:t,index:r,childNode:n})}}}function De(o){if(o==null)return null;const e=typeof o;return o.isNode===!0?"node":e==="number"?"float":e==="boolean"?"bool":e==="string"?"string":o.isVector2===!0?"vec2":o.isVector3===!0?"vec3":o.isVector4===!0?"vec4":o.isMatrix3===!0?"mat3":o.isMatrix4===!0?"mat4":o.isColor===!0?"color":o instanceof ArrayBuffer?"ArrayBuffer":null}function ft(o,...e){const t=o?o.slice(-4):void 0;return o==="color"?new xe(...e):t==="vec2"?new qe(...e):t==="vec3"?new ie(...e):t==="vec4"?new yt(...e):t==="mat3"?new ds(...e):t==="mat4"?new Ge(...e):o==="bool"?e[0]||!1:o==="float"||o==="int"||o==="uint"?e[0]||0:o==="string"?e[0]||"":o==="ArrayBuffer"?So(e[0]):null}function yo(o){let e="";const t=new Uint8Array(o);for(let s=0;s<t.length;s++)e+=String.fromCharCode(t[s]);return btoa(e)}function So(o){return Uint8Array.from(atob(o),e=>e.charCodeAt(0)).buffer}const Yt=new Map;let bo=0;class Co{constructor(e=null){this.isNode=!0,this.nodeType=e,this.updateType=O.NONE,this.updateBeforeType=O.NONE,this.uuid=Wn.generateUUID(),Object.defineProperty(this,"id",{value:bo++})}get type(){return this.constructor.name}isGlobal(){return!1}*getChildren(){const e=this;for(const{property:t,index:s,childNode:r}of We(this))s!==void 0?yield{childNode:r,replaceNode(n){e[t][s]=n}}:yield{childNode:r,replaceNode(n){e[t]=n}}}traverse(e,t=null){e(this,t);for(const{childNode:s,replaceNode:r}of this.getChildren())s.traverse(e,r)}getCacheKey(){return St(this)}getHash(){return this.uuid}getUpdateType(){return this.updateType}getUpdateBeforeType(){return this.updateBeforeType}getNodeType(){return this.nodeType}getReference(e){const t=this.getHash(e);return e.getNodeFromHash(t)||this}construct(e){const t=e.getNodeProperties(this);for(const{childNode:s}of this.getChildren())t["_node"+s.id]=s;return null}analyze(e){const t=e.getDataFromNode(this);if(t.dependenciesCount=t.dependenciesCount===void 0?1:t.dependenciesCount+1,t.dependenciesCount===1){const s=e.getNodeProperties(this);for(const r of Object.values(s))r&&r.isNode===!0&&r.build(e)}}generate(e,t){const{outputNode:s}=e.getNodeProperties(this);if(s&&s.isNode===!0)return s.build(e,t)}updateBefore(){console.warn("Abstract function.")}update(){console.warn("Abstract function.")}build(e,t=null){const s=this.getReference(e);if(this!==s)return s.build(e,t);e.addNode(this),e.addChain(this);let r=null;const n=e.getBuildStage();if(n==="construct"){const i=e.getNodeProperties(this);if(i.initialized!==!0||e.context.tempRead===!1){i.initialized=!0,i.outputNode=this.construct(e);for(const a of Object.values(i))a&&a.isNode===!0&&a.build(e)}}else if(n==="analyze")this.analyze(e);else if(n==="generate")if(this.generate.length===1){const a=this.getNodeType(e),c=e.getDataFromNode(this);r=c.snippet,r===void 0&&(r=this.generate(e)||"",c.snippet=r),r=e.format(r,a,t)}else r=this.generate(e,t)||"";return e.removeChain(this),r}getSerializeChildren(){return We(this)}serialize(e){const t=this.getSerializeChildren(),s={};for(const{property:r,index:n,childNode:i}of t)n!==void 0?(s[r]===void 0&&(s[r]=Number.isInteger(n)?[]:{}),s[r][n]=i.toJSON(e.meta).uuid):s[r]=i.toJSON(e.meta).uuid;Object.keys(s).length>0&&(e.inputNodes=s)}deserialize(e){if(e.inputNodes!==void 0){const t=e.meta.nodes;for(const s in e.inputNodes)if(Array.isArray(e.inputNodes[s])){const r=[];for(const n of e.inputNodes[s])r.push(t[n]);this[s]=r}else if(typeof e.inputNodes[s]=="object"){const r={};for(const n in e.inputNodes[s]){const i=e.inputNodes[s][n];r[n]=t[i]}this[s]=r}else{const r=e.inputNodes[s];this[s]=t[r]}}}toJSON(e){const{uuid:t,type:s}=this,r=e===void 0||typeof e=="string";r&&(e={textures:{},images:{},nodes:{}});let n=e.nodes[t];n===void 0&&(n={uuid:t,type:s,meta:e,metadata:{version:4.5,type:"Node",generator:"Node.toJSON"}},r!==!0&&(e.nodes[n.uuid]=n),this.serialize(n),delete n.meta);function i(a){const c=[];for(const l in a){const d=a[l];delete d.metadata,c.push(d)}return c}if(r){const a=i(e.textures),c=i(e.images),l=i(e.nodes);a.length>0&&(n.textures=a),c.length>0&&(n.images=c),l.length>0&&(n.nodes=l)}return n}}const v=Co;function T(o){if(typeof o!="function"||!o.name)throw new Error(`Node class ${o.name} is not a class`);if(Yt.has(o.name))throw new Error(`Redefinition of node class ${o.name}`);Yt.set(o.name,o)}class xs extends v{constructor(e,t=null){super(t),this.isInputNode=!0,this.value=e,this.precision=null}getNodeType(){return this.nodeType===null?De(this.value):this.nodeType}getInputType(e){return this.getNodeType(e)}setPrecision(e){return this.precision=e,this}serialize(e){super.serialize(e),e.value=this.value,this.value&&this.value.toArray&&(e.value=this.value.toArray()),e.valueType=De(this.value),e.nodeType=this.nodeType,e.valueType==="ArrayBuffer"&&(e.value=yo(e.value)),e.precision=this.precision}deserialize(e){super.deserialize(e),this.nodeType=e.nodeType,this.value=Array.isArray(e.value)?ft(e.valueType,...e.value):e.value,this.precision=e.precision||null,this.value&&this.value.fromArray&&(this.value=this.value.fromArray(e.value))}generate(){console.warn("Abstract function.")}}const Ts=xs;T(xs);class Ns extends v{constructor(e,t){super(),this.node=e,this.indexNode=t}getNodeType(e){return this.node.getNodeType(e)}generate(e){const t=this.node.build(e),s=this.indexNode.build(e,"uint");return`${t}[ ${s} ]`}}const ys=Ns;T(Ns);class Ss extends v{constructor(e,t){super(),this.node=e,this.convertTo=t}getNodeType(e){const t=this.node.getNodeType(e);let s=null;for(const r of this.convertTo.split("|"))(s===null||e.getTypeLength(t)===e.getTypeLength(r))&&(s=r);return s}serialize(e){super.serialize(e),e.convertTo=this.convertTo}deserialize(e){super.deserialize(e),this.convertTo=e.convertTo}generate(e,t){const s=this.node,r=this.getNodeType(e),n=s.build(e,r);return e.format(n,r,t)}}const bs=Ss;T(Ss);class Cs extends v{constructor(e){super(e),this.isTempNode=!0}hasDependencies(e){return e.getDataFromNode(this).dependenciesCount>1}build(e,t){if(e.getBuildStage()==="generate"){const r=e.getVectorType(this.getNodeType(e,t)),n=e.getDataFromNode(this);if(e.context.tempRead!==!1&&n.propertyName!==void 0)return e.format(n.propertyName,r,t);if(e.context.tempWrite!==!1&&r!=="void"&&t!=="void"&&this.hasDependencies(e)){const i=super.build(e,r),a=e.getVarFromNode(this,r),c=e.getPropertyName(a);return e.addLineFlowCode(`${c} = ${i}`),n.snippet=i,n.propertyName=c,e.format(n.propertyName,r,t)}}return super.build(e,t)}}const Te=Cs;T(Cs);class vs extends Te{constructor(e=[],t=null){super(t),this.nodes=e}getNodeType(e){return this.nodeType!==null?e.getVectorType(this.nodeType):e.getTypeFromLength(this.nodes.reduce((t,s)=>t+e.getTypeLength(s.getNodeType(e)),0))}generate(e,t){const s=this.getNodeType(e),r=this.nodes,n=[];for(const a of r){const c=a.build(e);n.push(c)}const i=`${e.getType(s)}( ${n.join(", ")} )`;return e.format(i,s,t)}}const vo=vs;T(vs);const Ao=ms.join("");class As extends v{constructor(e,t="x"){super(),this.node=e,this.components=t}getVectorLength(){let e=this.components.length;for(const t of this.components)e=Math.max(ms.indexOf(t)+1,e);return e}getNodeType(e){return e.getTypeFromLength(this.components.length)}generate(e,t){const s=this.node,r=e.getTypeLength(s.getNodeType(e));let n=null;if(r>1){let i=null;this.getVectorLength()>=r&&(i=e.getTypeFromLength(this.getVectorLength()));const c=s.build(e,i);this.components.length===r&&this.components===Ao.slice(0,this.components.length)?n=e.format(c,i,t):n=e.format(`${c}.${this.components}`,this.getNodeType(e),t)}else n=s.build(e,t);return n}serialize(e){super.serialize(e),e.components=this.components}deserialize(e){super.deserialize(e),this.components=e.components}}const Kt=As;T(As);class ws extends Ts{constructor(e,t=null){super(e,t),this.isConstNode=!0}generateConst(e){return e.getConst(this.getNodeType(e),this.value)}generate(e,t){const s=this.getNodeType(e);return e.format(this.generateConst(e),s,t)}}const H=ws;T(ws);const he=new Map;function p(o,e){if(he.has(o))throw new Error(`Redefinition of node element ${o}`);if(typeof e!="function")throw new Error(`Node element ${o} is not a function`);he.set(o,e)}const Rs={construct(o,e){const t=e.shift();return o(Gs(t),...e)},get:function(o,e,t){if(typeof e=="string"&&o[e]===void 0)if(he.has(e)){const s=he.get(e);return(...r)=>s(t,...r)}else if(e.endsWith("Assign")&&he.has(e.slice(0,e.length-6))){const s=he.get(e.slice(0,e.length-6));return(...r)=>t.assign(s(t,...r))}else{if(/^[xyzwrgbastpq]{1,4}$/.test(e)===!0)return e=e.replace(/r|s/g,"x").replace(/g|t/g,"y").replace(/b|p/g,"z").replace(/a|q/g,"w"),C(new Kt(o,e));if(e==="width"||e==="height")return C(new Kt(o,e==="width"?"x":"y"));if(/^\d+$/.test(e)===!0)return C(new ys(o,new H(Number(e),"uint")))}return o[e]}},nt=new WeakMap,wo=function(o){const e=De(o);if(e==="node"){let t=nt.get(o);return t===void 0&&(t=new Proxy(o,Rs),nt.set(o,t),nt.set(t,t)),t}else{if(e==="float"||e==="boolean")return C(Ms(o));if(e&&e!=="string")return C(new H(o))}return o},Ro=function(o){for(const e in o)o[e]=C(o[e]);return o},Uo=function(o){const e=o.length;for(let t=0;t<e;t++)o[t]=C(o[t]);return o},Mo=function(o,e=null,t=null,s=null){const r=n=>C(s!==null?Object.assign(n,s):n);return e===null?(...n)=>r(new o(...Le(n))):t!==null?(t=C(t),(...n)=>r(new o(e,...Le(n),t))):(...n)=>r(new o(e,...Le(n)))},Go=function(o,...e){return C(new o(...Le(e)))};class _o extends v{constructor(e){super(),this._jsFunc=e}call(e,t,s){return e=Gs(e),C(this._jsFunc(e,t,s))}getNodeType(e){const{outputNode:t}=e.getNodeProperties(this);return t?t.getNodeType(e):super.getNodeType(e)}construct(e){return e.addStack(),e.stack.outputNode=C(this._jsFunc(e.stack,e)),e.removeStack()}}const Po=[!1,!0],Eo=[0,1,2,3],Bo=[-1,-2],Us=[.5,1.5,1/3,1e-6,1e6,Math.PI,Math.PI*2,1/Math.PI,2/Math.PI,1/(Math.PI*2),Math.PI/2],bt=new Map;for(const o of Po)bt.set(o,new H(o));const Ct=new Map;for(const o of Eo)Ct.set(o,new H(o,"uint"));const vt=new Map([...Ct].map(o=>new H(o.value,"int")));for(const o of Bo)vt.set(o,new H(o,"int"));const Xe=new Map([...vt].map(o=>new H(o.value)));for(const o of Us)Xe.set(o,new H(o));for(const o of Us)Xe.set(-o,new H(-o));const Ye={bool:bt,uint:Ct,ints:vt,float:Xe},Zt=new Map([...bt,...Xe]),Ms=o=>Zt.has(o)?Zt.get(o):o.isNode===!0?o:new H(o),_=function(o,e=null){return(...t)=>{if(t.length===0)return C(new H(ft(o),o));{if(o==="color"&&t[0].isNode!==!0&&(t=[ft(o,...t)]),t.length===1&&e!==null&&e.has(t[0]))return e.get(t[0]);const s=t.map(Ms);return s.length===1?C(s[0].nodeType===o||De(s[0].value)===o?s[0]:new bs(s[0],o)):C(new vo(s,o))}}},_e=o=>o!=null?o.nodeType||o.convertTo||(typeof o=="string"?o:null):null;function J(o){return new Proxy(new _o(o),Rs)}const C=o=>wo(o),Gs=o=>new Ro(o),Le=o=>new Uo(o),g=(...o)=>new Mo(...o),N=(...o)=>new Go(...o),it=(...o)=>new J(...o);T(J);const Fo=new _("color"),ee=new _("float",Ye.float),Lo=new _("int",Ye.int),Io=new _("uint",Ye.uint),Oo=new _("bool",Ye.bool),Ue=new _("vec2"),Wo=new _("ivec2"),Do=new _("uvec2"),Vo=new _("bvec2"),V=new _("vec3"),ko=new _("ivec3"),$o=new _("uvec3"),zo=new _("bvec3"),ne=new _("vec4"),qo=new _("ivec4"),Ho=new _("uvec4"),Xo=new _("bvec4"),Me=new _("mat3"),Yo=new _("imat3"),Ko=new _("umat3"),Zo=new _("bmat3"),Jo=new _("mat4"),jo=new _("imat4"),Qo=new _("umat4"),ea=new _("bmat4"),ta=(o="")=>C(new H(o,"string")),sa=o=>C(new H(o,"ArrayBuffer"));p("color",Fo);p("float",ee);p("int",Lo);p("uint",Io);p("bool",Oo);p("vec2",Ue);p("ivec2",Wo);p("uvec2",Do);p("bvec2",Vo);p("vec3",V);p("ivec3",ko);p("uvec3",$o);p("bvec3",zo);p("vec4",ne);p("ivec4",qo);p("uvec4",Ho);p("bvec4",Xo);p("mat3",Me);p("imat3",Yo);p("umat3",Ko);p("bmat3",Zo);p("mat4",Jo);p("imat4",jo);p("umat4",Qo);p("bmat4",ea);p("string",ta);p("arrayBuffer",sa);const ra=g(ys),na=(o,e)=>C(new bs(C(o),e));p("element",ra);p("convert",na);class At extends Ts{constructor(e,t=null){super(e,t),this.isUniformNode=!0}getUniformHash(e){return this.getHash(e)}generate(e,t){const s=this.getNodeType(e),r=this.getUniformHash(e);let n=e.getNodeFromHash(r);n===void 0&&(e.setHashNode(this,r),n=this);const i=n.getInputType(e),a=e.getUniformFromNode(n,e.shaderStage,i),c=e.getPropertyName(a);return e.format(c,s,t)}}const Ke=At,te=(o,e)=>{const t=_e(e||o),s=o&&o.isNode===!0?o.node&&o.node.value||o.value:o;return C(new At(s,t))};T(At);class _s extends v{constructor(e,t=null){super(),this.node=e,this.name=t}isGlobal(){return!0}getHash(e){return this.name||super.getHash(e)}getNodeType(e){return this.node.getNodeType(e)}generate(e){const{name:t,node:s}=this,r=this.getNodeType(e),n=e.getVaryingFromNode(this,r);n.needsInterpolation||(n.needsInterpolation=e.shaderStage==="fragment"),t!==null&&(n.name=t);const i=e.getPropertyName(n,Xt.VERTEX);return e.flowNodeFromShaderStage(Xt.VERTEX,s,r,i),e.getPropertyName(n)}}const $=g(_s);p("varying",$);T(_s);class wt extends v{constructor(e,t=null){super(t),this._attributeName=e}getHash(e){return this.getAttributeName(e)}getNodeType(e){const t=this.getAttributeName(e);let s=super.getNodeType(e);if(s===null)if(e.hasGeometryAttribute(t)){const r=e.geometry.getAttribute(t);s=e.getTypeFromAttribute(r)}else s="float";return s}setAttributeName(e){return this._attributeName=e,this}getAttributeName(){return this._attributeName}generate(e){const t=this.getAttributeName(e),s=this.getNodeType(e);if(e.hasGeometryAttribute(t)===!0){const n=e.geometry.getAttribute(t),i=e.getTypeFromAttribute(n),a=e.getAttribute(t,i);return e.isShaderStage("vertex")?e.format(a.name,i,s):$(this).build(e,s)}else return console.warn(`AttributeNode: Attribute "${t}" not found.`),e.getConst(s)}}const pe=(o,e)=>C(new wt(o,e));T(wt);class Ps extends v{constructor(e,t){super(),this.isBypassNode=!0,this.outputNode=e,this.callNode=t}getNodeType(e){return this.outputNode.getNodeType(e)}generate(e,t){const s=this.callNode.build(e,"void");return s!==""&&e.addLineFlowCode(s),this.outputNode.build(e,t)}}const Es=g(Ps);p("bypass",Es);T(Ps);let ia=0;class oa{constructor(){this.id=ia++,this.nodesData=new WeakMap}getNodeData(e){return this.nodesData.get(e)}setNodeData(e,t){this.nodesData.set(e,t)}}const Bs=oa;class Fs extends v{constructor(e,t=new Bs){super(),this.isCacheNode=!0,this.node=e,this.cache=t}getNodeType(e){return this.node.getNodeType(e)}build(e,...t){const s=e.getCache();e.setCache(this.cache);const r=this.node.build(e,...t);return e.setCache(s),r}}const Ls=g(Fs);p("cache",Ls);T(Fs);class Is extends v{constructor(e,t={}){super(),this.isContextNode=!0,this.node=e,this.context=t}getNodeType(e){return this.node.getNodeType(e)}construct(e){const t=e.getContext();e.setContext({...e.context,...this.context});const s=this.node.build(e);return e.setContext(t),s}generate(e,t){const s=e.getContext();e.setContext({...e.context,...this.context});const r=this.node.build(e,t);return e.setContext(s),r}}const oe=g(Is);p("context",oe);T(Is);class Os extends v{constructor(){super("uint"),this.isInstanceIndexNode=!0}generate(e){return e.getInstanceIndex()}}const aa=N(Os);T(Os);class ca{constructor(e,t){this.isNodeAttribute=!0,this.name=e,this.type=t}}const ua=ca;class la{constructor(e,t,s,r=void 0){this.isNodeUniform=!0,this.name=e,this.type=t,this.node=s,this.needsUpdate=r}get value(){return this.node.value}set value(e){this.node.value=e}}const da=la;class ha{constructor(e,t){this.isNodeVar=!0,this.name=e,this.type=t}}const Ws=ha;class pa extends Ws{constructor(e,t){super(e,t),this.needsInterpolation=!1,this.isNodeVarying=!0}}const fa=pa;class ga{constructor(e,t,s=""){this.name=e,this.type=t,this.code=s,Object.defineProperty(this,"isNodeCode",{value:!0})}}const ma=ga;class xa{constructor(){this.keywords=[],this.nodes=[],this.keywordsCallback={}}getNode(e){let t=this.nodes[e];return t===void 0&&this.keywordsCallback[e]!==void 0&&(t=this.keywordsCallback[e](e),this.nodes[e]=t),t}addKeyword(e,t){return this.keywords.push(e),this.keywordsCallback[e]=t,this}parse(e){const t=this.keywords,s=new RegExp(`\\b${t.join("\\b|\\b")}\\b`,"g"),r=e.match(s),n=[];if(r!==null)for(const i of r){const a=this.getNode(i);a!==void 0&&n.indexOf(a)===-1&&n.push(a)}return n}include(e,t){const s=this.parse(t);for(const r of s)r.build(e)}}const Ta=xa;class E extends Te{constructor(e,t,s,...r){if(super(),this.op=e,r.length>0){let n=s;for(let i=0;i<r.length;i++)n=new E(e,n,r[i]);s=n}this.aNode=t,this.bNode=s}hasDependencies(e){return this.op!=="="?super.hasDependencies(e):!1}getNodeType(e,t){const s=this.op,r=this.aNode,n=this.bNode,i=r.getNodeType(e),a=n.getNodeType(e);if(i==="void"||a==="void")return"void";if(s==="="||s==="%")return i;if(s==="&"||s==="|"||s==="^"||s===">>"||s==="<<")return e.getIntegerType(i);if(s==="=="||s==="&&"||s==="||"||s==="^^")return"bool";if(s==="<"||s===">"||s==="<="||s===">="){const c=t?e.getTypeLength(t):Math.max(e.getTypeLength(i),e.getTypeLength(a));return c>1?`bvec${c}`:"bool"}else return i==="float"&&e.isMatrix(a)?a:e.isMatrix(i)&&e.isVector(a)?e.getVectorFromMatrix(i):e.isVector(i)&&e.isMatrix(a)?e.getVectorFromMatrix(a):e.getTypeLength(a)>e.getTypeLength(i)?a:i}generate(e,t){const s=this.op,r=this.aNode,n=this.bNode,i=this.getNodeType(e,t);let a=null,c=null;i!=="void"?(a=r.getNodeType(e),c=n.getNodeType(e),s==="="?c=a:s==="<"||s===">"||s==="<="||s===">="?e.isVector(a)?c=a:a=c="float":s===">>"||s==="<<"?(a=i,c=e.changeComponentType(c,"uint")):e.isMatrix(a)&&e.isVector(c)?c=e.getVectorFromMatrix(a):e.isVector(a)&&e.isMatrix(c)?a=e.getVectorFromMatrix(c):a=c=i):a=c=i;const l=r.build(e,a),d=n.build(e,c),f=e.getTypeLength(t);if(t!=="void")return s==="="?(e.addLineFlowCode(`${l} ${this.op} ${d}`),l):s==="<"&&f>1?e.format(`${e.getMethod("lessThan")}( ${l}, ${d} )`,i,t):s==="<="&&f>1?e.format(`${e.getMethod("lessThanEqual")}( ${l}, ${d} )`,i,t):s===">"&&f>1?e.format(`${e.getMethod("greaterThan")}( ${l}, ${d} )`,i,t):s===">="&&f>1?e.format(`${e.getMethod("greaterThanEqual")}( ${l}, ${d} )`,i,t):e.format(`( ${l} ${this.op} ${d} )`,i,t);if(a!=="void")return e.format(`${l} ${this.op} ${d}`,i,t)}serialize(e){super.serialize(e),e.op=this.op}deserialize(e){super.deserialize(e),this.op=e.op}}const Ve=g(E,"+"),gt=g(E,"-"),Ds=g(E,"*"),Vs=g(E,"/"),Na=g(E,"%"),ya=g(E,"=="),ks=g(E,"="),Sa=g(E,"<"),ba=g(E,">"),Ca=g(E,"<="),va=g(E,">="),Aa=g(E,"&&"),wa=g(E,"||"),Ra=g(E,"^^"),Ua=g(E,"&"),Ma=g(E,"|"),Ga=g(E,"^"),_a=g(E,"<<"),Pa=g(E,">>");p("add",Ve);p("sub",gt);p("mul",Ds);p("div",Vs);p("remainder",Na);p("equal",ya);p("assign",ks);p("lessThan",Sa);p("greaterThan",ba);p("lessThanEqual",Ca);p("greaterThanEqual",va);p("and",Aa);p("or",wa);p("xor",Ra);p("bitAnd",Ua);p("bitOr",Ma);p("bitXor",Ga);p("shiftLeft",_a);p("shiftRight",Pa);T(E);class $s extends v{constructor(e="",t="void"){super(t),this.snippet=e}generate(e,t){const s=this.getNodeType(e),r=this.snippet;if(s==="void")e.addLineFlowCode(r);else return e.format(`( ${r} )`,s,t)}}const Ea=g($s);T($s);class ce extends v{constructor(e,t=null){super(e),this.name=t}getHash(e){return this.name||super.getHash(e)}isGlobal(){return!0}generate(e){const t=e.getVarFromNode(this,this.getNodeType(e)),s=this.name;return s!==null&&(t.name=s),e.getPropertyName(t)}}const Ba=(o,e)=>C(new ce(o,_e(e))),de=N(ce,"vec4","DiffuseColor"),ot=N(ce,"float","Roughness");N(ce,"float","Metalness");N(ce,"color","SpecularColor");N(ce,"float","Shininess");T(ce);class zs extends v{constructor(e,t,s=null){super(),this.condNode=e,this.ifNode=t,this.elseNode=s}getNodeType(e){const t=this.ifNode.getNodeType(e);if(this.elseNode!==null){const s=this.elseNode.getNodeType(e);if(e.getTypeLength(s)>e.getTypeLength(t))return s}return t}generate(e){const t=this.getNodeType(e),s={tempWrite:!1},{ifNode:r,elseNode:n}=this,i=r.getNodeType(e)!=="void"||n&&n.getNodeType(e)!=="void",a=i?Ba(t).build(e):"",c=oe(this.condNode).build(e,"bool");e.addFlowCode(`
${e.tab}if ( ${c} ) {

`).addFlowTab();let l=oe(this.ifNode,s).build(e,t);if(l=i?a+" = "+l+";":l,e.removeFlowTab().addFlowCode(e.tab+"	"+l+`

`+e.tab+"}"),n!==null){e.addFlowCode(` else {

`).addFlowTab();let d=oe(n,s).build(e,t);d=a?a+" = "+d+";":d,e.removeFlowTab().addFlowCode(e.tab+"	"+d+`

`+e.tab+`}

`)}else e.addFlowCode(`

`);return a}}const ke=g(zs);p("cond",ke);T(zs);class qs extends v{constructor(e=null){super(),this.nodes=[],this.outputNode=null,this.parent=e,this._currentCond=null,this.isStackNode=!0}getNodeType(e){return this.outputNode?this.outputNode.getNodeType(e):"void"}add(e){return this.nodes.push(Es(Ea(),e)),this}if(e,t){const s=it(t);return this._currentCond=ke(e,s),this.add(this._currentCond)}elseif(e,t){const s=it(t),r=ke(e,s);return this._currentCond.elseNode=r,this._currentCond=r,this}else(e){return this._currentCond.elseNode=it(e),this}assign(e,t){return this.add(ks(e,t))}build(e,...t){for(const s of this.nodes)s.build(e);return this.outputNode?this.outputNode.build(e,...t):super.build(e,...t)}}const Jt=g(qs);T(qs);class Hs extends Ke{constructor(e){super(0),this.textureNode=e,this.updateType=O.FRAME}get texture(){return this.textureNode.value}update(){const e=this.texture,t=e.images,s=t&&t.length>0?t[0]&&t[0].image||t[0]:e.image;if(s&&s.width!==void 0){const{width:r,height:n}=s;this.value=Math.log2(Math.max(r,n))}}}const Xs=g(Hs);T(Hs);const Fa=new Map([[2,"vec2"],[3,"vec3"],[4,"vec4"],[9,"mat3"],[16,"mat4"]]),La=new Map([[Int8Array,"int"],[Int16Array,"int"],[Int32Array,"int"],[Uint8Array,"uint"],[Uint16Array,"uint"],[Uint32Array,"uint"],[Float32Array,"float"]]),Ia=new Set([Int32Array,Uint32Array,Float32Array]),Ee=o=>(o=Number(o),o+(o%1?"":".0"));class Oa{constructor(e,t,s){this.object=e,this.material=e&&(e.material||null),this.geometry=e&&(e.geometry||null),this.renderer=t,this.parser=s,this.nodes=[],this.updateNodes=[],this.updateBeforeNodes=[],this.hashNodes={},this.lightsNode=null,this.environmentNode=null,this.fogNode=null,this.toneMappingNode=null,this.vertexShader=null,this.fragmentShader=null,this.computeShader=null,this.flowNodes={vertex:[],fragment:[],compute:[]},this.flowCode={vertex:"",fragment:"",compute:[]},this.uniforms={vertex:[],fragment:[],compute:[],index:0},this.codes={vertex:[],fragment:[],compute:[]},this.attributes=[],this.varyings=[],this.vars={vertex:[],fragment:[],compute:[]},this.flow={code:""},this.chaining=[],this.stack=Jt(),this.tab="	",this.context={keywords:new Ta,material:this.material,getMIPLevelAlgorithmNode:(r,n)=>n.mul(Xs(r))},this.cache=new Bs,this.globalCache=this.cache,this.flowsData=new WeakMap,this.shaderStage=null,this.buildStage=null}setHashNode(e,t){this.hashNodes[t]=e}addNode(e){if(this.nodes.indexOf(e)===-1){const t=e.getUpdateType(),s=e.getUpdateBeforeType();t!==O.NONE&&this.updateNodes.push(e),s!==O.NONE&&this.updateBeforeNodes.push(e),this.nodes.push(e),this.setHashNode(e,e.getHash(this))}}get currentNode(){return this.chaining[this.chaining.length-1]}addChain(e){this.chaining.push(e)}removeChain(e){if(this.chaining.pop()!==e)throw new Error("NodeBuilder: Invalid node chaining!")}getMethod(e){return e}getNodeFromHash(e){return this.hashNodes[e]}addFlow(e,t){return this.flowNodes[e].push(t),t}setContext(e){this.context=e}getContext(){return this.context}setCache(e){this.cache=e}getCache(){return this.cache}isAvailable(){return!1}getInstanceIndex(){console.warn("Abstract function.")}getFrontFacing(){console.warn("Abstract function.")}getFragCoord(){console.warn("Abstract function.")}isFlipY(){return!1}getTexture(){console.warn("Abstract function.")}getTextureLevel(){console.warn("Abstract function.")}getConst(e,t=null){if(t===null&&(e==="float"||e==="int"||e==="uint"?t=0:e==="bool"?t=!1:e==="color"?t=new xe:e==="vec2"?t=new qe:e==="vec3"?t=new ie:e==="vec4"&&(t=new yt)),e==="float")return Ee(t);if(e==="int")return`${Math.round(t)}`;if(e==="uint")return t>=0?`${Math.round(t)}u`:"0u";if(e==="bool")return t?"true":"false";if(e==="color")return`${this.getType("vec3")}( ${Ee(t.r)}, ${Ee(t.g)}, ${Ee(t.b)} )`;const s=this.getTypeLength(e),r=this.getComponentType(e),n=i=>this.getConst(r,i);if(s===2)return`${this.getType(e)}( ${n(t.x)}, ${n(t.y)} )`;if(s===3)return`${this.getType(e)}( ${n(t.x)}, ${n(t.y)}, ${n(t.z)} )`;if(s===4)return`${this.getType(e)}( ${n(t.x)}, ${n(t.y)}, ${n(t.z)}, ${n(t.w)} )`;if(s>4)return`${this.getType(e)}()`;throw new Error(`NodeBuilder: Type '${e}' not found in generate constant attempt.`)}getType(e){return e}generateMethod(e){return e}hasGeometryAttribute(e){return this.geometry&&this.geometry.getAttribute(e)!==void 0}getAttribute(e,t){const s=this.attributes;for(const n of s)if(n.name===e)return n;const r=new ua(e,t);return s.push(r),r}getPropertyName(e){return e.name}isVector(e){return/vec\d/.test(e)}isMatrix(e){return/mat\d/.test(e)}isReference(e){return e==="void"||e==="property"||e==="sampler"||e==="texture"||e==="cubeTexture"}isShaderStage(e){return this.shaderStage===e}getTextureEncodingFromMap(e){return console.warn("THREE.NodeBuilder: Method .getTextureEncodingFromMap replaced by .getTextureColorSpaceFromMap in r152+."),this.getTextureColorSpaceFromMap(e)===P?Dn:Vn}getTextureColorSpaceFromMap(e){let t;return e&&e.isTexture?t=e.colorSpace:e&&e.isWebGLRenderTarget?t=e.texture.colorSpace:t=$n,t}getComponentType(e){if(e=this.getVectorType(e),e==="float"||e==="bool"||e==="int"||e==="uint")return e;const t=/(b|i|u|)(vec|mat)([2-4])/.exec(e);return t===null?null:t[1]==="b"?"bool":t[1]==="i"?"int":t[1]==="u"?"uint":"float"}getVectorType(e){return e==="color"?"vec3":e==="texture"?"vec4":e}getTypeFromLength(e,t="float"){if(e===1)return t;const s=Fa.get(e);return(t==="float"?"":t[0])+s}getTypeFromArray(e){return La.get(e.constructor)}getTypeFromAttribute(e){let t=e;e.isInterleavedBufferAttribute&&(t=e.data);const s=t.array,r=Ia.has(s.constructor)?e.itemSize:t.stride||e.itemSize,n=e.normalized;let i;return!(e instanceof ls)&&n!==!0&&(i=this.getTypeFromArray(s)),this.getTypeFromLength(r,i)}getTypeLength(e){const t=this.getVectorType(e),s=/vec([2-4])/.exec(t);return s!==null?Number(s[1]):t==="float"||t==="bool"||t==="int"||t==="uint"?1:/mat3/.test(e)===!0?9:/mat4/.test(e)===!0?16:0}getVectorFromMatrix(e){return e.replace("mat","vec")}changeComponentType(e,t){return this.getTypeFromLength(this.getTypeLength(e),t)}getIntegerType(e){const t=this.getComponentType(e);return t==="int"||t==="uint"?e:this.changeComponentType(e,"int")}addStack(){return this.stack=Jt(this.stack),this.stack}removeStack(){const e=this.stack;return this.stack=e.parent,e}getDataFromNode(e,t=this.shaderStage){const s=e.isGlobal(this)?this.globalCache:this.cache;let r=s.getNodeData(e);return r===void 0&&(r={vertex:{},fragment:{},compute:{}},s.setNodeData(e,r)),t!==null?r[t]:r}getNodeProperties(e,t=this.shaderStage){const s=this.getDataFromNode(e,t);return s.properties||(s.properties={outputNode:null})}getUniformFromNode(e,t,s){const r=this.getDataFromNode(e,t);let n=r.uniform;if(n===void 0){const i=this.uniforms.index++;n=new da("nodeUniform"+i,s,e),this.uniforms[t].push(n),r.uniform=n}return n}getVarFromNode(e,t,s=this.shaderStage){const r=this.getDataFromNode(e,s);let n=r.variable;if(n===void 0){const i=this.vars[s],a=i.length;n=new Ws("nodeVar"+a,t),i.push(n),r.variable=n}return n}getVaryingFromNode(e,t){const s=this.getDataFromNode(e,null);let r=s.varying;if(r===void 0){const n=this.varyings,i=n.length;r=new fa("nodeVarying"+i,t),n.push(r),s.varying=r}return r}getCodeFromNode(e,t,s=this.shaderStage){const r=this.getDataFromNode(e);let n=r.code;if(n===void 0){const i=this.codes[s],a=i.length;n=new ma("nodeCode"+a,t),i.push(n),r.code=n}return n}addLineFlowCode(e){return e===""?this:(e=this.tab+e,/;\s*$/.test(e)||(e=e+`;
`),this.flow.code+=e,this)}addFlowCode(e){return this.flow.code+=e,this}addFlowTab(){return this.tab+="	",this}removeFlowTab(){return this.tab=this.tab.slice(0,-1),this}getFlowData(e){return this.flowsData.get(e)}flowNode(e){const t=e.getNodeType(this),s=this.flowChildNode(e,t);return this.flowsData.set(e,s),s}flowChildNode(e,t=null){const s=this.flow,r={code:""};return this.flow=r,r.result=e.build(this,t),this.flow=s,r}flowNodeFromShaderStage(e,t,s=null,r=null){const n=this.shaderStage;this.setShaderStage(e);const i=this.flowChildNode(t,s);return r!==null&&(i.code+=`${this.tab+r} = ${i.result};
`),this.flowCode[e]=this.flowCode[e]+i.code,this.setShaderStage(n),i}getAttributes(){console.warn("Abstract function.")}getVaryings(){console.warn("Abstract function.")}getVars(e){let t="";const s=this.vars[e];for(const r of s)t+=`${r.type} ${r.name}; `;return t}getUniforms(){console.warn("Abstract function.")}getCodes(e){const t=this.codes[e];let s="";for(const r of t)s+=r.code+`
`;return s}getHash(){return this.vertexShader+this.fragmentShader+this.computeShader}setShaderStage(e){this.shaderStage=e}getShaderStage(){return this.shaderStage}setBuildStage(e){this.buildStage=e}getBuildStage(){return this.buildStage}buildCode(){console.warn("Abstract function.")}build(){for(const e of To){this.setBuildStage(e),this.context.vertex&&this.context.vertex.isNode&&this.flowNodeFromShaderStage("vertex",this.context.vertex);for(const t of No){this.setShaderStage(t);const s=this.flowNodes[t];for(const r of s)e==="generate"?this.flowNode(r):r.build(this)}}return this.setBuildStage(null),this.setShaderStage(null),this.buildCode(),this}format(e,t,s){if(t=this.getVectorType(t),s=this.getVectorType(s),t===s||s===null||this.isReference(s))return e;const r=this.getTypeLength(t),n=this.getTypeLength(s);return r>4||n>4||n===0?e:r===n?`${this.getType(s)}( ${e} )`:r>n?this.format(`${e}.${"xyz".slice(0,n)}`,this.getTypeFromLength(n,this.getComponentType(t)),s):n===4?`${this.getType(s)}( ${this.format(e,t,"vec3")}, 1.0 )`:r===2?`${this.getType(s)}( ${this.format(e,t,"vec2")}, 0.0 )`:`${this.getType(s)}( ${e} )`}getSignature(){return`// Three.js r${kn} - NodeMaterial System
`}}const Wa=Oa;class Da{constructor(){this.time=0,this.deltaTime=0,this.frameId=0,this.renderId=0,this.startTime=null,this.frameMap=new WeakMap,this.frameBeforeMap=new WeakMap,this.renderMap=new WeakMap,this.renderBeforeMap=new WeakMap,this.renderer=null,this.material=null,this.camera=null,this.object=null,this.scene=null}updateBeforeNode(e){const t=e.getUpdateBeforeType();t===O.FRAME?this.frameBeforeMap.get(e)!==this.frameId&&(this.frameBeforeMap.set(e,this.frameId),e.updateBefore(this)):t===O.RENDER?(this.renderBeforeMap.get(e)!==this.renderId||this.frameBeforeMap.get(e)!==this.frameId)&&(this.renderBeforeMap.set(e,this.renderId),this.frameBeforeMap.set(e,this.frameId),e.updateBefore(this)):t===O.OBJECT&&e.updateBefore(this)}updateNode(e){const t=e.getUpdateType();t===O.FRAME?this.frameMap.get(e)!==this.frameId&&(this.frameMap.set(e,this.frameId),e.update(this)):t===O.RENDER?(this.renderMap.get(e)!==this.renderId||this.frameMap.get(e)!==this.frameId)&&(this.renderMap.set(e,this.renderId),this.frameMap.set(e,this.frameId),e.update(this)):t===O.OBJECT&&e.update(this)}update(){this.frameId++,this.lastTime===void 0&&(this.lastTime=performance.now()),this.deltaTime=(performance.now()-this.lastTime)/1e3,this.lastTime=performance.now(),this.time+=this.deltaTime}}const jt=Da;class Ys{constructor(e,t,s=null,r="",n=!1){this.type=e,this.name=t,this.count=s,this.qualifier=r,this.isConst=n}}Ys.isNodeFunctionInput=!0;const Va=Ys;class Ks extends v{constructor(e,t=null){super(),this.node=e,this.name=t}assign(e){return e.traverse((t,s)=>{s&&t.uuid===this.uuid&&s(this.node)}),this.node=e,this}isGlobal(){return!0}getHash(e){return this.name||super.getHash(e)}getNodeType(e){return this.node.getNodeType(e)}generate(e){const t=this.node,s=this.name;if(s===null&&t.isTempNode===!0)return t.build(e);const r=e.getVectorType(this.getNodeType(e)),n=t.build(e,r),i=e.getVarFromNode(this,r);s!==null&&(i.name=s);const a=e.getPropertyName(i);return e.addLineFlowCode(`${a} = ${n}`),a}}const Ze=g(Ks),Zs=Ze;p("label",Ze);p("temp",Zs);T(Ks);class u extends Te{constructor(e,t,s=null,r=null){super(),this.method=e,this.aNode=t,this.bNode=s,this.cNode=r}getInputType(e){const t=this.aNode.getNodeType(e),s=this.bNode?this.bNode.getNodeType(e):null,r=this.cNode?this.cNode.getNodeType(e):null,n=e.isMatrix(t)?0:e.getTypeLength(t),i=e.isMatrix(s)?0:e.getTypeLength(s),a=e.isMatrix(r)?0:e.getTypeLength(r);return n>i&&n>a?t:i>a?s:a>n?r:t}getNodeType(e){const t=this.method;return t===u.LENGTH||t===u.DISTANCE||t===u.DOT?"float":t===u.CROSS?"vec3":this.getInputType(e)}generate(e,t){const s=this.method,r=this.getNodeType(e),n=this.getInputType(e),i=this.aNode,a=this.bNode,c=this.cNode,l=e.renderer.isWebGLRenderer===!0;if(s===u.TRANSFORM_DIRECTION){let d=i,f=a;e.isMatrix(d.getNodeType(e))?f=ne(V(f),0):d=ne(V(d),0);const m=Ds(d,f).xyz;return X(m).build(e,t)}else{if(s===u.NEGATE)return e.format("-"+i.build(e,n),r,t);if(s===u.ONE_MINUS)return gt(1,i).build(e,t);if(s===u.RECIPROCAL)return Vs(1,i).build(e,t);if(s===u.DIFFERENCE)return Js(gt(i,a)).build(e,t);{const d=[];return s===u.CROSS?d.push(i.build(e,r),a.build(e,r)):s===u.STEP?d.push(i.build(e,e.getTypeLength(i.getNodeType(e))===1?"float":n),a.build(e,n)):l&&(s===u.MIN||s===u.MAX)||s===u.MOD?d.push(i.build(e,n),a.build(e,e.getTypeLength(a.getNodeType(e))===1?"float":n)):s===u.REFRACT?d.push(i.build(e,n),a.build(e,n),c.build(e,"float")):s===u.MIX?d.push(i.build(e,n),a.build(e,n),c.build(e,e.getTypeLength(c.getNodeType(e))===1?"float":n)):(d.push(i.build(e,n)),a!==null&&d.push(a.build(e,n)),c!==null&&d.push(c.build(e,n))),e.format(`${e.getMethod(s)}( ${d.join(", ")} )`,r,t)}}}serialize(e){super.serialize(e),e.method=this.method}deserialize(e){super.deserialize(e),this.method=e.method}}u.RADIANS="radians";u.DEGREES="degrees";u.EXP="exp";u.EXP2="exp2";u.LOG="log";u.LOG2="log2";u.SQRT="sqrt";u.INVERSE_SQRT="inversesqrt";u.FLOOR="floor";u.CEIL="ceil";u.NORMALIZE="normalize";u.FRACT="fract";u.SIN="sin";u.COS="cos";u.TAN="tan";u.ASIN="asin";u.ACOS="acos";u.ATAN="atan";u.ABS="abs";u.SIGN="sign";u.LENGTH="length";u.NEGATE="negate";u.ONE_MINUS="oneMinus";u.DFDX="dFdx";u.DFDY="dFdy";u.ROUND="round";u.RECIPROCAL="reciprocal";u.ATAN2="atan2";u.MIN="min";u.MAX="max";u.MOD="mod";u.STEP="step";u.REFLECT="reflect";u.DISTANCE="distance";u.DIFFERENCE="difference";u.DOT="dot";u.CROSS="cross";u.POW="pow";u.TRANSFORM_DIRECTION="transformDirection";u.MIX="mix";u.CLAMP="clamp";u.REFRACT="refract";u.SMOOTHSTEP="smoothstep";u.FACEFORWARD="faceforward";ee(1e-6);ee(1e6);const ka=g(u,u.RADIANS),$a=g(u,u.DEGREES),za=g(u,u.EXP),qa=g(u,u.EXP2),Ha=g(u,u.LOG),Xa=g(u,u.LOG2),Ya=g(u,u.SQRT),Ka=g(u,u.INVERSE_SQRT),Za=g(u,u.FLOOR),Ja=g(u,u.CEIL),X=g(u,u.NORMALIZE),ja=g(u,u.FRACT),Qa=g(u,u.SIN),ec=g(u,u.COS),tc=g(u,u.TAN),sc=g(u,u.ASIN),rc=g(u,u.ACOS),nc=g(u,u.ATAN),Js=g(u,u.ABS),ic=g(u,u.SIGN),oc=g(u,u.LENGTH),js=g(u,u.NEGATE),ac=g(u,u.ONE_MINUS),cc=g(u,u.DFDX),uc=g(u,u.DFDY),lc=g(u,u.ROUND),dc=g(u,u.RECIPROCAL),hc=g(u,u.ATAN2),pc=g(u,u.MIN),fc=g(u,u.MAX),gc=g(u,u.MOD),mc=g(u,u.STEP),xc=g(u,u.REFLECT),Tc=g(u,u.DISTANCE),Nc=g(u,u.DIFFERENCE),yc=g(u,u.DOT),Sc=g(u,u.CROSS),bc=g(u,u.POW),Cc=g(u,u.POW,2),vc=g(u,u.POW,3),Ac=g(u,u.POW,4),Qs=g(u,u.TRANSFORM_DIRECTION),er=g(u,u.MIX),tr=(o,e=0,t=1)=>C(new u(u.CLAMP,C(o),C(e),C(t))),wc=o=>tr(o),Rc=g(u,u.REFRACT),sr=g(u,u.SMOOTHSTEP),Uc=g(u,u.FACEFORWARD),Mc=(o,e,t)=>er(e,t,o),Gc=(o,e,t)=>sr(e,t,o);p("radians",ka);p("degrees",$a);p("exp",za);p("exp2",qa);p("log",Ha);p("log2",Xa);p("sqrt",Ya);p("inverseSqrt",Ka);p("floor",Za);p("ceil",Ja);p("normalize",X);p("fract",ja);p("sin",Qa);p("cos",ec);p("tan",tc);p("asin",sc);p("acos",rc);p("atan",nc);p("abs",Js);p("sign",ic);p("length",oc);p("negate",js);p("oneMinus",ac);p("dFdx",cc);p("dFdy",uc);p("round",lc);p("reciprocal",dc);p("atan2",hc);p("min",pc);p("max",fc);p("mod",gc);p("step",mc);p("reflect",xc);p("distance",Tc);p("dot",yc);p("cross",Sc);p("pow",bc);p("pow2",Cc);p("pow3",vc);p("pow4",Ac);p("transformDirection",Qs);p("mix",Mc);p("clamp",tr);p("refract",Rc);p("smoothstep",Gc);p("faceForward",Uc);p("difference",Nc);p("saturate",wc);T(u);class S extends v{constructor(e=S.VIEW_MATRIX,t=null){super(),this.scope=e,this.object3d=t,this.updateType=O.OBJECT,this._uniformNode=te(null)}getNodeType(){const e=this.scope;if(e===S.WORLD_MATRIX||e===S.VIEW_MATRIX)return"mat4";if(e===S.NORMAL_MATRIX)return"mat3";if(e===S.POSITION||e===S.VIEW_POSITION||e===S.DIRECTION)return"vec3"}update(e){const t=this.object3d,s=this._uniformNode,r=this.scope;if(r===S.VIEW_MATRIX)s.value=t.modelViewMatrix;else if(r===S.NORMAL_MATRIX)s.value=t.normalMatrix;else if(r===S.WORLD_MATRIX)s.value=t.matrixWorld;else if(r===S.POSITION)s.value=s.value||new ie,s.value.setFromMatrixPosition(t.matrixWorld);else if(r===S.DIRECTION)s.value=s.value||new ie,t.getWorldDirection(s.value);else if(r===S.VIEW_POSITION){const n=e.camera;s.value=s.value||new ie,s.value.setFromMatrixPosition(t.matrixWorld),s.value.applyMatrix4(n.matrixWorldInverse)}}generate(e){const t=this.scope;return t===S.WORLD_MATRIX||t===S.VIEW_MATRIX?this._uniformNode.nodeType="mat4":t===S.NORMAL_MATRIX?this._uniformNode.nodeType="mat3":(t===S.POSITION||t===S.VIEW_POSITION||t===S.DIRECTION)&&(this._uniformNode.nodeType="vec3"),this._uniformNode.build(e)}serialize(e){super.serialize(e),e.scope=this.scope}deserialize(e){super.deserialize(e),this.scope=e.scope}}S.VIEW_MATRIX="viewMatrix";S.NORMAL_MATRIX="normalMatrix";S.WORLD_MATRIX="worldMatrix";S.POSITION="position";S.VIEW_POSITION="viewPosition";S.DIRECTION="direction";const rr=S;g(S,S.DIRECTION);g(S,S.VIEW_MATRIX);g(S,S.NORMAL_MATRIX);g(S,S.WORLD_MATRIX);g(S,S.POSITION);g(S,S.VIEW_POSITION);T(S);class k extends rr{constructor(e=k.VIEW_MATRIX){super(e)}update(e){this.object3d=e.object,super.update(e)}}N(k,k.DIRECTION);const Rt=N(k,k.VIEW_MATRIX),nr=N(k,k.NORMAL_MATRIX),mt=N(k,k.WORLD_MATRIX);N(k,k.POSITION);N(k,k.VIEW_POSITION);T(k);class U extends v{constructor(e=U.LOCAL){super("vec3"),this.scope=e}isGlobal(){return!0}getHash(){return`position-${this.scope}`}generate(e){const t=this.scope;let s=null;if(t===U.GEOMETRY)s=pe("position","vec3");else if(t===U.LOCAL)s=$(_c);else if(t===U.WORLD){const r=mt.mul(Z);s=$(r)}else if(t===U.VIEW){const r=Rt.mul(Z);s=$(r)}else if(t===U.VIEW_DIRECTION){const r=Je.negate();s=X($(r))}else if(t===U.WORLD_DIRECTION){const r=Z.transformDirection(mt);s=X($(r))}return s.build(e,this.getNodeType(e))}serialize(e){super.serialize(e),e.scope=this.scope}deserialize(e){super.deserialize(e),this.scope=e.scope}}U.GEOMETRY="geometry";U.LOCAL="local";U.WORLD="world";U.WORLD_DIRECTION="worldDirection";U.VIEW="view";U.VIEW_DIRECTION="viewDirection";const _c=N(U,U.GEOMETRY),Z=N(U,U.LOCAL),ir=N(U,U.WORLD),or=N(U,U.WORLD_DIRECTION),Je=N(U,U.VIEW),ar=N(U,U.VIEW_DIRECTION);T(U);class cr extends Te{constructor(e=or){super("vec2"),this.dirNode=e}construct(){const e=js(this.dirNode),t=e.z.atan2(e.x).mul(1/(Math.PI*2)).add(.5),s=e.y.clamp(-1,1).asin().mul(1/Math.PI).add(.5);return Ue(t,s)}}const xt=g(cr);T(cr);class W extends rr{constructor(e=W.POSITION){super(e)}getNodeType(e){return this.scope===W.PROJECTION_MATRIX?"mat4":super.getNodeType(e)}update(e){const t=e.camera,s=this._uniformNode,r=this.scope;r===W.PROJECTION_MATRIX?s.value=t.projectionMatrix:r===W.VIEW_MATRIX?s.value=t.matrixWorldInverse:(this.object3d=t,super.update(e))}generate(e){return this.scope===W.PROJECTION_MATRIX&&(this._uniformNode.nodeType="mat4"),super.generate(e)}}W.PROJECTION_MATRIX="projectionMatrix";const Pc=N(W,W.PROJECTION_MATRIX),ue=N(W,W.VIEW_MATRIX);N(W,W.NORMAL_MATRIX);N(W,W.WORLD_MATRIX);N(W,W.POSITION);T(W);class F extends v{constructor(e=F.LOCAL){super("vec3"),this.scope=e}isGlobal(){return!0}getHash(){return`normal-${this.scope}`}generate(e){const t=this.scope;let s=null;if(t===F.GEOMETRY)s=pe("normal","vec3");else if(t===F.LOCAL)s=$(ur);else if(t===F.VIEW){const r=nr.mul(fe);s=X($(r))}else if(t===F.WORLD){const r=Ne.transformDirection(ue);s=X($(r))}return s.build(e,this.getNodeType(e))}serialize(e){super.serialize(e),e.scope=this.scope}deserialize(e){super.deserialize(e),this.scope=e.scope}}F.GEOMETRY="geometry";F.LOCAL="local";F.VIEW="view";F.WORLD="world";const ur=N(F,F.GEOMETRY),fe=N(F,F.LOCAL),Ne=N(F,F.VIEW),Ec=N(F,F.WORLD),ge=Ze(Ne,"TransformedNormalView"),Qt=ge.transformDirection(ue).normalize();T(F);class lr extends v{constructor(e,t=null){super("float"),this.textureNode=e,this.roughnessNode=t}construct(){const{textureNode:e,roughnessNode:t}=this,s=Xs(e),r=t.mul(t).mul(Math.PI).div(t.add(1));return s.add(r.log2()).clamp(0,s)}}const es=g(lr);T(lr);class dr extends wt{constructor(e=0){super(null,"vec2"),this.isUVNode=!0,this.index=e}getAttributeName(){const e=this.index;return"uv"+(e>0?e+1:"")}serialize(e){super.serialize(e),e.index=this.index}deserialize(e){super.deserialize(e),this.index=e.index}}const $e=(...o)=>C(new dr(...o));T(dr);let ts;class Ut extends Ke{constructor(e,t=null,s=null){super(e),this.isTextureNode=!0,this.uvNode=t,this.levelNode=s}getUniformHash(){return this.value.uuid}getNodeType(){return this.value.isDepthTexture===!0?"float":"vec4"}getInputType(){return"texture"}getDefaultUV(){return ts||(ts=$e())}construct(e){const t=e.getNodeProperties(this);let s=this.uvNode;s===null&&e.context.getUVNode&&(s=e.context.getUVNode(this)),s||(s=this.getDefaultUV());let r=this.levelNode;r===null&&e.context.getSamplerLevelNode&&(r=e.context.getSamplerLevelNode(this)),t.uvNode=s,t.levelNode=r?e.context.getMIPLevelAlgorithmNode(this,r):null}generate(e,t){const{uvNode:s,levelNode:r}=e.getNodeProperties(this),n=this.value;if(!n||n.isTexture!==!0)throw new Error("TextureNode: Need a three.js texture.");const i=super.generate(e,"property");if(t==="sampler")return i+"_sampler";if(e.isReference(t))return i;{const a=this.getNodeType(e),c=e.getDataFromNode(this);let l=c.propertyName;if(l===void 0){const d=s.build(e,"vec2"),f=e.getVarFromNode(this,a);l=e.getPropertyName(f);let m=null;if(r&&r.isNode===!0){const y=r.build(e,"float");m=e.getTextureLevel(n,i,d,y)}else m=e.getTexture(n,i,d);e.addLineFlowCode(`${l} = ${m}`),c.snippet=m,c.propertyName=l}return e.format(l,a,t)}}serialize(e){super.serialize(e),e.value=this.value.toJSON(e.meta).uuid}deserialize(e){super.deserialize(e),this.value=e.meta.textures[e.value]}}const me=g(Ut);p("texture",me);T(Ut);class B extends v{constructor(e=B.LOCAL){super(),this.scope=e}getHash(){return`tangent-${this.scope}`}getNodeType(){return this.scope===B.GEOMETRY?"vec4":"vec3"}generate(e){const t=this.scope;let s=null;if(t===B.GEOMETRY)s=pe("tangent","vec4");else if(t===B.LOCAL)s=$(ze.xyz);else if(t===B.VIEW){const r=Rt.mul(Mt).xyz;s=X($(r))}else if(t===B.WORLD){const r=je.transformDirection(ue);s=X($(r))}return s.build(e,this.getNodeType(e))}serialize(e){super.serialize(e),e.scope=this.scope}deserialize(e){super.deserialize(e),this.scope=e.scope}}B.GEOMETRY="geometry";B.LOCAL="local";B.VIEW="view";B.WORLD="world";const ze=N(B,B.GEOMETRY),Mt=N(B,B.LOCAL),je=N(B,B.VIEW),Bc=N(B,B.WORLD),hr=Ze(je,"TransformedTangentView");X(hr.transformDirection(ue));T(B);class L extends v{constructor(e=L.LOCAL){super("vec3"),this.scope=e}getHash(){return`bitangent-${this.scope}`}generate(e){const t=this.scope;let s;t===L.GEOMETRY?s=ur.cross(ze):t===L.LOCAL?s=fe.cross(Mt):t===L.VIEW?s=Ne.cross(je):t===L.WORLD&&(s=Ec.cross(Bc));const r=s.mul(ze.w).xyz;return X($(r)).build(e,this.getNodeType(e))}serialize(e){super.serialize(e),e.scope=this.scope}deserialize(e){super.deserialize(e),this.scope=e.scope}}L.GEOMETRY="geometry";L.LOCAL="local";L.VIEW="view";L.WORLD="world";N(L,L.GEOMETRY);N(L,L.LOCAL);const Fc=N(L,L.VIEW);N(L,L.WORLD);const Lc=X(ge.cross(hr).mul(ze.w));X(Lc.transformDirection(ue));T(L);class pr extends Ke{constructor(e,t,s=0){super(e,t),this.isBufferNode=!0,this.bufferType=t,this.bufferCount=s}getInputType(){return"buffer"}}const fr=(o,e,t)=>C(new pr(o,_e(e),t));T(pr);class gr extends v{constructor(){super("vec3")}getHash(){return"reflectVector"}construct(){return ar.negate().reflect(ge).transformDirection(ue)}}const Ic=N(gr);T(gr);class mr extends Ut{constructor(e,t=null,s=null){super(e,t,s),this.isCubeTextureNode=!0}getInputType(){return"cubeTexture"}getDefaultUV(){return Ic}generate(e,t){const{uvNode:s,levelNode:r}=e.getNodeProperties(this),n=this.value;if(!n||n.isCubeTexture!==!0)throw new Error("CubeTextureNode: Need a three.js cube texture.");const i=Ke.prototype.generate.call(this,e,"cubeTexture");if(t==="sampler")return i+"_sampler";if(e.isReference(t))return i;{const a=e.getDataFromNode(this);let c=a.propertyName;if(c===void 0){const d=V(s.x.negate(),s.yz).build(e,"vec3"),f=e.getVarFromNode(this,"vec4");c=e.getPropertyName(f);let m=null;if(r&&r.isNode===!0){const y=r.build(e,"float");m=e.getTextureLevel(this,i,d,y)}else m=e.getTexture(this,i,d);e.addLineFlowCode(`${c} = ${m}`),a.snippet=m,a.propertyName=c}return e.format(c,"vec4",t)}}}const Tt=g(mr);p("cubeTexture",Tt);T(mr);class Gt extends v{constructor(e,t,s=null){super(),this.property=e,this.uniformType=t,this.object=s,this.node=null,this.updateType=O.OBJECT,this.setNodeType(t)}setNodeType(e){let t=null;e==="texture"?t=me(null):t=te(e),this.node=t}getNodeType(e){return this.node.getNodeType(e)}update(e){const t=this.object!==null?this.object:e.object,s=this.property;this.node.value=t[s]}construct(){return this.node}}const re=(o,e,t)=>C(new Gt(o,_e(e),t));T(Gt);class xr extends Gt{constructor(e,t,s=null){super(e,t,s),this.material=s}construct(e){const t=this.material!==null?this.material:e.material;return this.node.value=t[this.property],super.construct(e)}update(e){this.object=this.material!==null?this.material:e.material,super.update(e)}}const Ae=(o,e,t)=>C(new xr(o,_e(e),t));T(xr);class x extends v{constructor(e){super(),this.scope=e}getNodeType(e){const t=this.scope,s=e.context.material;if(t===x.COLOR)return s.map!==null?"vec4":"vec3";if(t===x.OPACITY||t===x.ROTATION)return"float";if(t===x.UV)return"vec2";if(t===x.EMISSIVE)return"vec3";if(t===x.ROUGHNESS||t===x.METALNESS||t===x.SPECULAR||t===x.SHININESS)return"float"}getFloat(e){return Ae(e,"float")}getColor(e){return Ae(e,"color")}getTexture(e){const t=Ae(e,"texture");return t.node.uvNode=Oc,t}construct(e){const t=e.context.material,s=this.scope;let r=null;if(s===x.ALPHA_TEST)r=this.getFloat("alphaTest");else if(s===x.COLOR){const n=this.getColor("color");t.map&&t.map.isTexture===!0?r=n.mul(this.getTexture("map")):r=n}else if(s===x.OPACITY){const n=this.getFloat("opacity");t.alphaMap&&t.alphaMap.isTexture===!0?r=n.mul(this.getTexture("alphaMap")):r=n}else if(s===x.SHININESS)r=this.getFloat("shininess");else if(s===x.SPECULAR_COLOR)r=this.getColor("specular");else if(s===x.REFLECTIVITY){const n=this.getFloat("reflectivity");t.specularMap&&t.specularMap.isTexture===!0?r=n.mul(this.getTexture("specularMap").r):r=n}else if(s===x.ROUGHNESS){const n=this.getFloat("roughness");t.roughnessMap&&t.roughnessMap.isTexture===!0?r=n.mul(this.getTexture("roughnessMap").g):r=n}else if(s===x.METALNESS){const n=this.getFloat("metalness");t.metalnessMap&&t.metalnessMap.isTexture===!0?r=n.mul(this.getTexture("metalnessMap").b):r=n}else if(s===x.EMISSIVE){const n=this.getColor("emissive");t.emissiveMap&&t.emissiveMap.isTexture===!0?r=n.mul(this.getTexture("emissiveMap")):r=n}else if(s===x.ROTATION)r=this.getFloat("rotation");else if(s===x.UV){let n=t.map||t.specularMap||t.displacementMap||t.normalMap||t.bumpMap||t.roughnessMap||t.metalnessMap||t.alphaMap||t.emissiveMap||t.clearcoatMap||t.clearcoatNormalMap||t.clearcoatRoughnessMap||t.iridescenceMap||t.iridescenceThicknessMap||t.specularIntensityMap||t.specularColorMap||t.transmissionMap||t.thicknessMap||t.sheenColorMap||t.sheenRoughnessMap;n?(n.isWebGLRenderTarget&&(n=n.texture),n.matrixAutoUpdate===!0&&n.updateMatrix(),r=te(n.matrix).mul(V($e(),1))):r=$e()}else{const n=this.getNodeType(e);r=Ae(s,n)}return r}}x.ALPHA_TEST="alphaTest";x.COLOR="color";x.OPACITY="opacity";x.SHININESS="shininess";x.SPECULAR_COLOR="specularColor";x.REFLECTIVITY="reflectivity";x.ROUGHNESS="roughness";x.METALNESS="metalness";x.EMISSIVE="emissive";x.ROTATION="rotation";x.UV="uv";const Oc=N(x,x.UV),Wc=N(x,x.ALPHA_TEST),Dc=N(x,x.COLOR);N(x,x.SHININESS);const Vc=N(x,x.EMISSIVE),kc=N(x,x.OPACITY);N(x,x.SPECULAR_COLOR);N(x,x.REFLECTIVITY);N(x,x.ROUGHNESS);N(x,x.METALNESS);N(x,x.ROTATION);T(x);class Tr extends v{constructor(){super("bool"),this.isFrontFacingNode=!0}generate(e){return e.getFrontFacing()}}const $c=N(Tr),zc=ee($c).mul(2).sub(1);T(Tr);const qc=new J(o=>{const{eye_pos:e,surf_norm:t,mapN:s,uv:r}=o,n=e.dFdx(),i=e.dFdy(),a=r.dFdx(),c=r.dFdy(),l=t,d=i.cross(l),f=l.cross(n),m=d.mul(a.x).add(f.mul(c.x)),y=d.mul(a.y).add(f.mul(c.y)),A=m.dot(m).max(y.dot(y)),b=zc.mul(A.inverseSqrt());return Ve(m.mul(s.x,b),y.mul(s.y,b),l.mul(s.z)).normalize()});class Nr extends Te{constructor(e,t=null){super("vec3"),this.node=e,this.scaleNode=t,this.normalMapType=Vt}construct(e){const{normalMapType:t,scaleNode:s}=this;let r=this.node.mul(2).sub(1);s!==null&&(r=V(r.xy.mul(s),r.z));let n=null;return t===zn?n=nr.mul(r).normalize():t===Vt&&(e.hasGeometryAttribute("tangent")===!0?n=Xc.mul(r).normalize():n=qc.call({eye_pos:Je,surf_norm:Ne,mapN:r,uv:$e()})),n}}const Hc=g(Nr),Xc=Me(je,Fc,Ne);T(Nr);class ae extends x{constructor(e){super(e)}getNodeType(e){const t=this.scope;let s=null;return t===ae.NORMAL&&(s="vec3"),s||super.getNodeType(e)}construct(e){const t=e.material,s=this.scope;let r=null;return s===ae.NORMAL&&(r=t.normalMap?Hc(this.getTexture("normalMap"),Ae("normalScale","vec2")):Ne),r||super.construct(e)}}ae.NORMAL="normal";const Yc=N(ae,ae.NORMAL);T(ae);class yr extends v{constructor(e){super("void"),this.instanceMesh=e;const t=fr(e.instanceMatrix.array,"mat4",e.count);this.instanceMatrixNode=Zs(t.element(aa))}generate(e){const{instanceMatrixNode:t}=this,s=t.mul(Z).xyz,r=Me(t[0].xyz,t[1].xyz,t[2].xyz),n=fe.div(V(r[0].dot(r[0]),r[1].dot(r[1]),r[2].dot(r[2]))),i=r.mul(n).xyz;Z.assign(s).build(e),fe.assign(i).build(e)}}const Kc=g(yr);T(yr);class Sr extends v{constructor(e=Z){super("vec4"),this.position=e}generate(e){const t=this.position;return Pc.mul(Rt).mul(t).build(e)}}const Zc=g(Sr);T(Sr);const Jc=new J((o,{},e)=>{const{index:t,weight:s,bindMatrix:r,bindMatrixInverse:n,boneMatrices:i}=o,a=i.element(t.x),c=i.element(t.y),l=i.element(t.z),d=i.element(t.w),f=r.mul(Z),m=Ve(a.mul(f).mul(s.x),c.mul(f).mul(s.y),l.mul(f).mul(s.z),d.mul(f).mul(s.w)),y=n.mul(m).xyz;let A=Ve(s.x.mul(a),s.y.mul(c),s.z.mul(l),s.w.mul(d));A=n.mul(A).mul(r);const b=A.transformDirection(fe).xyz;Z.assign(y).build(e),fe.assign(b).build(e),e.hasGeometryAttribute("tangent")&&Mt.assign(b).build(e)});class br extends v{constructor(e){super("void"),this.skinnedMesh=e,this.updateType=O.OBJECT,this.skinIndexNode=pe("skinIndex","uvec4"),this.skinWeightNode=pe("skinWeight","vec4"),this.bindMatrixNode=te(e.bindMatrix,"mat4"),this.bindMatrixInverseNode=te(e.bindMatrixInverse,"mat4"),this.boneMatricesNode=fr(e.skeleton.boneMatrices,"mat4",e.skeleton.bones.length)}generate(e){Jc.call({index:this.skinIndexNode,weight:this.skinWeightNode,bindMatrix:this.bindMatrixNode,bindMatrixInverse:this.bindMatrixInverseNode,boneMatrices:this.boneMatricesNode},{},e)}update(){this.skinnedMesh.skeleton.update()}}const jc=g(br);T(br);const Qc=new J(({color:o,exposure:e})=>o.mul(e)),eu=new J(({color:o,exposure:e})=>(o=o.mul(e),o.div(o.add(1)).clamp())),tu=new J(({color:o,exposure:e})=>{o=o.mul(e),o=o.sub(.004).max(0);const t=o.mul(o.mul(6.2).add(.5)),s=o.mul(o.mul(6.2).add(1.7)).add(.06);return t.div(s).pow(2.2)}),su=new J(({color:o})=>{const e=o.mul(o.add(.0245786)).sub(90537e-9),t=o.mul(o.add(.432951).mul(.983729)).add(.238081);return e.div(t)}),ru=new J(({color:o,exposure:e})=>{const t=Me(V(.59719,.076,.0284),V(.35458,.90834,.13383),V(.04823,.01566,.83777)),s=Me(V(1.60475,-.10208,-.00327),V(-.53108,1.10813,-.07276),V(-.07367,-.00605,1.07602));return o=o.mul(e).div(.6),o=t.mul(o),o=su.call({color:o}),o=s.mul(o),o.clamp()}),nu={[qn]:Qc,[Hn]:eu,[Xn]:tu,[Yn]:ru};class Cr extends Te{constructor(e=Ie,t=ee(1),s=null){super("vec3"),this.toneMapping=e,this.exposureNode=t,this.colorNode=s}construct(e){const t=this.colorNode||e.context.color,s=this.toneMapping;if(s===Ie)return t;const r={exposure:this.exposureNode,color:t},n=nu[s];let i=null;return n?i=n.call(r):(console.error("ToneMappingNode: Unsupported Tone Mapping configuration.",s),i=t),i}}const iu=(o,e,t)=>C(new Cr(o,C(e),C(t)));T(Cr);let at;class R extends v{constructor(e){super(),this.scope=e,this.isViewportNode=!0}getNodeType(){return this.scope===R.COORDINATE?"vec4":"vec2"}getUpdateType(){let e=O.NONE;return this.scope===R.RESOLUTION&&(e=O.FRAME),this.updateType=e,e}update({renderer:e}){e.getDrawingBufferSize(at)}construct(e){const t=this.scope;if(t===R.COORDINATE)return;let s=null;if(t===R.RESOLUTION)s=te(at||(at=new qe));else{const r=Ue(new R(R.COORDINATE)),n=new R(R.RESOLUTION);s=r.div(n);let i=s.x,a=s.y;(/top/i.test(t)&&e.isFlipY()||/bottom/i.test(t)&&e.isFlipY()===!1)&&(a=a.oneMinus()),/right/i.test(t)&&(i=i.oneMinus()),s=Ue(i,a)}return s}generate(e){return this.scope===R.COORDINATE?e.getFragCoord():super.generate(e)}}R.COORDINATE="coordinate";R.RESOLUTION="resolution";R.TOP_LEFT="topLeft";R.BOTTOM_LEFT="bottomLeft";R.TOP_RIGHT="topRight";R.BOTTOM_RIGHT="bottomRight";N(R,R.COORDINATE);N(R,R.RESOLUTION);N(R,R.TOP_LEFT);const ou=N(R,R.BOTTOM_LEFT);N(R,R.TOP_RIGHT);N(R,R.BOTTOM_RIGHT);T(R);class _t extends v{constructor(e="",t=[],s=""){super("code"),this.isCodeNode=!0,this.code=e,this.language=s,this._includes=t}setIncludes(e){return this._includes=e,this}getIncludes(){return this._includes}generate(e){const t=this.getIncludes(e);for(const r of t)r.build(e);const s=e.getCodeFromNode(this,this.getNodeType(e));return s.code=this.code,s.code}serialize(e){super.serialize(e),e.code=this.code,e.language=this.language}deserialize(e){super.deserialize(e),this.code=e.code,this.language=e.language}}const ct=_t;g(_t);T(_t);class Pt extends v{constructor(e,t){super("float"),this.isFogNode=!0,this.colorNode=e,this.factorNode=t}mixAssign(e){return this.mix(e,this.colorNode)}construct(){return this.factorNode}}const vr=Pt,au=g(Pt);p("fog",au);T(Pt);class Ar extends vr{constructor(e,t,s){super(e),this.isFogRangeNode=!0,this.nearNode=t,this.farNode=s}construct(){return sr(this.nearNode,this.farNode,Je.z.negate())}}const wr=g(Ar);p("rangeFog",wr);T(Ar);class Rr extends vr{constructor(e,t){super(e),this.isFogExp2Node=!0,this.densityNode=t}construct(){const e=Je.z.negate(),t=this.densityNode;return t.mul(t,e,e).negate().exp().oneMinus()}}const Ur=g(Rr);p("densityFog",Ur);T(Rr);class Mr extends v{constructor(){super("vec3")}generate(){console.warn("Abstract function.")}}const Et=Mr;T(Mr);const ss=new WeakMap,cu=o=>o.sort((e,t)=>e.id-t.id);class Gr extends v{constructor(e=[]){super("vec3"),this.lightNodes=e,this._hash=null}get hasLight(){return this.lightNodes.length>0}construct(e){const t=this.lightNodes;for(const s of t)s.build(e)}getHash(e){if(this._hash===null){let t="";const s=this.lightNodes;for(const r of s)t+=r.getHash(e)+" ";this._hash=t}return this._hash}getLightNodeByHash(e){const t=this.lightNodes;for(const s of t)if(s.light.uuid===e)return s;return null}fromLights(e=[]){const t=[];e=cu(e);for(const s of e){let r=this.getLightNodeByHash(s.uuid);if(r===null){const n=s.constructor,i=ss.has(n)?ss.get(n):gu;r=C(new i(s))}t.push(r)}return this.lightNodes=t,this._hash=null,this}}const uu=o=>C(new Gr().fromLights(o)),lu=g(Gr);class _r extends Et{constructor(e=null){super(),this.aoNode=e}construct(e){const s=this.aoNode.sub(1).mul(1).add(1);e.context.ambientOcclusion.mulAssign(s)}}const du=_r;T(_r);class Pr extends Et{constructor(e=null){super(),this.envNode=e}construct(e){const t=this.envNode,s=e.getNodeProperties(this);let r,n,i;const a=oe(t,{getUVNode:d=>{let f=null;return r===void 0&&(r=ar.negate().reflect(ge),r=ot.mul(ot).mix(r,ge).normalize(),r=r.transformDirection(ue)),d.isCubeTextureNode?f=r:d.isTextureNode&&(n===void 0&&(n=xt(r)),f=n),f},getSamplerLevelNode:()=>ot,getMIPLevelAlgorithmNode:(d,f)=>es(d,f)}),c=oe(t,{getUVNode:d=>{let f=null;return d.isCubeTextureNode?f=Qt:d.isTextureNode&&(i===void 0&&(i=xt(Qt),i=Ue(i.x,i.y.oneMinus())),f=i),f},getSamplerLevelNode:()=>ee(1),getMIPLevelAlgorithmNode:(d,f)=>es(d,f)}),l=Ls(a);e.context.radiance.addAssign(l),e.context.iblIrradiance.addAssign(c.mul(Math.PI)),s.radianceContext=l,s.irradianceContext=c}}const hu=Pr;T(Pr);const Nt=new Map;class Er extends Kn{constructor(){super(),this.isNodeMaterial=!0,this.type=this.constructor.name,this.lights=!0,this.normals=!0,this.lightsNode=null,this.envNode=null,this.colorNode=null,this.normalNode=null,this.opacityNode=null,this.backdropNode=null,this.backdropAlphaNode=null,this.alphaTestNode=null,this.positionNode=null}customProgramCacheKey(){return St(this)}build(e){this.construct(e)}construct(e){e.addStack(),e.stack.outputNode=this.constructPosition(e),e.addFlow("vertex",e.removeStack()),e.addStack(),this.normals===!0&&this.constructNormal(e),this.constructDiffuseColor(e),this.constructVariants(e);const t=this.constructLighting(e);e.stack.outputNode=this.constructOutput(e,t,de.a),e.addFlow("fragment",e.removeStack())}constructPosition(e){const t=e.object;let s=Z;return this.positionNode!==null&&(s=s.bypass(Z.assign(this.positionNode))),t.instanceMatrix&&t.instanceMatrix.isInstancedBufferAttribute===!0&&e.isAvailable("instance")===!0&&(s=s.bypass(Kc(t))),t.isSkinnedMesh===!0&&(s=s.bypass(jc(t))),e.context.vertex=s,Zc()}constructDiffuseColor({stack:e,geometry:t}){let s=this.colorNode?ne(this.colorNode):Dc;this.vertexColors===!0&&t.hasAttribute("color")&&(s=ne(s.xyz.mul(pe("color")),s.a)),e.assign(de,s);const r=this.opacityNode?ee(this.opacityNode):kc;if(e.assign(de.a,de.a.mul(r)),this.alphaTestNode||this.alphaTest>0){const n=this.alphaTestNode?ee(this.alphaTestNode):Wc;e.add(de.a.lessThanEqual(n).discard())}}constructVariants(){}constructNormal({stack:e}){const t=this.normalNode?V(this.normalNode):Yc;return e.assign(ge,t),t}constructLights(e){const t=this.envNode||e.environmentNode,s=[];t&&s.push(new hu(t)),e.material.aoMap&&s.push(new du(me(e.material.aoMap)));let r=this.lightsNode||e.lightsNode;return s.length>0&&(r=lu([...r.lightNodes,...s])),r}constructLightingModel(){}constructLighting(e){const{material:t}=e,{backdropNode:s,backdropAlphaNode:r,emissiveNode:n}=this,a=this.lights===!0||this.lightsNode!==null?this.constructLights(e):null,c=a?this.constructLightingModel(e):null;let l=de.rgb;return a&&a.hasLight!==!1?l=a.lightingContext(c,s,r):s!==null&&(l=V(r!==null?er(l,s,r):s)),(n&&n.isNode===!0||t.emissive&&t.emissive.isColor===!0)&&(l=l.add(n?V(n):Vc)),l}constructOutput(e,t,s){const r=e.renderer,n=e.toneMappingNode;n&&(t=n.context({color:t}));let i=ne(t,s);i=i.colorSpace(r.outputColorSpace);const a=e.fogNode;return a&&(i=ne(a.mixAssign(i.rgb),i.a)),i}setDefaultValues(e){for(const s in e){const r=e[s];this[s]===void 0&&(this[s]=r,r&&r.clone&&(this[s]=r.clone()))}Object.assign(this.defines,e.defines);const t=Object.getOwnPropertyDescriptors(e.constructor.prototype);for(const s in t)Object.getOwnPropertyDescriptor(this.constructor.prototype,s)===void 0&&t[s].get!==void 0&&Object.defineProperty(this.constructor.prototype,s,t[s])}toJSON(e){const t=e===void 0||typeof e=="string";t&&(e={textures:{},images:{},nodes:{}});const s=Zn.prototype.toJSON.call(this,e),r=We(this);s.inputNodes={};for(const{property:i,childNode:a}of r)s.inputNodes[i]=a.toJSON(e).uuid;function n(i){const a=[];for(const c in i){const l=i[c];delete l.metadata,a.push(l)}return a}if(t){const i=n(e.textures),a=n(e.images),c=n(e.nodes);i.length>0&&(s.textures=i),a.length>0&&(s.images=a),c.length>0&&(s.nodes=c)}return s}static fromMaterial(e){if(e.isNodeMaterial===!0)return e;const t=e.type.replace("Material","NodeMaterial"),s=pu(t);if(s===void 0)throw new Error(`NodeMaterial: Material "${e.type}" is not compatible.`);for(const r in e)s[r]=e[r];return s}}const Br=Er;function Fr(o){if(typeof o!="function"||!o.name)throw new Error(`Node material ${o.name} is not a class`);if(Nt.has(o.name))throw new Error(`Redefinition of node material ${o.name}`);Nt.set(o.name,o)}function pu(o){const e=Nt.get(o);if(e!==void 0)return new e}Fr(Er);const fu=new Jn;class Lr extends Br{constructor(e){super(),this.isMeshBasicNodeMaterial=!0,this.lights=!1,this.setDefaultValues(fu),this.setValues(e)}copy(e){return this.colorNode=e.colorNode,this.opacityNode=e.opacityNode,this.alphaTestNode=e.alphaTestNode,this.lightNode=e.lightNode,this.positionNode=e.positionNode,super.copy(e)}}const Ir=Lr;Fr(Lr);let ut=null;class Or extends Et{constructor(e=null){super(),this.updateType=O.FRAME,this.light=e,this.rtt=null,this.shadowNode=null,this.color=new xe,this.colorNode=te(this.color)}getHash(){return this.light.uuid}constructShadow(e){let t=this.shadowNode;if(t===null){ut===null&&(ut=new Ir);const s=this.light.shadow,r=e.getRenderTarget(s.mapSize.width,s.mapSize.height),n=new hs;n.minFilter=K,n.magFilter=K,r.depthTexture=n,s.camera.updateProjectionMatrix();const i=re("bias","float",s);let a=te(s.matrix).mul(ir);a=a.xyz.div(a.w),a=V(a.x,a.y.oneMinus(),a.z);let c=me(n,a.xy);c=c.mul(.5).add(.5).add(i),t=ke(a.z.lessThan(c).or(a.y.lessThan(1e-6)),1,0),this.rtt=r,this.colorNode=this.colorNode.mul(t),this.shadowNode=t,this.updateBeforeType=O.RENDER}}construct(e){this.light.castShadow&&this.constructShadow(e)}updateShadow(e){const{rtt:t,light:s}=this,{renderer:r,scene:n}=e;n.overrideMaterial=ut,t.setSize(s.shadow.mapSize.width,s.shadow.mapSize.height),s.shadow.updateMatrices(s),r.setRenderTarget(t),r.render(n,s.shadow.camera),r.setRenderTarget(null),n.overrideMaterial=null}updateBefore(e){const{light:t}=this;t.castShadow&&this.updateShadow(e)}update(e){const{light:t}=this;this.color.copy(t.color).multiplyScalar(t.intensity)}}const gu=Or;T(Or);class mu{parseFunction(){console.warn("Abstract function.")}}const xu=mu;class Wr{constructor(e,t,s="",r=""){this.type=e,this.inputs=t,this.name=s,this.presicion=r}getCode(){console.warn("Abstract function.")}}Wr.isNodeFunction=!0;const Tu=Wr,Nu=/^[fn]*\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)\s*[\-\>]*\s*([a-z_0-9]+)?/i,yu=/[a-z_0-9]+/ig,Su={f32:"float"},bu=o=>{o=o.trim();const e=o.match(Nu);if(e!==null&&e.length===4){const t=e[2],s=[];let r=null;for(;(r=yu.exec(t))!==null;)s.push(r);const n=[];let i=0;for(;i<s.length;){const d=s[i++][0];let f=s[i++][0];f=Su[f]||f,i<s.length&&/^[fui]\d{2}$/.test(s[i][0])===!0&&i++,n.push(new Va(f,d))}const a=o.substring(e[0].length),c=e[1]!==void 0?e[1]:"";return{type:e[3]||"void",inputs:n,name:c,inputsCode:t,blockCode:a}}else throw new Error("FunctionNode: Function is not a WGSL code.")};class Cu extends Tu{constructor(e){const{type:t,inputs:s,name:r,inputsCode:n,blockCode:i}=bu(e);super(t,s,r),this.inputsCode=n,this.blockCode=i}getCode(e=this.name){const t=this.type!=="void"?"-> "+this.type:"";return`fn ${e} ( ${this.inputsCode.trim()} ) ${t}`+this.blockCode}}const vu=Cu;class Au extends xu{parseFunction(e){return new vu(e)}}const wu=Au;function Ru(o,e){return o.groupOrder!==e.groupOrder?o.groupOrder-e.groupOrder:o.renderOrder!==e.renderOrder?o.renderOrder-e.renderOrder:o.material.id!==e.material.id?o.material.id-e.material.id:o.z!==e.z?o.z-e.z:o.id-e.id}function Uu(o,e){return o.groupOrder!==e.groupOrder?o.groupOrder-e.groupOrder:o.renderOrder!==e.renderOrder?o.renderOrder-e.renderOrder:o.z!==e.z?e.z-o.z:o.id-e.id}class Mu{constructor(){this.renderItems=[],this.renderItemsIndex=0,this.opaque=[],this.transparent=[],this.lightsNode=uu([]),this.lightsArray=[]}init(){return this.renderItemsIndex=0,this.opaque.length=0,this.transparent.length=0,this.lightsArray.length=0,this}getNextRenderItem(e,t,s,r,n,i){let a=this.renderItems[this.renderItemsIndex];return a===void 0?(a={id:e.id,object:e,geometry:t,material:s,groupOrder:r,renderOrder:e.renderOrder,z:n,group:i},this.renderItems[this.renderItemsIndex]=a):(a.id=e.id,a.object=e,a.geometry=t,a.material=s,a.groupOrder=r,a.renderOrder=e.renderOrder,a.z=n,a.group=i),this.renderItemsIndex++,a}push(e,t,s,r,n,i){const a=this.getNextRenderItem(e,t,s,r,n,i);(s.transparent===!0?this.transparent:this.opaque).push(a)}unshift(e,t,s,r,n,i){const a=this.getNextRenderItem(e,t,s,r,n,i);(s.transparent===!0?this.transparent:this.opaque).unshift(a)}pushLight(e){this.lightsArray.push(e)}getLightsNode(){return this.lightsNode.fromLights(this.lightsArray)}sort(e,t){this.opaque.length>1&&this.opaque.sort(e||Ru),this.transparent.length>1&&this.transparent.sort(t||Uu)}finish(){this.lightsNode.fromLights(this.lightsArray);for(let e=this.renderItemsIndex,t=this.renderItems.length;e<t;e++){const s=this.renderItems[e];if(s.id===null)break;s.id=null,s.object=null,s.geometry=null,s.material=null,s.program=null,s.group=null}}}class Gu{constructor(){this.lists=new WeakMap,this.lists=new Re}get(e,t){const s=this.lists,r=[e,t];let n=s.get(r);return n===void 0&&(n=new Mu,s.set(r,n)),n}dispose(){this.lists=new WeakMap}}const _u=Gu;class Pu{constructor(){this.depth=!0,this.stencil=!0,this.descriptorGPU=null,this.encoderGPU=null,this.currentPassGPU=null}}class Eu{constructor(){this.renderStates=new Re}get(e,t){const s=[e,t];let r=this.renderStates.get(s);return r===void 0&&(r=new Pu,this.renderStates.set(s,r)),r}dispose(){this.renderStates=new Re}}const Bu=Eu;class Fu{constructor(e){this.device=e;const t=`
struct VarysStruct {
	@builtin( position ) Position: vec4<f32>,
	@location( 0 ) vTex : vec2<f32>
};

@vertex
fn main( @builtin( vertex_index ) vertexIndex : u32 ) -> VarysStruct {

	var Varys : VarysStruct;

	var pos = array< vec2<f32>, 4 >(
		vec2<f32>( -1.0,  1.0 ),
		vec2<f32>(  1.0,  1.0 ),
		vec2<f32>( -1.0, -1.0 ),
		vec2<f32>(  1.0, -1.0 )
	);

	var tex = array< vec2<f32>, 4 >(
		vec2<f32>( 0.0, 0.0 ),
		vec2<f32>( 1.0, 0.0 ),
		vec2<f32>( 0.0, 1.0 ),
		vec2<f32>( 1.0, 1.0 )
	);

	Varys.vTex = tex[ vertexIndex ];
	Varys.Position = vec4<f32>( pos[ vertexIndex ], 0.0, 1.0 );

	return Varys;

}
`,s=`
@group( 0 ) @binding( 0 )
var imgSampler : sampler;

@group( 0 ) @binding( 1 )
var img : texture_2d<f32>;

@fragment
fn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {

	return textureSample( img, imgSampler, vTex );

}
`;this.sampler=e.createSampler({minFilter:dt.Linear}),this.pipelines={},this.mipmapVertexShaderModule=e.createShaderModule({label:"mipmapVertex",code:t}),this.mipmapFragmentShaderModule=e.createShaderModule({label:"mipmapFragment",code:s})}getMipmapPipeline(e){let t=this.pipelines[e];return t===void 0&&(t=this.device.createRenderPipeline({vertex:{module:this.mipmapVertexShaderModule,entryPoint:"main"},fragment:{module:this.mipmapFragmentShaderModule,entryPoint:"main",targets:[{format:e}]},primitive:{topology:ve.TriangleStrip,stripIndexFormat:we.Uint32},layout:"auto"}),this.pipelines[e]=t),t}generateMipmaps(e,t,s=0){const r=this.getMipmapPipeline(t.format),n=this.device.createCommandEncoder({}),i=r.getBindGroupLayout(0);let a=e.createView({baseMipLevel:0,mipLevelCount:1,dimension:Oe.TwoD,baseArrayLayer:s});for(let c=1;c<t.mipLevelCount;c++){const l=e.createView({baseMipLevel:c,mipLevelCount:1,dimension:Oe.TwoD,baseArrayLayer:s}),d=n.beginRenderPass({colorAttachments:[{view:l,loadOp:q.Clear,storeOp:Y.Store,clearValue:[0,0,0,0]}]}),f=this.device.createBindGroup({layout:i,entries:[{binding:0,resource:this.sampler},{binding:1,resource:a}]});d.setPipeline(r),d.setBindGroup(0,f),d.draw(4,1,0,0),d.end(),a=l}this.device.queue.submit([n.finish()])}}const Lu=Fu;class Iu{constructor(e,t,s){this.device=e,this.properties=t,this.info=s,this.defaultTexture=null,this.depthDefaultTexture=null,this.defaultVideoTexture=null,this.defaultCubeTexture=null,this.defaultSampler=null,this.samplerCache=new Map,this.utils=null}getDefaultSampler(){return this.defaultSampler===null&&(this.defaultSampler=this.device.createSampler({})),this.defaultSampler}getDefaultDepthTexture(){if(this.depthDefaultTexture===null){const e=new hs;e.image.width=1,e.image.height=1,this._uploadTexture(e),this.depthDefaultTexture=this.getTextureGPU(e)}return this.depthDefaultTexture}getDefaultTexture(){if(this.defaultTexture===null){const e=new jn;e.minFilter=K,e.magFilter=K,this._uploadTexture(e),this.defaultTexture=this.getTextureGPU(e)}return this.defaultTexture}getDefaultVideoTexture(){if(this.defaultVideoTexture===null){const e=document.getElementById("video"),t=new Qn(e);t.minFilter=K,t.magFilter=K,this._uploadVideoTexture(t),this.defaultVideoTexture=this.getTextureGPU(t)}return this.defaultVideoTexture}getDefaultCubeTexture(){if(this.defaultCubeTexture===null){const e=new ei;e.minFilter=K,e.magFilter=K,this._uploadTexture(e),this.defaultCubeTexture=this.getTextureGPU(e)}return this.defaultCubeTexture}getTextureGPU(e){return this.properties.get(e).textureGPU}getSampler(e){return this.properties.get(e).samplerGPU}updateTexture(e){let t=!1;const s=this.properties.get(e);if(e.version>0&&s.version!==e.version){const r=e.image;if(r===void 0)console.warn("THREE.WebGPURenderer: Texture marked for update but image is undefined.");else if(r.complete===!1)console.warn("THREE.WebGPURenderer: Texture marked for update but image is incomplete.");else{if(s.initialized===void 0){s.initialized=!0;const n=Wu.bind(this);s.disposeCallback=n,e.addEventListener("dispose",n),this.info.memory.textures++}e.isVideoTexture?t=this._uploadVideoTexture(e):t=this._uploadTexture(e)}}return s.initializedRTT===!1&&(s.initializedRTT=!0,t=!0),t}updateSampler(e){const t=[];t.push(e.wrapS),t.push(e.wrapT),t.push(e.wrapR),t.push(e.magFilter),t.push(e.minFilter),t.push(e.anisotropy);const s=t.join();let r=this.samplerCache.get(s);r===void 0&&(r=this.device.createSampler({addressModeU:this._convertAddressMode(e.wrapS),addressModeV:this._convertAddressMode(e.wrapT),addressModeW:this._convertAddressMode(e.wrapR),magFilter:this._convertFilterMode(e.magFilter),minFilter:this._convertFilterMode(e.minFilter),mipmapFilter:this._convertFilterMode(e.minFilter),maxAnisotropy:e.anisotropy}),this.samplerCache.set(s,r));const n=this.properties.get(e);n.samplerGPU=r}initRenderTarget(e){const t=this.properties,s=t.get(e);if(s.initialized===void 0){const r=this.device,n=e.width,i=e.height,a=e.texture,c=a.internalFormat||this._getFormat(a),l=a.name?"_"+a.name:"",d=this._needsMipmaps(a),f=this._getMipLevelCount(a,n,i,d),m=r.createTexture({label:"renderTarget"+l,size:{width:n,height:i,depthOrArrayLayers:1},mipLevelCount:f,format:c,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST});this.info.memory.textures++,s.colorTextureGPU=m,s.colorTextureFormat=c;const y=t.get(a);if(y.textureGPU=m,y.initializedRTT=!1,e.depthBuffer===!0){const b=e.depthTexture!==null?this._getFormat(e.depthTexture):h.Depth24PlusStencil8,M=r.createTexture({label:"renderTarget"+l+"_depthBuffer",size:{width:n,height:i,depthOrArrayLayers:1},format:b,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST});if(this.info.memory.textures++,s.depthTextureGPU=M,s.depthTextureFormat=b,e.depthTexture!==null){const G=t.get(e.depthTexture);G.textureGPU=M,G.initializedRTT=!1}}const A=Ou.bind(this);s.disposeCallback=A,e.addEventListener("dispose",A),s.initialized=!0}}dispose(){this.samplerCache.clear()}_convertAddressMode(e){let t=rt.ClampToEdge;return e===Ui?t=rt.Repeat:e===Mi&&(t=rt.MirrorRepeat),t}_convertFilterMode(e){let t=dt.Linear;return(e===K||e===Gi||e===_i)&&(t=dt.Nearest),t}_uploadVideoTexture(e){const t=this.device,s=this.properties.get(e),r=t.importExternalTexture({source:e.source.data});return s.textureGPU=r,!0}_uploadTexture(e){let t=!1;const s=this.device,r=e.image,n=this.properties.get(e),{width:i,height:a,depth:c}=this._getSize(e),l=this._needsMipmaps(e),d=this._getDimension(e),f=this._getMipLevelCount(e,i,a,l),m=e.internalFormat||this._getFormat(e);let y=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST;l&&(y|=GPUTextureUsage.RENDER_ATTACHMENT);const A={label:e.name,size:{width:i,height:a,depthOrArrayLayers:c},mipLevelCount:f,sampleCount:1,dimension:d,format:m,usage:y};let b=n.textureGPU;return b===void 0&&(b=s.createTexture(A),t=!0),e.isDataTexture||e.isDataArrayTexture||e.isData3DTexture?this._copyBufferToTexture(r,b,A,l):e.isCompressedTexture?this._copyCompressedBufferToTexture(e.mipmaps,b,A):e.isCubeTexture?r.length===6&&this._copyCubeMapToTexture(r,e,b,A,l):e.isRenderTargetTexture?l===!0&&this._generateMipmaps(b,A):e.isDepthTexture!==!0&&r!==null&&this._copyImageToTexture(r,e,b,A,l),n.textureGPU=b,n.version=e.version,t}_copyBufferToTexture(e,t,s,r,n=0){const i=e.data,a=this._getBytesPerTexel(s.format),c=e.width*a;this.device.queue.writeTexture({texture:t,mipLevel:0,origin:{x:0,y:0,z:n}},i,{offset:0,bytesPerRow:c},{width:e.width,height:e.height,depthOrArrayLayers:e.depth!==void 0?e.depth:1}),r===!0&&this._generateMipmaps(t,s,n)}_copyCubeMapToTexture(e,t,s,r,n){for(let i=0;i<6;i++){const a=e[i];a.isDataTexture?this._copyBufferToTexture(a.image,s,r,n,i):this._copyImageToTexture(a,t,s,r,n,i)}}_copyExternalImageToTexture(e,t,s,r,n=0){this.device.queue.copyExternalImageToTexture({source:e},{texture:t,mipLevel:0,origin:{x:0,y:0,z:n}},{width:e.width,height:e.height,depthOrArrayLayers:1}),r&&this._generateMipmaps(t,s,n)}_copyCompressedBufferToTexture(e,t,s){const r=this._getBlockData(s.format);for(let n=0;n<e.length;n++){const i=e[n],a=i.width,c=i.height,l=Math.ceil(a/r.width)*r.byteLength;this.device.queue.writeTexture({texture:t,mipLevel:n},i.data,{offset:0,bytesPerRow:l},{width:Math.ceil(a/r.width)*r.width,height:Math.ceil(c/r.width)*r.width,depthOrArrayLayers:1})}}_generateMipmaps(e,t,s){this.utils===null&&(this.utils=new Lu(this.device)),this.utils.generateMipmaps(e,t,s)}_getBlockData(e){if(e===h.BC1RGBAUnorm||e===h.BC1RGBAUnormSRGB)return{byteLength:8,width:4,height:4};if(e===h.BC2RGBAUnorm||e===h.BC2RGBAUnormSRGB)return{byteLength:16,width:4,height:4};if(e===h.BC3RGBAUnorm||e===h.BC3RGBAUnormSRGB)return{byteLength:16,width:4,height:4};if(e===h.BC4RUnorm||e===h.BC4RSNorm)return{byteLength:8,width:4,height:4};if(e===h.BC5RGUnorm||e===h.BC5RGSnorm)return{byteLength:16,width:4,height:4};if(e===h.BC6HRGBUFloat||e===h.BC6HRGBFloat)return{byteLength:16,width:4,height:4};if(e===h.BC7RGBAUnorm||e===h.BC7RGBAUnormSRGB)return{byteLength:16,width:4,height:4};if(e===h.ETC2RGB8Unorm||e===h.ETC2RGB8UnormSRGB)return{byteLength:8,width:4,height:4};if(e===h.ETC2RGB8A1Unorm||e===h.ETC2RGB8A1UnormSRGB)return{byteLength:8,width:4,height:4};if(e===h.ETC2RGBA8Unorm||e===h.ETC2RGBA8UnormSRGB)return{byteLength:16,width:4,height:4};if(e===h.EACR11Unorm)return{byteLength:8,width:4,height:4};if(e===h.EACR11Snorm)return{byteLength:8,width:4,height:4};if(e===h.EACRG11Unorm)return{byteLength:16,width:4,height:4};if(e===h.EACRG11Snorm)return{byteLength:16,width:4,height:4};if(e===h.ASTC4x4Unorm||e===h.ASTC4x4UnormSRGB)return{byteLength:16,width:4,height:4};if(e===h.ASTC5x4Unorm||e===h.ASTC5x4UnormSRGB)return{byteLength:16,width:5,height:4};if(e===h.ASTC5x5Unorm||e===h.ASTC5x5UnormSRGB)return{byteLength:16,width:5,height:5};if(e===h.ASTC6x5Unorm||e===h.ASTC6x5UnormSRGB)return{byteLength:16,width:6,height:5};if(e===h.ASTC6x6Unorm||e===h.ASTC6x6UnormSRGB)return{byteLength:16,width:6,height:6};if(e===h.ASTC8x5Unorm||e===h.ASTC8x5UnormSRGB)return{byteLength:16,width:8,height:5};if(e===h.ASTC8x6Unorm||e===h.ASTC8x6UnormSRGB)return{byteLength:16,width:8,height:6};if(e===h.ASTC8x8Unorm||e===h.ASTC8x8UnormSRGB)return{byteLength:16,width:8,height:8};if(e===h.ASTC10x5Unorm||e===h.ASTC10x5UnormSRGB)return{byteLength:16,width:10,height:5};if(e===h.ASTC10x6Unorm||e===h.ASTC10x6UnormSRGB)return{byteLength:16,width:10,height:6};if(e===h.ASTC10x8Unorm||e===h.ASTC10x8UnormSRGB)return{byteLength:16,width:10,height:8};if(e===h.ASTC10x10Unorm||e===h.ASTC10x10UnormSRGB)return{byteLength:16,width:10,height:10};if(e===h.ASTC12x10Unorm||e===h.ASTC12x10UnormSRGB)return{byteLength:16,width:12,height:10};if(e===h.ASTC12x12Unorm||e===h.ASTC12x12UnormSRGB)return{byteLength:16,width:12,height:12}}_getBytesPerTexel(e){if(e===h.R8Unorm)return 1;if(e===h.R16Float||e===h.RG8Unorm)return 2;if(e===h.RG16Float||e===h.R32Float||e===h.RGBA8Unorm||e===h.RGBA8UnormSRGB)return 4;if(e===h.RG32Float||e===h.RGBA16Float)return 8;if(e===h.RGBA32Float)return 16}_getDimension(e){let t;return e.isData3DTexture?t=$t.ThreeD:t=$t.TwoD,t}_getFormat(e){const t=e.format,s=e.type,r=e.colorSpace;let n;if(e.isCompressedTexture===!0)switch(t){case Ni:n=r===P?h.BC1RGBAUnormSRGB:h.BC1RGBAUnorm;break;case Ti:n=r===P?h.BC2RGBAUnormSRGB:h.BC2RGBAUnorm;break;case xi:n=r===P?h.BC3RGBAUnormSRGB:h.BC3RGBAUnorm;break;case mi:n=r===P?h.ETC2RGB8UnormSRGB:h.ETC2RGB8Unorm;break;case gi:n=r===P?h.ETC2RGBA8UnormSRGB:h.ETC2RGBA8Unorm;break;case fi:n=r===P?h.ASTC4x4UnormSRGB:h.ASTC4x4Unorm;break;case pi:n=r===P?h.ASTC5x4UnormSRGB:h.ASTC5x4Unorm;break;case hi:n=r===P?h.ASTC5x5UnormSRGB:h.ASTC5x5Unorm;break;case di:n=r===P?h.ASTC6x5UnormSRGB:h.ASTC6x5Unorm;break;case li:n=r===P?h.ASTC6x6UnormSRGB:h.ASTC6x6Unorm;break;case ui:n=r===P?h.ASTC8x5UnormSRGB:h.ASTC8x5Unorm;break;case ci:n=r===P?h.ASTC8x6UnormSRGB:h.ASTC8x6Unorm;break;case ai:n=r===P?h.ASTC8x8UnormSRGB:h.ASTC8x8Unorm;break;case oi:n=r===P?h.ASTC10x5UnormSRGB:h.ASTC10x5Unorm;break;case ii:n=r===P?h.ASTC10x6UnormSRGB:h.ASTC10x6Unorm;break;case ni:n=r===P?h.ASTC10x8UnormSRGB:h.ASTC10x8Unorm;break;case ri:n=r===P?h.ASTC10x10UnormSRGB:h.ASTC10x10Unorm;break;case si:n=r===P?h.ASTC12x10UnormSRGB:h.ASTC12x10Unorm;break;case ti:n=r===P?h.ASTC12x12UnormSRGB:h.ASTC12x12Unorm;break;default:console.error("WebGPURenderer: Unsupported texture format.",t)}else switch(t){case wi:switch(s){case et:n=r===P?h.RGBA8UnormSRGB:h.RGBA8Unorm;break;case Qe:n=h.RGBA16Float;break;case Se:n=h.RGBA32Float;break;default:console.error("WebGPURenderer: Unsupported texture type with RGBAFormat.",s)}break;case Ai:switch(s){case et:n=h.R8Unorm;break;case Qe:n=h.R16Float;break;case Se:n=h.R32Float;break;default:console.error("WebGPURenderer: Unsupported texture type with RedFormat.",s)}break;case vi:switch(s){case et:n=h.RG8Unorm;break;case Qe:n=h.RG16Float;break;case Se:n=h.RG32Float;break;default:console.error("WebGPURenderer: Unsupported texture type with RGFormat.",s)}break;case ps:switch(s){case Ci:n=h.Depth16Unorm;break;case bi:n=h.Depth24Plus;break;case Se:n=h.Depth32Float;break;default:console.error("WebGPURenderer: Unsupported texture type with DepthFormat.",s)}break;case yi:switch(s){case Si:n=h.Depth24PlusStencil8;break;case Se:this.device.features.has(ht.Depth32FloatStencil8)===!1&&console.error('WebGPURenderer: Depth textures with DepthStencilFormat + FloatType can only be used with the "depth32float-stencil8" GPU feature.'),n=h.Depth32FloatStencil8;break;default:console.error("WebGPURenderer: Unsupported texture type with DepthStencilFormat.",s)}break;default:console.error("WebGPURenderer: Unsupported texture format.",t)}return n}_isHTMLImage(e){return typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement}_copyImageToTexture(e,t,s,r,n,i){this._isHTMLImage(e)?this._getImageBitmapFromHTML(e,t).then(a=>{this._copyExternalImageToTexture(a,s,r,n,i)}):this._copyExternalImageToTexture(e,s,r,n,i)}_getImageBitmapFromHTML(e,t){const s=e.width,r=e.height,n={};return n.imageOrientation=t.flipY===!0?"flipY":"none",n.premultiplyAlpha=t.premultiplyAlpha===!0?"premultiply":"default",createImageBitmap(e,0,0,s,r,n)}_getImageBitmap(e,t){const s=e.width,r=e.height;if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement){const n={};return n.imageOrientation=t.flipY===!0?"flipY":"none",n.premultiplyAlpha=t.premultiplyAlpha===!0?"premultiply":"default",createImageBitmap(e,0,0,s,r,n)}else return Promise.resolve(e)}_getMipLevelCount(e,t,s,r){let n;return e.isCompressedTexture?n=e.mipmaps.length:r?n=Math.floor(Math.log2(Math.max(t,s)))+1:n=1,n}_getSize(e){const t=e.image;let s,r,n;if(e.isCubeTexture){const i=t.length>0?t[0].image||t[0]:null;s=i?i.width:1,r=i?i.height:1,n=6}else t!==null?(s=t.width,r=t.height,n=t.depth!==void 0?t.depth:1):s=r=n=1;return{width:s,height:r,depth:n}}_needsMipmaps(e){return e.isCompressedTexture!==!0&&e.generateMipmaps===!0&&e.minFilter!==K&&e.minFilter!==Ri}}function Ou(o){const e=o.target,t=this.properties,s=t.get(e);e.removeEventListener("dispose",s.disposeCallback),s.colorTextureGPU.destroy(),t.remove(e.texture),this.info.memory.textures--,e.depthBuffer===!0&&(s.depthTextureGPU.destroy(),this.info.memory.textures--,e.depthTexture!==null&&t.remove(e.depthTexture)),t.remove(e)}function Wu(o){const e=o.target,t=this.properties.get(e);t.textureGPU.destroy(),e.removeEventListener("dispose",t.disposeCallback),this.properties.remove(e),this.info.memory.textures--}const Du=Iu;let be;const se=new xe;class Vu{constructor(e,t){this.renderer=e,this.properties=t,this.boxMesh=null,this.boxMeshNode=null,this.forceClear=!1}clear(){this.forceClear=!0}update(e,t,s){const r=this.renderer,n=e.isScene===!0?e.backgroundNode||this.properties.get(e).backgroundNode||e.background:null;let i=this.forceClear;if(n===null)se.copy(r._clearColor),be=r._clearAlpha;else if(n.isColor===!0)se.copy(n),be=1,i=!0;else if(n.isNode===!0){const l=this.properties.get(e),d=n;se.copy(r._clearColor),be=r._clearAlpha;let f=this.boxMesh;if(f===null){this.boxMeshNode=oe(d,{getUVNode:()=>or});const y=new Ir;y.colorNode=this.boxMeshNode,y.side=us,y.depthTest=!1,y.depthWrite=!1,y.fog=!1,this.boxMesh=f=new Pi(new Ei(1,1,1),y),f.frustumCulled=!1,f.onBeforeRender=function(A,b,M){const G=M.far;this.matrixWorld.makeScale(G,G,G).copyPosition(M.matrixWorld)}}const m=d.getCacheKey();l.backgroundCacheKey!==m&&(this.boxMeshNode.node=d,f.material.needsUpdate=!0,l.backgroundCacheKey=m),t.unshift(f,f.geometry,f.material,0,0,null)}else console.error("THREE.WebGPURenderer: Unsupported background configuration.",n);const a=s.descriptorGPU.colorAttachments[0],c=s.descriptorGPU.depthStencilAttachment;r.autoClear===!0||i===!0?(r.autoClearColor===!0?(se.multiplyScalar(be),a.clearValue={r:se.r,g:se.g,b:se.b,a:be},a.loadOp=q.Clear,a.storeOp=Y.Store):(a.loadOp=q.Load,a.storeOp=Y.Store),s.depth&&(r.autoClearDepth===!0?(c.depthClearValue=r._clearDepth,c.depthLoadOp=q.Clear,c.depthStoreOp=Y.Store):(c.depthLoadOp=q.Load,c.depthStoreOp=Y.Store)),s.stencil&&(r.autoClearStencil===!0?(c.stencilClearValue=r._clearStencil,c.stencilLoadOp=q.Clear,c.stencilStoreOp=Y.Store):(c.stencilLoadOp=q.Load,c.stencilStoreOp=Y.Store))):(a.loadOp=q.Load,a.storeOp=Y.Store,s.depth&&(c.depthLoadOp=q.Load,c.depthStoreOp=Y.Store),s.stencil&&(c.stencilLoadOp=q.Load,c.stencilStoreOp=Y.Store)),this.forceClear=!1}}const ku=Vu;class $u{constructor(e=""){this.name=e,this.visibility=null,this.type=null,this.isShared=!1}setVisibility(e){this.visibility=e}}const Bt=$u;function Dr(o){return o+(Q-o%Q)%Q}function zu(o,e=4){const s=Vr(e)*o;return Dr(s)}function Vr(o){return o+(4-o%4)%4}class qu extends Bt{constructor(e,t,s=null){super(e),this.isBuffer=!0,this.bytesPerElement=Float32Array.BYTES_PER_ELEMENT,this.type=t,this.visibility=GPUShaderStage.VERTEX,this.usage=GPUBufferUsage.COPY_DST,this.buffer=s,this.bufferGPU=null}getByteLength(){return Dr(this.buffer.byteLength)}getBuffer(){return this.buffer}update(){return!0}}const kr=qu;class Hu extends kr{constructor(e,t=null){super(e,He.UniformBuffer,t),this.isUniformBuffer=!0,this.usage|=GPUBufferUsage.UNIFORM}}const $r=Hu;class Xu extends $r{constructor(e){super(e),this.isUniformsGroup=!0,this.uniforms=[]}addUniform(e){return this.uniforms.push(e),this}removeUniform(e){const t=this.uniforms.indexOf(e);return t!==-1&&this.uniforms.splice(t,1),this}getBuffer(){let e=this.buffer;if(e===null){const t=this.getByteLength();e=new Float32Array(new ArrayBuffer(t)),this.buffer=e}return e}getByteLength(){let e=0;for(let t=0,s=this.uniforms.length;t<s;t++){const r=this.uniforms[t],n=e%Q,i=Q-n;n!==0&&i-r.boundary<0?e+=Q-n:n%r.boundary!==0&&(e+=n%r.boundary),r.offset=e/this.bytesPerElement,e+=r.itemSize*this.bytesPerElement}return Math.ceil(e/Q)*Q}update(){let e=!1;for(const t of this.uniforms)this.updateByType(t)===!0&&(e=!0);return e}updateByType(e){if(e.isFloatUniform)return this.updateNumber(e);if(e.isVector2Uniform)return this.updateVector2(e);if(e.isVector3Uniform)return this.updateVector3(e);if(e.isVector4Uniform)return this.updateVector4(e);if(e.isColorUniform)return this.updateColor(e);if(e.isMatrix3Uniform)return this.updateMatrix3(e);if(e.isMatrix4Uniform)return this.updateMatrix4(e);console.error("THREE.WebGPUUniformsGroup: Unsupported uniform type.",e)}updateNumber(e){let t=!1;const s=this.buffer,r=e.getValue(),n=e.offset;return s[n]!==r&&(s[n]=r,t=!0),t}updateVector2(e){let t=!1;const s=this.buffer,r=e.getValue(),n=e.offset;return(s[n+0]!==r.x||s[n+1]!==r.y)&&(s[n+0]=r.x,s[n+1]=r.y,t=!0),t}updateVector3(e){let t=!1;const s=this.buffer,r=e.getValue(),n=e.offset;return(s[n+0]!==r.x||s[n+1]!==r.y||s[n+2]!==r.z)&&(s[n+0]=r.x,s[n+1]=r.y,s[n+2]=r.z,t=!0),t}updateVector4(e){let t=!1;const s=this.buffer,r=e.getValue(),n=e.offset;return(s[n+0]!==r.x||s[n+1]!==r.y||s[n+2]!==r.z||s[n+4]!==r.w)&&(s[n+0]=r.x,s[n+1]=r.y,s[n+2]=r.z,s[n+3]=r.w,t=!0),t}updateColor(e){let t=!1;const s=this.buffer,r=e.getValue(),n=e.offset;return(s[n+0]!==r.r||s[n+1]!==r.g||s[n+2]!==r.b)&&(s[n+0]=r.r,s[n+1]=r.g,s[n+2]=r.b,t=!0),t}updateMatrix3(e){let t=!1;const s=this.buffer,r=e.getValue().elements,n=e.offset;return(s[n+0]!==r[0]||s[n+1]!==r[1]||s[n+2]!==r[2]||s[n+4]!==r[3]||s[n+5]!==r[4]||s[n+6]!==r[5]||s[n+8]!==r[6]||s[n+9]!==r[7]||s[n+10]!==r[8])&&(s[n+0]=r[0],s[n+1]=r[1],s[n+2]=r[2],s[n+4]=r[3],s[n+5]=r[4],s[n+6]=r[5],s[n+8]=r[6],s[n+9]=r[7],s[n+10]=r[8],t=!0),t}updateMatrix4(e){let t=!1;const s=this.buffer,r=e.getValue().elements,n=e.offset;return Yu(s,r,n)===!1&&(s.set(r,n),t=!0),t}}function Yu(o,e,t){for(let s=0,r=e.length;s<r;s++)if(o[t+s]!==e[s])return!1;return!0}const Ku=Xu;class le{constructor(e,t=null){this.name=e,this.value=t,this.boundary=0,this.itemSize=0,this.offset=0}setValue(e){this.value=e}getValue(){return this.value}}class Zu extends le{constructor(e,t=0){super(e,t),this.isFloatUniform=!0,this.boundary=4,this.itemSize=1}}class Ju extends le{constructor(e,t=new qe){super(e,t),this.isVector2Uniform=!0,this.boundary=8,this.itemSize=2}}class ju extends le{constructor(e,t=new ie){super(e,t),this.isVector3Uniform=!0,this.boundary=16,this.itemSize=3}}class Qu extends le{constructor(e,t=new yt){super(e,t),this.isVector4Uniform=!0,this.boundary=16,this.itemSize=4}}class el extends le{constructor(e,t=new xe){super(e,t),this.isColorUniform=!0,this.boundary=16,this.itemSize=3}}class tl extends le{constructor(e,t=new ds){super(e,t),this.isMatrix3Uniform=!0,this.boundary=48,this.itemSize=12}}class sl extends le{constructor(e,t=new Ge){super(e,t),this.isMatrix4Uniform=!0,this.boundary=64,this.itemSize=16}}class rl extends Zu{constructor(e){super(e.name,e.value),this.nodeUniform=e}getValue(){return this.nodeUniform.value}}class nl extends Ju{constructor(e){super(e.name,e.value),this.nodeUniform=e}getValue(){return this.nodeUniform.value}}class il extends ju{constructor(e){super(e.name,e.value),this.nodeUniform=e}getValue(){return this.nodeUniform.value}}class ol extends Qu{constructor(e){super(e.name,e.value),this.nodeUniform=e}getValue(){return this.nodeUniform.value}}class al extends el{constructor(e){super(e.name,e.value),this.nodeUniform=e}getValue(){return this.nodeUniform.value}}class cl extends tl{constructor(e){super(e.name,e.value),this.nodeUniform=e}getValue(){return this.nodeUniform.value}}class ul extends sl{constructor(e){super(e.name,e.value),this.nodeUniform=e}getValue(){return this.nodeUniform.value}}class ll extends Bt{constructor(e,t){super(e),this.isSampler=!0,this.texture=t,this.type=He.Sampler,this.visibility=GPUShaderStage.FRAGMENT,this.samplerGPU=null}getTexture(){return this.texture}}const dl=ll;class hl extends dl{constructor(e,t){super(e,t.value),this.textureNode=t}getTexture(){return this.textureNode.value}}const pl=hl;class zr extends Bt{constructor(e,t){super(e),this.isSampledTexture=!0,this.texture=t,this.dimension=Oe.TwoD,this.type=He.SampledTexture,this.visibility=GPUShaderStage.FRAGMENT,this.aspect=t.isDepthTexture?zt.DepthOnly:zt.All,this.textureGPU=null}getTexture(){return this.texture}}class fl extends zr{constructor(e,t){super(e,t),this.isSampledCubeTexture=!0,this.dimension=Oe.Cube}}class gl extends zr{constructor(e,t){super(e,t.value),this.textureNode=t}getTexture(){return this.textureNode.value}}class ml extends fl{constructor(e,t){super(e,t.value),this.textureNode=t}getTexture(){return this.textureNode.value}}class xl extends kr{constructor(e,t){super(e,He.StorageBuffer,t.array),this.isStorageBuffer=!0,this.usage|=GPUBufferUsage.VERTEX|GPUBufferUsage.STORAGE,this.attribute=t}}const Tl=xl;class Nl extends Bi{constructor(e,t,s={}){super(e,t,s)}}const yl=Nl,rs={vertex:GPUShaderStage.VERTEX,fragment:GPUShaderStage.FRAGMENT,compute:GPUShaderStage.COMPUTE},Sl={instance:!0},bl={float:"f32",int:"i32",uint:"u32",bool:"bool",color:"vec3<f32>",vec2:"vec2<f32>",ivec2:"vec2<i32>",uvec2:"vec2<u32>",bvec2:"vec2<bool>",vec3:"vec3<f32>",ivec3:"vec3<i32>",uvec3:"vec3<u32>",bvec3:"vec3<bool>",vec4:"vec4<f32>",ivec4:"vec4<i32>",uvec4:"vec4<u32>",bvec4:"vec4<bool>",mat3:"mat3x3<f32>",imat3:"mat3x3<i32>",umat3:"mat3x3<u32>",bmat3:"mat3x3<bool>",mat4:"mat4x4<f32>",imat4:"mat4x4<i32>",umat4:"mat4x4<u32>",bmat4:"mat4x4<bool>"},Cl={dFdx:"dpdx",dFdy:"dpdy",mod:"threejs_mod",lessThanEqual:"threejs_lessThanEqual",inversesqrt:"inverseSqrt"},ns={lessThanEqual:new ct(`
fn threejs_lessThanEqual( a : vec3<f32>, b : vec3<f32> ) -> vec3<bool> {

	return vec3<bool>( a.x <= b.x, a.y <= b.y, a.z <= b.z );

}
`),mod:new ct(`
fn threejs_mod( x : f32, y : f32 ) -> f32 {

	return x - y * floor( x / y );

}
`),repeatWrapping:new ct(`
fn threejs_repeatWrapping( uv : vec2<f32>, dimension : vec2<u32> ) -> vec2<u32> {

	let uvScaled = vec2<u32>( uv * vec2<f32>( dimension ) );

	return ( ( uvScaled % dimension ) + dimension ) % dimension;

}
`)};class vl extends Wa{constructor(e,t){super(e,t,new wu),this.bindings={vertex:[],fragment:[],compute:[]},this.bindingsOffset={vertex:0,fragment:0,compute:0},this.uniformsGroup={},this.builtins={vertex:new Map,fragment:new Map,compute:new Map,attribute:new Map}}build(){const{object:e,material:t}=this;return t!==null?Br.fromMaterial(t).build(this):this.addFlow("compute",e),super.build()}getSampler(e,t,s=this.shaderStage){if(s==="fragment")return`textureSample( ${e}, ${e}_sampler, ${t} )`;{this._include("repeatWrapping");const r=`textureDimensions( ${e}, 0 )`;return`textureLoad( ${e}, threejs_repeatWrapping( ${t}, ${r} ), 0 )`}}getVideoSampler(e,t,s=this.shaderStage){if(s==="fragment")return`textureSampleBaseClampToEdge( ${e}, ${e}_sampler, vec2<f32>( ${t}.x, 1.0 - ${t}.y ) )`;console.error(`WebGPURenderer: THREE.VideoTexture does not support ${s} shader.`)}getSamplerLevel(e,t,s,r=this.shaderStage){if(r==="fragment")return`textureSampleLevel( ${e}, ${e}_sampler, ${t}, ${s} )`;{this._include("repeatWrapping");const n=`textureDimensions( ${e}, 0 )`;return`textureLoad( ${e}, threejs_repeatWrapping( ${t}, ${n} ), i32( ${s} ) )`}}getTexture(e,t,s,r=this.shaderStage){let n=null;return e.isVideoTexture===!0?n=this.getVideoSampler(t,s,r):n=this.getSampler(t,s,r),n}getTextureLevel(e,t,s,r,n=this.shaderStage){let i=null;return e.isVideoTexture===!0?i=this.getVideoSampler(t,s,n):i=this.getSamplerLevel(t,s,r,n),i}getPropertyName(e,t=this.shaderStage){if(e.isNodeVarying===!0&&e.needsInterpolation===!0){if(t==="vertex")return`NodeVaryings.${e.name}`}else if(e.isNodeUniform===!0){const s=e.name,r=e.type;return r==="texture"||r==="cubeTexture"?s:r==="buffer"||r==="storageBuffer"?`NodeBuffer_${e.node.id}.${s}`:`NodeUniforms.${s}`}return super.getPropertyName(e)}getBindings(){const e=this.bindings;return this.material!==null?[...e.vertex,...e.fragment]:e.compute}getUniformFromNode(e,t,s){const r=super.getUniformFromNode(e,t,s),n=this.getDataFromNode(e,t);if(n.uniformGPU===void 0){let i;const a=this.bindings[t];if(s==="texture"||s==="cubeTexture"){const c=new pl(`${r.name}_sampler`,r.node);let l=null;s==="texture"?l=new gl(r.name,r.node):s==="cubeTexture"&&(l=new ml(r.name,r.node));const d=a[a.length-1],f=d&&d.isUniformsGroup?a.length-1:a.length;t==="fragment"?(a.splice(f,0,c,l),i=[c,l]):(a.splice(f,0,l),i=[l])}else if(s==="buffer"||s==="storageBuffer"){const c=s==="storageBuffer"?Tl:$r,l=new c("NodeBuffer_"+e.id,e.value);l.setVisibility(rs[t]);const d=a[a.length-1],f=d&&d.isUniformsGroup?a.length-1:a.length;a.splice(f,0,l),i=l}else{let c=this.uniformsGroup[t];if(c===void 0&&(c=new Ku("nodeUniforms"),c.setVisibility(rs[t]),this.uniformsGroup[t]=c,a.push(c)),e.isArrayUniformNode===!0){i=[];for(const l of e.nodes){const d=this._getNodeUniform(l,s);d.boundary=zu(d.itemSize),d.itemSize=Vr(d.itemSize),c.addUniform(d),i.push(d)}}else i=this._getNodeUniform(r,s),c.addUniform(i)}n.uniformGPU=i,t==="vertex"&&(this.bindingsOffset.fragment=a.length)}return r}isReference(e){return super.isReference(e)||e==="texture_2d"||e==="texture_cube"}getBuiltin(e,t,s,r=this.shaderStage){const n=this.builtins[r];return n.has(e)===!1&&n.set(e,{name:e,property:t,type:s}),t}getInstanceIndex(){return this.shaderStage==="vertex"?this.getBuiltin("instance_index","instanceIndex","u32","attribute"):"instanceIndex"}getFrontFacing(){return this.getBuiltin("front_facing","isFront","bool")}getFragCoord(){return this.getBuiltin("position","fragCoord","vec4<f32>","fragment")}isFlipY(){return!1}getAttributes(e){const t=[];if(e==="compute"&&this.getBuiltin("global_invocation_id","id","vec3<u32>","attribute"),e==="vertex"||e==="compute"){for(const{name:n,property:i,type:a}of this.builtins.attribute.values())t.push(`@builtin( ${n} ) ${i} : ${a}`);const s=this.attributes,r=s.length;for(let n=0;n<r;n++){const i=s[n],a=i.name,c=this.getType(i.type);t.push(`@location( ${n} ) ${a} : ${c}`)}}return t.join(`,
	`)}getVars(e){const t=[],s=this.vars[e];for(const r of s){const n=r.name,i=this.getType(r.type);t.push(`	var ${n} : ${i};`)}return`
${t.join(`
`)}
`}getVaryings(e){const t=[];if(e==="vertex"&&this.getBuiltin("position","Vertex","vec4<f32>","vertex"),e==="vertex"||e==="fragment"){const r=this.varyings,n=this.vars[e];for(let i=0;i<r.length;i++){const a=r[i];a.needsInterpolation?t.push(`@location( ${i} ) ${a.name} : ${this.getType(a.type)}`):n.includes(a)===!1&&n.push(a)}}for(const{name:r,property:n,type:i}of this.builtins[e].values())t.push(`@builtin( ${r} ) ${n} : ${i}`);const s=t.join(`,
	`);return e==="vertex"?this._getWGSLStruct("NodeVaryingsStruct","	"+s):s}getUniforms(e){const t=this.uniforms[e],s=[],r=[],n=[];let i=this.bindingsOffset[e];for(const c of t)if(c.type==="texture"||c.type==="cubeTexture"){e==="fragment"&&s.push(`@group( 0 ) @binding( ${i++} ) var ${c.name}_sampler : sampler;`);const l=c.node.value;let d;l.isCubeTexture===!0?d="texture_cube<f32>":l.isDepthTexture===!0?d="texture_depth_2d":l.isVideoTexture===!0?d="texture_external":d="texture_2d<f32>",s.push(`@group( 0 ) @binding( ${i++} ) var ${c.name} : ${d};`)}else if(c.type==="buffer"||c.type==="storageBuffer"){const l=c.node,d=this.getType(l.bufferType),f=l.bufferCount,m=f>0?", "+f:"",y=`	${c.name} : array< ${d}${m} >
`,A=l.isStorageBufferNode?"storage,read_write":"uniform";r.push(this._getWGSLStructBinding("NodeBuffer_"+l.id,y,A,i++))}else{const l=this.getType(this.getVectorType(c.type));if(Array.isArray(c.value)===!0){const d=c.value.length;n.push(`uniform ${l}[ ${d} ] ${c.name}`)}else n.push(`	${c.name} : ${l}`)}let a=s.join(`
`);return a+=r.join(`
`),n.length>0&&(a+=this._getWGSLStructBinding("NodeUniforms",n.join(`,
`),"uniform",i++)),a}buildCode(){const e=this.material!==null?{fragment:{},vertex:{}}:{compute:{}};for(const t in e){let s=`// code

`;s+=this.flowCode[t];const r=this.flowNodes[t],n=r[r.length-1];for(const a of r){const c=this.getFlowData(a),l=a.name;l&&(s.length>0&&(s+=`
`),s+=`	// flow -> ${l}
	`),s+=`${c.code}
	`,a===n&&t!=="compute"&&(s+=`// result
	`,t==="vertex"?s+="NodeVaryings.Vertex = ":t==="fragment"&&(s+="return "),s+=`${c.result};`)}const i=e[t];i.uniforms=this.getUniforms(t),i.attributes=this.getAttributes(t),i.varyings=this.getVaryings(t),i.vars=this.getVars(t),i.codes=this.getCodes(t),i.flow=s}this.material!==null?(this.vertexShader=this._getWGSLVertexCode(e.vertex),this.fragmentShader=this._getWGSLFragmentCode(e.fragment)):this.computeShader=this._getWGSLComputeCode(e.compute,(this.object.workgroupSize||[64]).join(", "))}getRenderTarget(e,t,s){return new yl(e,t,s)}getMethod(e){return ns[e]!==void 0&&this._include(e),Cl[e]||e}getType(e){return bl[e]||e}isAvailable(e){return Sl[e]===!0}_include(e){ns[e].build(this)}_getNodeUniform(e,t){if(t==="float")return new rl(e);if(t==="vec2")return new nl(e);if(t==="vec3")return new il(e);if(t==="vec4")return new ol(e);if(t==="color")return new al(e);if(t==="mat3")return new cl(e);if(t==="mat4")return new ul(e);throw new Error(`Uniform "${t}" not declared.`)}_getWGSLVertexCode(e){return`${this.getSignature()}

// uniforms
${e.uniforms}

// varyings
${e.varyings}

// codes
${e.codes}

@vertex
fn main( ${e.attributes} ) -> NodeVaryingsStruct {

	// system
	var NodeVaryings: NodeVaryingsStruct;

	// vars
	${e.vars}

	// flow
	${e.flow}

	return NodeVaryings;

}
`}_getWGSLFragmentCode(e){return`${this.getSignature()}

// uniforms
${e.uniforms}

// codes
${e.codes}

@fragment
fn main( ${e.varyings} ) -> @location( 0 ) vec4<f32> {

	// vars
	${e.vars}

	// flow
	${e.flow}

}
`}_getWGSLComputeCode(e,t){return`${this.getSignature()}
// system
var<private> instanceIndex : u32;

// uniforms
${e.uniforms}

// codes
${e.codes}

@compute @workgroup_size( ${t} )
fn main( ${e.attributes} ) {

	// system
	instanceIndex = id.x;

	// vars
	${e.vars}

	// flow
	${e.flow}

}
`}_getWGSLStruct(e,t){return`
struct ${e} {
${t}
};`}_getWGSLStructBinding(e,t,s,r=0,n=0){const i=e+"Struct";return`${this._getWGSLStruct(i,t)}
@binding( ${r} ) @group( ${n} )
var<${s}> ${e} : ${i};`}}const is=vl;class Al{constructor(e,t){this.renderer=e,this.properties=t,this.nodeFrame=new jt}get(e){const t=this.properties.get(e);let s=t.nodeBuilder;return s===void 0&&(s=new is(e.object,this.renderer),s.material=e.material,s.lightsNode=e.lightsNode,s.environmentNode=this.getEnvironmentNode(e.scene),s.fogNode=this.getFogNode(e.scene),s.toneMappingNode=this.getToneMappingNode(),s.build(),t.nodeBuilder=s),s}getForCompute(e){const t=this.properties.get(e);let s=t.nodeBuilder;return s===void 0&&(s=new is(e,this.renderer),s.build(),t.nodeBuilder=s),s}remove(e){const t=this.properties.get(e);delete t.nodeBuilder}getEnvironmentNode(e){return e.environmentNode||this.properties.get(e).environmentNode||null}getFogNode(e){return e.fogNode||this.properties.get(e).fogNode||null}getToneMappingNode(){return this.renderer.toneMappingNode||this.properties.get(this.renderer).toneMappingNode||null}getCacheKey(e,t){const s=this.getEnvironmentNode(e),r=this.getFogNode(e),n=this.getToneMappingNode(),i=[];return t&&i.push("lightsNode:"+t.getCacheKey()),s&&i.push("environmentNode:"+s.getCacheKey()),r&&i.push("fogNode:"+r.getCacheKey()),n&&i.push("toneMappingNode:"+n.getCacheKey()),"{"+i.join(",")+"}"}updateToneMapping(){const e=this.renderer,t=this.properties.get(e),s=e.toneMapping;s!==Ie?t.toneMapping!==s&&(t.toneMappingNode=iu(s,re("toneMappingExposure","float",e)),t.toneMapping=s):(delete t.toneMappingNode,delete t.toneMapping)}updateBackground(e){const t=this.properties.get(e),s=e.background;if(s){if(t.background!==s){let r=null;if(s.isCubeTexture===!0)r=Tt(s,Qs(ir,mt));else if(s.isTexture===!0){let n=null;s.mapping===Fi||s.mapping===Li?n=xt():n=ou,r=me(s,n)}else s.isColor!==!0&&console.error("WebGPUNodes: Unsupported background configuration.",s);t.backgroundNode=r,t.background=s}}else t.backgroundNode&&(delete t.backgroundNode,delete t.background)}updateFog(e){const t=this.properties.get(e),s=e.fog;if(s){if(t.fog!==s){let r=null;s.isFogExp2?r=Ur(re("color","color",s),re("density","float",s)):s.isFog?r=wr(re("color","color",s),re("near","float",s),re("far","float",s)):console.error("WebGPUNodes: Unsupported fog configuration.",s),t.fogNode=r,t.fog=s}}else delete t.fogNode,delete t.fog}updateEnvironment(e){const t=this.properties.get(e),s=e.environment;if(s){if(t.environment!==s){let r=null;s.isCubeTexture===!0?r=Tt(s):s.isTexture===!0?r=me(s):console.error("WebGPUNodes: Unsupported environment configuration.",s),t.environmentNode=r,t.environment=s}}else t.environmentNode&&(delete t.environmentNode,delete t.environment)}getNodeFrame(e){const t=this.nodeFrame;return t.scene=e.scene,t.object=e.object,t.camera=e.camera,t.renderer=e.renderer,t.material=e.material,t}updateBefore(e){const t=this.getNodeFrame(e),s=this.get(e);for(const r of s.updateBeforeNodes)t.updateBeforeNode(r)}update(e){const t=this.getNodeFrame(e),s=this.get(e);for(const r of s.updateNodes)t.updateNode(r)}dispose(){this.nodeFrame=new jt}}const wl=Al;class Rl{constructor(e){this.renderer=e}getCurrentColorSpace(){const e=this.renderer,t=e.getRenderTarget();return t!==null?t.texture.colorSpace:e.outputColorSpace}getCurrentColorFormat(){let e;const t=this.renderer,s=t.getRenderTarget();return s!==null?e=t._properties.get(s).colorTextureFormat:e=h.BGRA8Unorm,e}getCurrentDepthStencilFormat(){let e;const t=this.renderer,s=t.getRenderTarget();return s!==null?e=t._properties.get(s).depthTextureFormat:e=h.Depth24PlusStencil8,e}getPrimitiveTopology(e,t){if(e.isPoints)return ve.PointList;if(e.isLineSegments||e.isMesh&&t.wireframe===!0)return ve.LineList;if(e.isLine)return ve.LineStrip;if(e.isMesh)return ve.TriangleList}getSampleCount(){return this.renderer._parameters.sampleCount}}const Ul=Rl;console.info("THREE.WebGPURenderer: Modified Matrix4.makePerspective() and Matrix4.makeOrtographic() to work with WebGPU, see https://github.com/mrdoob/three.js/issues/20276.");Ge.prototype.makePerspective=function(o,e,t,s,r,n){const i=this.elements,a=2*r/(e-o),c=2*r/(t-s),l=(e+o)/(e-o),d=(t+s)/(t-s),f=-n/(n-r),m=-n*r/(n-r);return i[0]=a,i[4]=0,i[8]=l,i[12]=0,i[1]=0,i[5]=c,i[9]=d,i[13]=0,i[2]=0,i[6]=0,i[10]=f,i[14]=m,i[3]=0,i[7]=0,i[11]=-1,i[15]=0,this};Ge.prototype.makeOrthographic=function(o,e,t,s,r,n){const i=this.elements,a=1/(e-o),c=1/(t-s),l=1/(n-r),d=(e+o)*a,f=(t+s)*c,m=r*l;return i[0]=2*a,i[4]=0,i[8]=0,i[12]=-d,i[1]=0,i[5]=2*c,i[9]=0,i[13]=-f,i[2]=0,i[6]=0,i[10]=-1*l,i[14]=-m,i[3]=0,i[7]=0,i[11]=0,i[15]=1,this};fs.prototype.setFromProjectionMatrix=function(o){const e=this.planes,t=o.elements,s=t[0],r=t[1],n=t[2],i=t[3],a=t[4],c=t[5],l=t[6],d=t[7],f=t[8],m=t[9],y=t[10],A=t[11],b=t[12],M=t[13],G=t[14],I=t[15];return e[0].setComponents(i-s,d-a,A-f,I-b).normalize(),e[1].setComponents(i+s,d+a,A+f,I+b).normalize(),e[2].setComponents(i+r,d+c,A+m,I+M).normalize(),e[3].setComponents(i-r,d-c,A-m,I-M).normalize(),e[4].setComponents(i-n,d-l,A-y,I-G).normalize(),e[5].setComponents(n,l,y,G).normalize(),this};const lt=new fs,Be=new Ge,Ce=new ie;class Ml{constructor(e={}){this.isWebGPURenderer=!0,this.domElement=e.canvas!==void 0?e.canvas:this._createCanvasElement(),this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.outputColorSpace=P,this.toneMapping=Ie,this.toneMappingExposure=1,this.sortObjects=!0,this._parameters=Object.assign({},e),this._pixelRatio=1,this._width=this.domElement.width,this._height=this.domElement.height,this._viewport=null,this._scissor=null,this._adapter=null,this._device=null,this._context=null,this._colorBuffer=null,this._depthBuffer=null,this._info=null,this._properties=null,this._attributes=null,this._geometries=null,this._nodes=null,this._bindings=null,this._objects=null,this._renderPipelines=null,this._computePipelines=null,this._renderLists=null,this._renderStates=null,this._textures=null,this._background=null,this._animation=new zi,this._currentRenderState=null,this._opaqueSort=null,this._transparentSort=null,this._clearAlpha=1,this._clearColor=new xe(0),this._clearDepth=1,this._clearStencil=0,this._renderTarget=null,this._initialized=!1,this._parameters.antialias=e.antialias===!0,this._parameters.antialias===!0?this._parameters.sampleCount=e.sampleCount===void 0?4:e.sampleCount:this._parameters.sampleCount=1,this._parameters.requiredLimits=e.requiredLimits===void 0?{}:e.requiredLimits,this.shadow={shadowMap:{}}}async init(){if(this._initialized===!0)throw new Error("WebGPURenderer: Device has already been initialized.");const e=this._parameters,t={powerPreference:e.powerPreference},s=await navigator.gpu.requestAdapter(t);if(s===null)throw new Error("WebGPURenderer: Unable to create WebGPU adapter.");const r=Object.values(ht),n=[];for(const l of r)s.features.has(l)&&n.push(l);const i={requiredFeatures:n,requiredLimits:e.requiredLimits},a=await s.requestDevice(i),c=e.context!==void 0?e.context:this.domElement.getContext("webgpu");this._adapter=s,this._device=a,this._context=c,this._configureContext(),this._info=new eo,this._properties=new so,this._attributes=new Ki(a),this._geometries=new ji(this._attributes,this._properties,this._info),this._textures=new Du(a,this._properties,this._info),this._utils=new Ul(this),this._nodes=new wl(this,this._properties),this._objects=new Xi(this,this._nodes,this._geometries,this._info),this._computePipelines=new fo(a,this._nodes),this._renderPipelines=new ho(a,this._nodes,this._utils),this._bindings=this._renderPipelines.bindings=new mo(a,this._info,this._properties,this._textures,this._renderPipelines,this._computePipelines,this._attributes,this._nodes),this._renderLists=new _u,this._renderStates=new Bu,this._background=new ku(this,this._properties),this._setupColorBuffer(),this._setupDepthBuffer(),this._animation.setNodes(this._nodes),this._animation.start(),this._initialized=!0}async render(e,t){this._initialized===!1&&await this.init();const s=this._nodes.nodeFrame,r=s.renderId,n=this._currentRenderState,i=this._renderStates.get(e,t),a=this._renderTarget;this._currentRenderState=i,s.renderId++,this._animation.isAnimating===!1&&s.update(),e.matrixWorldAutoUpdate===!0&&e.updateMatrixWorld(),t.parent===null&&t.matrixWorldAutoUpdate===!0&&t.updateMatrixWorld(),this._info.autoReset===!0&&this._info.reset(),Be.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),lt.setFromProjectionMatrix(Be);const c=this._renderLists.get(e,t);c.init(),this._projectObject(e,t,0,c),c.finish(),this.sortObjects===!0&&c.sort(this._opaqueSort,this._transparentSort),i.descriptorGPU={colorAttachments:[{view:null}],depthStencilAttachment:{view:null}};const l=i.descriptorGPU.colorAttachments[0],d=i.descriptorGPU.depthStencilAttachment;if(a!==null){this._textures.initRenderTarget(a);const G=this._properties.get(a);l.view=G.colorTextureGPU.createView(),d.view=G.depthTextureGPU.createView(),i.stencil=a.depthTexture?a.depthTexture.format!==ps:!0}else this._parameters.antialias===!0?(l.view=this._colorBuffer.createView(),l.resolveTarget=this._context.getCurrentTexture().createView()):(l.view=this._context.getCurrentTexture().createView(),l.resolveTarget=void 0),d.view=this._depthBuffer.createView();this._nodes.updateEnvironment(e),this._nodes.updateFog(e),this._nodes.updateBackground(e),this._nodes.updateToneMapping(),this._background.update(e,c,i);const f=this._device;i.encoderGPU=f.createCommandEncoder({}),i.currentPassGPU=i.encoderGPU.beginRenderPass(i.descriptorGPU);const m=this._viewport;if(m!==null){const G=Math.floor(m.width*this._pixelRatio),I=Math.floor(m.height*this._pixelRatio);i.currentPassGPU.setViewport(m.x,m.y,G,I,m.minDepth,m.maxDepth)}const y=this._scissor;if(y!==null){const G=Math.floor(y.width*this._pixelRatio),I=Math.floor(y.height*this._pixelRatio);i.currentPassGPU.setScissorRect(y.x,y.y,G,I)}const A=c.opaque,b=c.transparent,M=c.lightsNode;A.length>0&&this._renderObjects(A,t,e,M,i),b.length>0&&this._renderObjects(b,t,e,M,i),i.currentPassGPU.end(),f.queue.submit([i.encoderGPU.finish()]),s.renderId=r,this._currentRenderState=n}setAnimationLoop(e){this._initialized===!1&&this.init();const t=this._animation;t.setAnimationLoop(e),e===null?t.stop():t.start()}async getArrayBuffer(e){return await this._attributes.getArrayBuffer(e)}getContext(){return this._context}getPixelRatio(){return this._pixelRatio}getDrawingBufferSize(e){return e.set(this._width*this._pixelRatio,this._height*this._pixelRatio).floor()}getSize(e){return e.set(this._width,this._height)}setPixelRatio(e=1){this._pixelRatio=e,this.setSize(this._width,this._height,!1)}setDrawingBufferSize(e,t,s){this._width=e,this._height=t,this._pixelRatio=s,this.domElement.width=Math.floor(e*s),this.domElement.height=Math.floor(t*s),this._configureContext(),this._setupColorBuffer(),this._setupDepthBuffer()}setSize(e,t,s=!0){this._width=e,this._height=t,this.domElement.width=Math.floor(e*this._pixelRatio),this.domElement.height=Math.floor(t*this._pixelRatio),s===!0&&(this.domElement.style.width=e+"px",this.domElement.style.height=t+"px"),this._configureContext(),this._setupColorBuffer(),this._setupDepthBuffer()}setOpaqueSort(e){this._opaqueSort=e}setTransparentSort(e){this._transparentSort=e}getScissor(e){const t=this._scissor;return e.x=t.x,e.y=t.y,e.width=t.width,e.height=t.height,e}setScissor(e,t,s,r){e===null?this._scissor=null:this._scissor={x:e,y:t,width:s,height:r}}copyFramebufferToRenderTarget(e){const t=this._currentRenderState,{encoderGPU:s,descriptorGPU:r}=t,n=e.texture;n.internalFormat=h.BGRA8Unorm,this._textures.initRenderTarget(e);const i=this._context.getCurrentTexture(),a=this._textures.getTextureGPU(n);t.currentPassGPU.end(),s.copyTextureToTexture({texture:i},{texture:a},[n.image.width,n.image.height]),r.colorAttachments[0].loadOp=q.Load,t.depth&&(r.depthStencilAttachment.depthLoadOp=q.Load),t.stencil&&(r.depthStencilAttachment.stencilLoadOp=q.Load),t.currentPassGPU=s.beginRenderPass(r)}getViewport(e){const t=this._viewport;return e.x=t.x,e.y=t.y,e.width=t.width,e.height=t.height,e.minDepth=t.minDepth,e.maxDepth=t.maxDepth,e}setViewport(e,t,s,r,n=0,i=1){e===null?this._viewport=null:this._viewport={x:e,y:t,width:s,height:r,minDepth:n,maxDepth:i}}getClearColor(e){return e.copy(this._clearColor)}setClearColor(e,t=1){this._clearColor.set(e),this._clearAlpha=t}getClearAlpha(){return this._clearAlpha}setClearAlpha(e){this._clearAlpha=e}getClearDepth(){return this._clearDepth}setClearDepth(e){this._clearDepth=e}getClearStencil(){return this._clearStencil}setClearStencil(e){this._clearStencil=e}clear(){this._background&&this._background.clear()}dispose(){this._objects.dispose(),this._properties.dispose(),this._renderPipelines.dispose(),this._computePipelines.dispose(),this._nodes.dispose(),this._bindings.dispose(),this._info.dispose(),this._renderLists.dispose(),this._renderStates.dispose(),this._textures.dispose(),this.setRenderTarget(null),this.setAnimationLoop(null)}setRenderTarget(e){this._renderTarget=e}async compute(...e){this._initialized===!1&&await this.init();const t=this._device,s=this._computePipelines,r=t.createCommandEncoder({}),n=r.beginComputePass();for(const i of e){s.has(i)===!1&&i.onInit({renderer:this});const a=s.get(i);n.setPipeline(a);const c=this._bindings.getForCompute(i).group;this._bindings.update(i),n.setBindGroup(0,c),n.dispatchWorkgroups(i.dispatchCount)}n.end(),t.queue.submit([r.finish()])}getRenderTarget(){return this._renderTarget}hasFeature(e){if(this._initialized===!1)throw new Error("THREE.WebGPURenderer: Renderer must be initialized before testing features.");if(Object.values(ht).includes(e)===!1)throw new Error("THREE.WebGPURenderer: Unknown WebGPU GPU feature: "+e);return this._adapter.features.has(e)}_projectObject(e,t,s,r){if(e.visible===!1)return;if(e.layers.test(t.layers)){if(e.isGroup)s=e.renderOrder;else if(e.isLOD)e.autoUpdate===!0&&e.update(t);else if(e.isLight)r.pushLight(e);else if(e.isSprite){if(!e.frustumCulled||lt.intersectsSprite(e)){this.sortObjects===!0&&Ce.setFromMatrixPosition(e.matrixWorld).applyMatrix4(Be);const a=e.geometry,c=e.material;c.visible&&r.push(e,a,c,s,Ce.z,null)}}else if(e.isLineLoop)console.error("THREE.WebGPURenderer: Objects of type THREE.LineLoop are not supported. Please use THREE.Line or THREE.LineSegments.");else if((e.isMesh||e.isLine||e.isPoints)&&(!e.frustumCulled||lt.intersectsObject(e))){const a=e.geometry,c=e.material;if(this.sortObjects===!0&&(a.boundingSphere===null&&a.computeBoundingSphere(),Ce.copy(a.boundingSphere.center).applyMatrix4(e.matrixWorld).applyMatrix4(Be)),Array.isArray(c)){const l=a.groups;for(let d=0,f=l.length;d<f;d++){const m=l[d],y=c[m.materialIndex];y&&y.visible&&r.push(e,a,y,s,Ce.z,m)}}else c.visible&&r.push(e,a,c,s,Ce.z,null)}}const i=e.children;for(let a=0,c=i.length;a<c;a++)this._projectObject(i[a],t,s,r)}_renderObjects(e,t,s,r){for(let n=0,i=e.length;n<i;n++){const a=e[n],{object:c,geometry:l,material:d,group:f}=a;if(t.isArrayCamera){const m=t.cameras;for(let y=0,A=m.length;y<A;y++){const b=m[y];if(c.layers.test(b.layers)){const M=b.viewport,G=M.minDepth===void 0?0:M.minDepth,I=M.maxDepth===void 0?1:M.maxDepth;this._currentRenderState.currentPassGPU.setViewport(M.x,M.y,M.width,M.height,G,I),this._renderObject(c,s,b,l,d,f,r)}}}else this._renderObject(c,s,t,l,d,f,r)}}_renderObject(e,t,s,r,n,i,a){n=t.overrideMaterial!==null?t.overrideMaterial:n,e.onBeforeRender(this,t,s,r,n,i);const c=this._getRenderObject(e,n,t,s,a);this._nodes.updateBefore(c);const l=this._currentRenderState.currentPassGPU,d=this._info;e.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse,e.matrixWorld),e.normalMatrix.getNormalMatrix(e.modelViewMatrix),this._nodes.update(c),this._geometries.update(c),this._bindings.update(c);const f=this._renderPipelines.get(c);l.setPipeline(f.pipeline);const m=this._bindings.get(c).group;l.setBindGroup(0,m);const y=this._geometries.getIndex(c),A=y!==null;A===!0&&this._setupIndexBuffer(y,l),this._setupVertexBuffers(r.attributes,l,f);const b=r.drawRange,M=b.start,G=r.isInstancedBufferGeometry?r.instanceCount:e.isInstancedMesh?e.count:1;if(A===!0){const I=b.count!==1/0?b.count:y.count;l.drawIndexed(I,G,M,0,0),d.update(e,I,G)}else{const I=r.attributes.position,Pe=b.count!==1/0?b.count:I.count;l.draw(Pe,G,M,0),d.update(e,Pe,G)}}_getRenderObject(e,t,s,r,n){const i=this._objects.get(e,t,s,r,n),a=this._properties.get(i);if(a.initialized!==!0){a.initialized=!0;const l=()=>{this._renderPipelines.remove(i),this._nodes.remove(i),this._properties.remove(i),this._objects.remove(e,t,s,r,n),i.material.removeEventListener("dispose",l)};i.material.addEventListener("dispose",l)}const c=i.getCacheKey();return a.cacheKey!==c&&(a.cacheKey=c,this._renderPipelines.remove(i),this._nodes.remove(i)),i}_setupIndexBuffer(e,t){const s=this._attributes.get(e).buffer,r=e.array instanceof Uint16Array?we.Uint16:we.Uint32;t.setIndexBuffer(s,r)}_setupVertexBuffers(e,t,s){const r=s.shaderAttributes;for(const n of r){const i=n.name,a=n.slot,c=e[i];if(c!==void 0){const l=this._attributes.get(c).buffer;t.setVertexBuffer(a,l)}}}_setupColorBuffer(){this._device&&(this._colorBuffer&&this._colorBuffer.destroy(),this._colorBuffer=this._device.createTexture({label:"colorBuffer",size:{width:Math.floor(this._width*this._pixelRatio),height:Math.floor(this._height*this._pixelRatio),depthOrArrayLayers:1},sampleCount:this._parameters.sampleCount,format:h.BGRA8Unorm,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC}))}_setupDepthBuffer(){this._device&&(this._depthBuffer&&this._depthBuffer.destroy(),this._depthBuffer=this._device.createTexture({label:"depthBuffer",size:{width:Math.floor(this._width*this._pixelRatio),height:Math.floor(this._height*this._pixelRatio),depthOrArrayLayers:1},sampleCount:this._parameters.sampleCount,format:h.Depth24PlusStencil8,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC}))}_configureContext(){const e=this._device;e&&this._context.configure({device:e,format:h.BGRA8Unorm,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC,alphaMode:"premultiplied"})}_createCanvasElement(){const e=document.createElementNS("http://www.w3.org/1999/xhtml","canvas");return e.style.display="block",e}}const Gl=Ml,_l=`import { three } from 'trzy'
import WebGPU from 'three/examples/jsm/capabilities/WebGPU'
import WebGPURenderer from 'three/examples/jsm/renderers/webgpu/WebGPURenderer'

const renderer = WebGPU.isAvailable() ? new WebGPURenderer() : undefined
const { update } = three({ renderer })

update(() => {
  
})
`,Fl={title:"WebGPU",parameters:{docs:{description:{component:""},source:{code:_l}}}},Pl=()=>{const{canvas:o,camera:e,scene:t,renderer:s,update:r}=Ii({renderer:Di.isAvailable()?new Gl:void 0});return console.log(s),Oi({canvas:o,camera:e,scene:t,update:r,controls:!0,webGPU:!0}),o},Fe={render:Pl};var os,as,cs;Fe.parameters={...Fe.parameters,docs:{...(os=Fe.parameters)==null?void 0:os.docs,source:{originalSource:`{
  render
}`,...(cs=(as=Fe.parameters)==null?void 0:as.docs)==null?void 0:cs.source}}};const Ll=["Primary"];export{Fe as Primary,Ll as __namedExportsOrder,Fl as default};
//# sourceMappingURL=index.stories-312e2018.js.map
