var mn=Object.defineProperty;var xn=(e,n,t)=>n in e?mn(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t;var z=(e,n,t)=>(xn(e,typeof n!="symbol"?n+"":n,t),t),wn=(e,n,t)=>{if(!n.has(e))throw TypeError("Cannot "+t)};var K=(e,n,t)=>(wn(e,n,"read from private field"),t?t.call(e):n.get(e)),Ht=(e,n,t)=>{if(n.has(e))throw TypeError("Cannot add the same private member more than once");n instanceof WeakSet?n.add(e):n.set(e,t)};import{y as bn,e as k,R as ln,z as fn,V as I,F as un,L as O,T as ft,J as An,v as dt,K as Pn,D as Tn,N as ot,U as Xt,W as vn,b as pn,X as Yt,s as Bn,u as gn,d as Sn}from"./setup-bf23c97c.js";import{s as Mn}from"./strawberry-9ab81ec5.js";var q;class In extends bn{constructor(t){super();z(this,"camera");z(this,"raycaster");z(this,"objects",[]);z(this,"pointerDown",new k);z(this,"pointerUp",new k);z(this,"pointerMove",new k);z(this,"recursive",!0);z(this,"renderer");Ht(this,q,{click:0,move:0});z(this,"onPointerDown",t=>{this.getNormalizedCoordinates(t,this.pointerDown)});z(this,"onPointerUp",t=>{if(this.camera===void 0||(this.getNormalizedCoordinates(t,this.pointerUp),this.pointerDown.sub(this.pointerUp).lengthSq()>.001))return;this.raycaster.setFromCamera(this.pointerUp,this.camera);const s=this.raycaster.intersectObjects(this.objects,this.recursive);this.dispatchEvent({type:"click",intersections:s})});z(this,"onPointerMove",t=>{if(this.camera===void 0)return;this.getNormalizedCoordinates(t,this.pointerMove),this.raycaster.setFromCamera(this.pointerMove,this.camera);const s=this.raycaster.intersectObjects(this.objects,this.recursive);this.dispatchEvent({type:"move",intersections:s})});this.camera=t.camera,this.renderer=t.renderer,this.raycaster=t.raycaster??new ln,this.objects=t.objects??(t.scene?[t.scene]:[]),this.recursive=t.recursive??!0}on(t,s){super.addEventListener(t,s);const i=this.renderer.domElement;t==="move"&&K(this,q).move===0?i.addEventListener("pointermove",this.onPointerMove,{passive:!0}):t==="click"&&K(this,q).click===0&&(i.addEventListener("pointerdown",this.onPointerDown,{passive:!0}),i.addEventListener("pointerup",this.onPointerUp,{passive:!0})),K(this,q)[t]+=1}off(t,s){super.removeEventListener(t,s);const i=this.renderer.domElement;K(this,q)[t]-=1,t==="move"&&K(this,q).move<=0?i.removeEventListener("pointermove",this.onPointerMove):t==="click"&&K(this,q).click<=0&&(i.addEventListener("pointerdown",this.onPointerDown,{passive:!0}),i.addEventListener("pointerup",this.onPointerUp,{passive:!0}))}getNormalizedCoordinates(t,s){const i=this.renderer.domElement,o=i.getBoundingClientRect();s.x=(t.clientX-o.x)/i.clientWidth*2-1,s.y=-((t.clientY-o.y)/i.clientHeight*2)+1}dispose(){const t=this.renderer.domElement;t.removeEventListener("pointerdown",this.onPointerDown),t.removeEventListener("pointerup",this.onPointerUp),t.removeEventListener("pointermove",this.onPointerMove)}}q=new WeakMap;const dn=0,Cn=1,En=2,Zt=2,Lt=1.25,Wt=1,It=6*4+4+4,Nt=65535,Fn=Math.pow(2,-24);class wt{constructor(){}}function R(e,n,t){return t.min.x=n[e],t.min.y=n[e+1],t.min.z=n[e+2],t.max.x=n[e+3],t.max.y=n[e+4],t.max.z=n[e+5],t}function Ln(e){e[0]=e[1]=e[2]=1/0,e[3]=e[4]=e[5]=-1/0}function Kt(e){let n=-1,t=-1/0;for(let s=0;s<3;s++){const i=e[s+3]-e[s];i>t&&(t=i,n=s)}return n}function $t(e,n){n.set(e)}function Jt(e,n,t){let s,i;for(let o=0;o<3;o++){const r=o+3;s=e[o],i=n[o],t[o]=s<i?s:i,s=e[r],i=n[r],t[r]=s>i?s:i}}function bt(e,n,t){for(let s=0;s<3;s++){const i=n[e+2*s],o=n[e+2*s+1],r=i-o,a=i+o;r<t[s]&&(t[s]=r),a>t[s+3]&&(t[s+3]=a)}}function ct(e){const n=e[3]-e[0],t=e[4]-e[1],s=e[5]-e[2];return 2*(n*t+t*s+s*n)}function zn(e,n){if(!e.index){const t=e.attributes.position.count,s=n.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;let i;t>65535?i=new Uint32Array(new s(4*t)):i=new Uint16Array(new s(2*t)),e.setIndex(new fn(i,1));for(let o=0;o<t;o++)i[o]=o}}function Un(e){if(!e.groups||!e.groups.length)return[{offset:0,count:e.index.count/3}];const n=[],t=new Set;for(const i of e.groups)t.add(i.start),t.add(i.start+i.count);const s=Array.from(t.values()).sort((i,o)=>i-o);for(let i=0;i<s.length-1;i++){const o=s[i],r=s[i+1];n.push({offset:o/3,count:(r-o)/3})}return n}function zt(e,n,t,s,i=null){let o=1/0,r=1/0,a=1/0,c=-1/0,f=-1/0,u=-1/0,d=1/0,l=1/0,h=1/0,P=-1/0,g=-1/0,m=-1/0;const p=i!==null;for(let x=n*6,y=(n+t)*6;x<y;x+=6){const b=e[x+0],w=e[x+1],A=b-w,v=b+w;A<o&&(o=A),v>c&&(c=v),p&&b<d&&(d=b),p&&b>P&&(P=b);const B=e[x+2],T=e[x+3],S=B-T,M=B+T;S<r&&(r=S),M>f&&(f=M),p&&B<l&&(l=B),p&&B>g&&(g=B);const C=e[x+4],E=e[x+5],F=C-E,L=C+E;F<a&&(a=F),L>u&&(u=L),p&&C<h&&(h=C),p&&C>m&&(m=C)}s[0]=o,s[1]=r,s[2]=a,s[3]=c,s[4]=f,s[5]=u,p&&(i[0]=d,i[1]=l,i[2]=h,i[3]=P,i[4]=g,i[5]=m)}function Dn(e,n,t,s){let i=1/0,o=1/0,r=1/0,a=-1/0,c=-1/0,f=-1/0;for(let u=n*6,d=(n+t)*6;u<d;u+=6){const l=e[u+0];l<i&&(i=l),l>a&&(a=l);const h=e[u+2];h<o&&(o=h),h>c&&(c=h);const P=e[u+4];P<r&&(r=P),P>f&&(f=P)}s[0]=i,s[1]=o,s[2]=r,s[3]=a,s[4]=c,s[5]=f}function _n(e,n,t,s,i){let o=t,r=t+s-1;const a=i.pos,c=i.axis*2;for(;;){for(;o<=r&&n[o*6+c]<a;)o++;for(;o<=r&&n[r*6+c]>=a;)r--;if(o<r){for(let f=0;f<3;f++){let u=e[o*3+f];e[o*3+f]=e[r*3+f],e[r*3+f]=u;let d=n[o*6+f*2+0];n[o*6+f*2+0]=n[r*6+f*2+0],n[r*6+f*2+0]=d;let l=n[o*6+f*2+1];n[o*6+f*2+1]=n[r*6+f*2+1],n[r*6+f*2+1]=l}o++,r--}else return o}}const N=32,Rn=(e,n)=>e.candidate-n.candidate,X=new Array(N).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),At=new Float32Array(6);function Vn(e,n,t,s,i,o){let r=-1,a=0;if(o===dn)r=Kt(n),r!==-1&&(a=(n[r]+n[r+3])/2);else if(o===Cn)r=Kt(e),r!==-1&&(a=Nn(t,s,i,r));else if(o===En){const c=ct(e);let f=Lt*i;const u=s*6,d=(s+i)*6;for(let l=0;l<3;l++){const h=n[l],m=(n[l+3]-h)/N;if(i<N/4){const p=[...X];p.length=i;let x=0;for(let b=u;b<d;b+=6,x++){const w=p[x];w.candidate=t[b+2*l],w.count=0;const{bounds:A,leftCacheBounds:v,rightCacheBounds:B}=w;for(let T=0;T<3;T++)B[T]=1/0,B[T+3]=-1/0,v[T]=1/0,v[T+3]=-1/0,A[T]=1/0,A[T+3]=-1/0;bt(b,t,A)}p.sort(Rn);let y=i;for(let b=0;b<y;b++){const w=p[b];for(;b+1<y&&p[b+1].candidate===w.candidate;)p.splice(b+1,1),y--}for(let b=u;b<d;b+=6){const w=t[b+2*l];for(let A=0;A<y;A++){const v=p[A];w>=v.candidate?bt(b,t,v.rightCacheBounds):(bt(b,t,v.leftCacheBounds),v.count++)}}for(let b=0;b<y;b++){const w=p[b],A=w.count,v=i-w.count,B=w.leftCacheBounds,T=w.rightCacheBounds;let S=0;A!==0&&(S=ct(B)/c);let M=0;v!==0&&(M=ct(T)/c);const C=Wt+Lt*(S*A+M*v);C<f&&(r=l,f=C,a=w.candidate)}}else{for(let y=0;y<N;y++){const b=X[y];b.count=0,b.candidate=h+m+y*m;const w=b.bounds;for(let A=0;A<3;A++)w[A]=1/0,w[A+3]=-1/0}for(let y=u;y<d;y+=6){let A=~~((t[y+2*l]-h)/m);A>=N&&(A=N-1);const v=X[A];v.count++,bt(y,t,v.bounds)}const p=X[N-1];$t(p.bounds,p.rightCacheBounds);for(let y=N-2;y>=0;y--){const b=X[y],w=X[y+1];Jt(b.bounds,w.rightCacheBounds,b.rightCacheBounds)}let x=0;for(let y=0;y<N-1;y++){const b=X[y],w=b.count,A=b.bounds,B=X[y+1].rightCacheBounds;w!==0&&(x===0?$t(A,At):Jt(A,At,At)),x+=w;let T=0,S=0;x!==0&&(T=ct(At)/c);const M=i-x;M!==0&&(S=ct(B)/c);const C=Wt+Lt*(T*x+S*M);C<f&&(r=l,f=C,a=b.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${o} used.`);return{axis:r,pos:a}}function Nn(e,n,t,s){let i=0;for(let o=n,r=n+t;o<r;o++)i+=e[o*6+s*2];return i/t}function qn(e,n){Ln(n);const t=e.attributes.position,s=e.index.array,i=s.length/3,o=new Float32Array(i*6),r=t.normalized,a=t.array,c=t.offset||0;let f=3;t.isInterleavedBufferAttribute&&(f=t.data.stride);const u=["getX","getY","getZ"];for(let d=0;d<i;d++){const l=d*3,h=d*6;let P,g,m;r?(P=s[l+0],g=s[l+1],m=s[l+2]):(P=s[l+0]*f+c,g=s[l+1]*f+c,m=s[l+2]*f+c);for(let p=0;p<3;p++){let x,y,b;r?(x=t[u[p]](P),y=t[u[p]](g),b=t[u[p]](m)):(x=a[P+p],y=a[g+p],b=a[m+p]);let w=x;y<w&&(w=y),b<w&&(w=b);let A=x;y>A&&(A=y),b>A&&(A=b);const v=(A-w)/2,B=p*2;o[h+B+0]=w+v,o[h+B+1]=v+(Math.abs(w)+v)*Fn,w<n[p]&&(n[p]=w),A>n[p+3]&&(n[p+3]=A)}}return o}function kn(e,n){function t(p){l&&l(p/h)}function s(p,x,y,b=null,w=0){if(!P&&w>=c&&(P=!0,f&&(console.warn(`MeshBVH: Max depth of ${c} reached when generating BVH. Consider increasing maxDepth.`),console.warn(e))),y<=u||w>=c)return t(x+y),p.offset=x,p.count=y,p;const A=Vn(p.boundingData,b,r,x,y,d);if(A.axis===-1)return t(x+y),p.offset=x,p.count=y,p;const v=_n(a,r,x,y,A);if(v===x||v===x+y)t(x+y),p.offset=x,p.count=y;else{p.splitAxis=A.axis;const B=new wt,T=x,S=v-x;p.left=B,B.boundingData=new Float32Array(6),zt(r,T,S,B.boundingData,o),s(B,T,S,o,w+1);const M=new wt,C=v,E=y-S;p.right=M,M.boundingData=new Float32Array(6),zt(r,C,E,M.boundingData,o),s(M,C,E,o,w+1)}return p}zn(e,n);const i=new Float32Array(6),o=new Float32Array(6),r=qn(e,i),a=e.index.array,c=n.maxDepth,f=n.verbose,u=n.maxLeafTris,d=n.strategy,l=n.onProgress,h=e.index.count/3;let P=!1;const g=[],m=Un(e);if(m.length===1){const p=m[0],x=new wt;x.boundingData=i,Dn(r,p.offset,p.count,o),s(x,p.offset,p.count,o),g.push(x)}else for(let p of m){const x=new wt;x.boundingData=new Float32Array(6),zt(r,p.offset,p.count,x.boundingData,o),s(x,p.offset,p.count,o),g.push(x)}return g}function On(e,n){const t=kn(e,n);let s,i,o;const r=[],a=n.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;for(let u=0;u<t.length;u++){const d=t[u];let l=c(d);const h=new a(It*l);s=new Float32Array(h),i=new Uint32Array(h),o=new Uint16Array(h),f(0,d),r.push(h)}return r;function c(u){return u.count?1:1+c(u.left)+c(u.right)}function f(u,d){const l=u/4,h=u/2,P=!!d.count,g=d.boundingData;for(let m=0;m<6;m++)s[l+m]=g[m];if(P){const m=d.offset,p=d.count;return i[l+6]=m,o[h+14]=p,o[h+15]=Nt,u+It}else{const m=d.left,p=d.right,x=d.splitAxis;let y;if(y=f(u+It,m),y/4>Math.pow(2,32))throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return i[l+6]=y/4,y=f(y,p),i[l+7]=x,y}}}class j{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(n,t){let s=1/0,i=-1/0;for(let o=0,r=n.length;o<r;o++){const c=n[o][t];s=c<s?c:s,i=c>i?c:i}this.min=s,this.max=i}setFromPoints(n,t){let s=1/0,i=-1/0;for(let o=0,r=t.length;o<r;o++){const a=t[o],c=n.dot(a);s=c<s?c:s,i=c>i?c:i}this.min=s,this.max=i}isSeparated(n){return this.min>n.max||n.min>this.max}}j.prototype.setFromBox=function(){const e=new I;return function(t,s){const i=s.min,o=s.max;let r=1/0,a=-1/0;for(let c=0;c<=1;c++)for(let f=0;f<=1;f++)for(let u=0;u<=1;u++){e.x=i.x*c+o.x*(1-c),e.y=i.y*f+o.y*(1-f),e.z=i.z*u+o.z*(1-u);const d=t.dot(e);r=Math.min(d,r),a=Math.max(d,a)}this.min=r,this.max=a}}();const jn=function(){const e=new I,n=new I,t=new I;return function(i,o,r){const a=i.start,c=e,f=o.start,u=n;t.subVectors(a,f),e.subVectors(i.end,i.start),n.subVectors(o.end,o.start);const d=t.dot(u),l=u.dot(c),h=u.dot(u),P=t.dot(c),m=c.dot(c)*h-l*l;let p,x;m!==0?p=(d*l-P*h)/m:p=0,x=(d+p*l)/h,r.x=p,r.y=x}}(),jt=function(){const e=new k,n=new I,t=new I;return function(i,o,r,a){jn(i,o,e);let c=e.x,f=e.y;if(c>=0&&c<=1&&f>=0&&f<=1){i.at(c,r),o.at(f,a);return}else if(c>=0&&c<=1){f<0?o.at(0,a):o.at(1,a),i.closestPointToPoint(a,!0,r);return}else if(f>=0&&f<=1){c<0?i.at(0,r):i.at(1,r),o.closestPointToPoint(r,!0,a);return}else{let u;c<0?u=i.start:u=i.end;let d;f<0?d=o.start:d=o.end;const l=n,h=t;if(i.closestPointToPoint(d,!0,n),o.closestPointToPoint(u,!0,t),l.distanceToSquared(d)<=h.distanceToSquared(u)){r.copy(l),a.copy(d);return}else{r.copy(u),a.copy(h);return}}}}(),Hn=function(){const e=new I,n=new I,t=new un,s=new O;return function(o,r){const{radius:a,center:c}=o,{a:f,b:u,c:d}=r;if(s.start=f,s.end=u,s.closestPointToPoint(c,!0,e).distanceTo(c)<=a||(s.start=f,s.end=d,s.closestPointToPoint(c,!0,e).distanceTo(c)<=a)||(s.start=u,s.end=d,s.closestPointToPoint(c,!0,e).distanceTo(c)<=a))return!0;const g=r.getPlane(t);if(Math.abs(g.distanceToPoint(c))<=a){const p=g.projectPoint(c,n);if(r.containsPoint(p))return!0}return!1}}(),Xn=1e-15;function Ut(e){return Math.abs(e)<Xn}class H extends ft{constructor(...n){super(...n),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new I),this.satBounds=new Array(4).fill().map(()=>new j),this.points=[this.a,this.b,this.c],this.sphere=new An,this.plane=new un,this.needsUpdate=!0}intersectsSphere(n){return Hn(n,this)}update(){const n=this.a,t=this.b,s=this.c,i=this.points,o=this.satAxes,r=this.satBounds,a=o[0],c=r[0];this.getNormal(a),c.setFromPoints(a,i);const f=o[1],u=r[1];f.subVectors(n,t),u.setFromPoints(f,i);const d=o[2],l=r[2];d.subVectors(t,s),l.setFromPoints(d,i);const h=o[3],P=r[3];h.subVectors(s,n),P.setFromPoints(h,i),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(a,n),this.needsUpdate=!1}}H.prototype.closestPointToSegment=function(){const e=new I,n=new I,t=new O;return function(i,o=null,r=null){const{start:a,end:c}=i,f=this.points;let u,d=1/0;for(let l=0;l<3;l++){const h=(l+1)%3;t.start.copy(f[l]),t.end.copy(f[h]),jt(t,i,e,n),u=e.distanceToSquared(n),u<d&&(d=u,o&&o.copy(e),r&&r.copy(n))}return this.closestPointToPoint(a,e),u=a.distanceToSquared(e),u<d&&(d=u,o&&o.copy(e),r&&r.copy(a)),this.closestPointToPoint(c,e),u=c.distanceToSquared(e),u<d&&(d=u,o&&o.copy(e),r&&r.copy(c)),Math.sqrt(d)}}();H.prototype.intersectsTriangle=function(){const e=new H,n=new Array(3),t=new Array(3),s=new j,i=new j,o=new I,r=new I,a=new I,c=new I,f=new I,u=new O,d=new O,l=new O,h=new I;function P(g,m,p){const x=g.points;let y=0,b=-1;for(let w=0;w<3;w++){const{start:A,end:v}=u;A.copy(x[w]),v.copy(x[(w+1)%3]),u.delta(r);const B=Ut(m.distanceToPoint(A));if(Ut(m.normal.dot(r))&&B){p.copy(u),y=2;break}const T=m.intersectLine(u,h);if(!T&&B&&h.copy(A),(T||B)&&!Ut(h.distanceTo(v))){if(y<=1)(y===1?p.start:p.end).copy(h),B&&(b=y);else if(y>=2){(b===1?p.start:p.end).copy(h),y=2;break}if(y++,y===2&&b===-1)break}}return y}return function(m,p=null,x=!1){this.needsUpdate&&this.update(),m.isExtendedTriangle?m.needsUpdate&&m.update():(e.copy(m),e.update(),m=e);const y=this.plane,b=m.plane;if(Math.abs(y.normal.dot(b.normal))>1-1e-10){const w=this.satBounds,A=this.satAxes;t[0]=m.a,t[1]=m.b,t[2]=m.c;for(let T=0;T<4;T++){const S=w[T],M=A[T];if(s.setFromPoints(M,t),S.isSeparated(s))return!1}const v=m.satBounds,B=m.satAxes;n[0]=this.a,n[1]=this.b,n[2]=this.c;for(let T=0;T<4;T++){const S=v[T],M=B[T];if(s.setFromPoints(M,n),S.isSeparated(s))return!1}for(let T=0;T<4;T++){const S=A[T];for(let M=0;M<4;M++){const C=B[M];if(o.crossVectors(S,C),s.setFromPoints(o,n),i.setFromPoints(o,t),s.isSeparated(i))return!1}}return p&&(x||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),p.start.set(0,0,0),p.end.set(0,0,0)),!0}else{const w=P(this,b,d);if(w===1&&m.containsPoint(d.end))return p&&(p.start.copy(d.end),p.end.copy(d.end)),!0;if(w!==2)return!1;const A=P(m,y,l);if(A===1&&this.containsPoint(l.end))return p&&(p.start.copy(l.end),p.end.copy(l.end)),!0;if(A!==2)return!1;if(d.delta(a),l.delta(c),a.dot(c)<0){let E=l.start;l.start=l.end,l.end=E}const v=d.start.dot(a),B=d.end.dot(a),T=l.start.dot(a),S=l.end.dot(a),M=B<T,C=v<S;return v!==S&&T!==B&&M===C?!1:(p&&(f.subVectors(d.start,l.start),f.dot(a)>0?p.start.copy(d.start):p.start.copy(l.start),f.subVectors(d.end,l.end),f.dot(a)<0?p.end.copy(d.end):p.end.copy(l.end)),!0)}}}();H.prototype.distanceToPoint=function(){const e=new I;return function(t){return this.closestPointToPoint(t,e),t.distanceTo(e)}}();H.prototype.distanceToTriangle=function(){const e=new I,n=new I,t=["a","b","c"],s=new O,i=new O;return function(r,a=null,c=null){const f=a||c?s:null;if(this.intersectsTriangle(r,f))return(a||c)&&(a&&f.getCenter(a),c&&f.getCenter(c)),0;let u=1/0;for(let d=0;d<3;d++){let l;const h=t[d],P=r[h];this.closestPointToPoint(P,e),l=P.distanceToSquared(e),l<u&&(u=l,a&&a.copy(e),c&&c.copy(P));const g=this[h];r.closestPointToPoint(g,e),l=g.distanceToSquared(e),l<u&&(u=l,a&&a.copy(g),c&&c.copy(e))}for(let d=0;d<3;d++){const l=t[d],h=t[(d+1)%3];s.set(this[l],this[h]);for(let P=0;P<3;P++){const g=t[P],m=t[(P+1)%3];i.set(r[g],r[m]),jt(s,i,e,n);const p=e.distanceToSquared(n);p<u&&(u=p,a&&a.copy(e),c&&c.copy(n))}}return Math.sqrt(u)}}();class V{constructor(n,t,s){this.isOrientedBox=!0,this.min=new I,this.max=new I,this.matrix=new dt,this.invMatrix=new dt,this.points=new Array(8).fill().map(()=>new I),this.satAxes=new Array(3).fill().map(()=>new I),this.satBounds=new Array(3).fill().map(()=>new j),this.alignedSatBounds=new Array(3).fill().map(()=>new j),this.needsUpdate=!1,n&&this.min.copy(n),t&&this.max.copy(t),s&&this.matrix.copy(s)}set(n,t,s){this.min.copy(n),this.max.copy(t),this.matrix.copy(s),this.needsUpdate=!0}copy(n){this.min.copy(n.min),this.max.copy(n.max),this.matrix.copy(n.matrix),this.needsUpdate=!0}}V.prototype.update=function(){return function(){const n=this.matrix,t=this.min,s=this.max,i=this.points;for(let f=0;f<=1;f++)for(let u=0;u<=1;u++)for(let d=0;d<=1;d++){const l=1*f|2*u|4*d,h=i[l];h.x=f?s.x:t.x,h.y=u?s.y:t.y,h.z=d?s.z:t.z,h.applyMatrix4(n)}const o=this.satBounds,r=this.satAxes,a=i[0];for(let f=0;f<3;f++){const u=r[f],d=o[f],l=1<<f,h=i[l];u.subVectors(a,h),d.setFromPoints(u,i)}const c=this.alignedSatBounds;c[0].setFromPointsField(i,"x"),c[1].setFromPointsField(i,"y"),c[2].setFromPointsField(i,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();V.prototype.intersectsBox=function(){const e=new j;return function(t){this.needsUpdate&&this.update();const s=t.min,i=t.max,o=this.satBounds,r=this.satAxes,a=this.alignedSatBounds;if(e.min=s.x,e.max=i.x,a[0].isSeparated(e)||(e.min=s.y,e.max=i.y,a[1].isSeparated(e))||(e.min=s.z,e.max=i.z,a[2].isSeparated(e)))return!1;for(let c=0;c<3;c++){const f=r[c],u=o[c];if(e.setFromBox(f,t),u.isSeparated(e))return!1}return!0}}();V.prototype.intersectsTriangle=function(){const e=new H,n=new Array(3),t=new j,s=new j,i=new I;return function(r){this.needsUpdate&&this.update(),r.isExtendedTriangle?r.needsUpdate&&r.update():(e.copy(r),e.update(),r=e);const a=this.satBounds,c=this.satAxes;n[0]=r.a,n[1]=r.b,n[2]=r.c;for(let l=0;l<3;l++){const h=a[l],P=c[l];if(t.setFromPoints(P,n),h.isSeparated(t))return!1}const f=r.satBounds,u=r.satAxes,d=this.points;for(let l=0;l<3;l++){const h=f[l],P=u[l];if(t.setFromPoints(P,d),h.isSeparated(t))return!1}for(let l=0;l<3;l++){const h=c[l];for(let P=0;P<4;P++){const g=u[P];if(i.crossVectors(h,g),t.setFromPoints(i,n),s.setFromPoints(i,d),t.isSeparated(s))return!1}}return!0}}();V.prototype.closestPointToPoint=function(){return function(n,t){return this.needsUpdate&&this.update(),t.copy(n).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),t}}();V.prototype.distanceToPoint=function(){const e=new I;return function(t){return this.closestPointToPoint(t,e),t.distanceTo(e)}}();V.prototype.distanceToBox=function(){const e=["x","y","z"],n=new Array(12).fill().map(()=>new O),t=new Array(12).fill().map(()=>new O),s=new I,i=new I;return function(r,a=0,c=null,f=null){if(this.needsUpdate&&this.update(),this.intersectsBox(r))return(c||f)&&(r.getCenter(i),this.closestPointToPoint(i,s),r.closestPointToPoint(s,i),c&&c.copy(s),f&&f.copy(i)),0;const u=a*a,d=r.min,l=r.max,h=this.points;let P=1/0;for(let m=0;m<8;m++){const p=h[m];i.copy(p).clamp(d,l);const x=p.distanceToSquared(i);if(x<P&&(P=x,c&&c.copy(p),f&&f.copy(i),x<u))return Math.sqrt(x)}let g=0;for(let m=0;m<3;m++)for(let p=0;p<=1;p++)for(let x=0;x<=1;x++){const y=(m+1)%3,b=(m+2)%3,w=p<<y|x<<b,A=1<<m|p<<y|x<<b,v=h[w],B=h[A];n[g].set(v,B);const S=e[m],M=e[y],C=e[b],E=t[g],F=E.start,L=E.end;F[S]=d[S],F[M]=p?d[M]:l[M],F[C]=x?d[C]:l[M],L[S]=l[S],L[M]=p?d[M]:l[M],L[C]=x?d[C]:l[M],g++}for(let m=0;m<=1;m++)for(let p=0;p<=1;p++)for(let x=0;x<=1;x++){i.x=m?l.x:d.x,i.y=p?l.y:d.y,i.z=x?l.z:d.z,this.closestPointToPoint(i,s);const y=i.distanceToSquared(s);if(y<P&&(P=y,c&&c.copy(s),f&&f.copy(i),y<u))return Math.sqrt(y)}for(let m=0;m<12;m++){const p=n[m];for(let x=0;x<12;x++){const y=t[x];jt(p,y,s,i);const b=s.distanceToSquared(i);if(b<P&&(P=b,c&&c.copy(s),f&&f.copy(i),b<u))return Math.sqrt(b)}}return Math.sqrt(P)}}();const Q=new I,tt=new I,nt=new I,Pt=new k,Tt=new k,vt=new k,Gt=new I,Qt=new I,tn=new I,Bt=new I;function Yn(e,n,t,s,i,o){let r;return o===Pn?r=e.intersectTriangle(s,t,n,!0,i):r=e.intersectTriangle(n,t,s,o!==Tn,i),r===null?null:{distance:e.origin.distanceTo(i),point:i.clone()}}function Zn(e,n,t,s,i,o,r,a,c){Q.fromBufferAttribute(n,o),tt.fromBufferAttribute(n,r),nt.fromBufferAttribute(n,a);const f=Yn(e,Q,tt,nt,Bt,c);if(f){s&&(Pt.fromBufferAttribute(s,o),Tt.fromBufferAttribute(s,r),vt.fromBufferAttribute(s,a),f.uv=ft.getInterpolation(Bt,Q,tt,nt,Pt,Tt,vt,new k)),i&&(Pt.fromBufferAttribute(i,o),Tt.fromBufferAttribute(i,r),vt.fromBufferAttribute(i,a),f.uv1=ft.getInterpolation(Bt,Q,tt,nt,Pt,Tt,vt,new k)),t&&(Gt.fromBufferAttribute(t,o),Qt.fromBufferAttribute(t,r),tn.fromBufferAttribute(t,a),f.normal=ft.getInterpolation(Bt,Q,tt,nt,Gt,Qt,tn,new I),f.normal.dot(e.direction)>0&&f.normal.multiplyScalar(-1));const u={a:o,b:r,c:a,normal:new I,materialIndex:0};ft.getNormal(Q,tt,nt,u.normal),f.face=u,f.faceIndex=o}return f}function hn(e,n,t,s,i){const o=s*3,r=e.index.getX(o),a=e.index.getX(o+1),c=e.index.getX(o+2),{position:f,normal:u,uv:d,uv1:l}=e.attributes,h=Zn(t,f,u,d,l,r,a,c,n);return h?(h.faceIndex=s,i&&i.push(h),h):null}function Wn(e,n,t,s,i,o){for(let r=s,a=s+i;r<a;r++)hn(e,n,t,r,o)}function Kn(e,n,t,s,i){let o=1/0,r=null;for(let a=s,c=s+i;a<c;a++){const f=hn(e,n,t,a);f&&f.distance<o&&(r=f,o=f.distance)}return r}function nn(e,n,t){return e===null||(e.point.applyMatrix4(n.matrixWorld),e.distance=e.point.distanceTo(t.ray.origin),e.object=n,e.distance<t.near||e.distance>t.far)?null:e}function _(e,n,t,s){const i=e.a,o=e.b,r=e.c;let a=n,c=n+1,f=n+2;t&&(a=t.getX(n),c=t.getX(n+1),f=t.getX(n+2)),i.x=s.getX(a),i.y=s.getY(a),i.z=s.getZ(a),o.x=s.getX(c),o.y=s.getY(c),o.z=s.getZ(c),r.x=s.getX(f),r.y=s.getY(f),r.z=s.getZ(f)}function en(e,n,t,s,i,o,r){const a=t.index,c=t.attributes.position;for(let f=e,u=n+e;f<u;f++)if(_(r,f*3,a,c),r.needsUpdate=!0,s(r,f,i,o))return!0;return!1}class yn{constructor(n){this._getNewPrimitive=n,this._primitives=[]}getPrimitive(){const n=this._primitives;return n.length===0?this._getNewPrimitive():n.pop()}releasePrimitive(n){this._primitives.push(n)}}function Y(e,n){return n[e+15]===65535}function it(e,n){return n[e+6]}function ht(e,n){return n[e+14]}function yt(e){return e+8}function mt(e,n){return n[e+6]}function $n(e,n){return n[e+7]}const st=new ot,Et=new I,Jn=["x","y","z"];function qt(e,n,t,s,i){let o=e*2,r=rt,a=Z,c=W;if(Y(o,a)){const u=it(e,c),d=ht(o,a);Wn(n,t,s,u,d,i)}else{const u=yt(e);Ft(u,r,s,Et)&&qt(u,n,t,s,i);const d=mt(e,c);Ft(d,r,s,Et)&&qt(d,n,t,s,i)}}function kt(e,n,t,s){let i=e*2,o=rt,r=Z,a=W;if(Y(i,r)){const f=it(e,a),u=ht(i,r);return Kn(n,t,s,f,u)}else{const f=$n(e,a),u=Jn[f],l=s.direction[u]>=0;let h,P;l?(h=yt(e),P=mt(e,a)):(h=mt(e,a),P=yt(e));const m=Ft(h,o,s,Et)?kt(h,n,t,s):null;if(m){const y=m.point[u];if(l?y<=o[P+f]:y>=o[P+f+3])return m}const x=Ft(P,o,s,Et)?kt(P,n,t,s):null;return m&&x?m.distance<=x.distance?m:x:m||x||null}}const Gn=function(){let e,n;const t=[],s=new yn(()=>new ot);return function(...r){e=s.getPrimitive(),n=s.getPrimitive(),t.push(e,n);const a=i(...r);s.releasePrimitive(e),s.releasePrimitive(n),t.pop(),t.pop();const c=t.length;return c>0&&(n=t[c-1],e=t[c-2]),a};function i(o,r,a,c,f=null,u=0,d=0){function l(y){let b=y*2,w=Z,A=W;for(;!Y(b,w);)y=yt(y),b=y*2;return it(y,A)}function h(y){let b=y*2,w=Z,A=W;for(;!Y(b,w);)y=mt(y,A),b=y*2;return it(y,A)+ht(b,w)}let P=o*2,g=rt,m=Z,p=W;if(Y(P,m)){const y=it(o,p),b=ht(P,m);return R(o,g,e),c(y,b,!1,d,u+o,e)}else{const y=yt(o),b=mt(o,p);let w=y,A=b,v,B,T,S;if(f&&(T=e,S=n,R(w,g,T),R(A,g,S),v=f(T),B=f(S),B<v)){w=b,A=y;const U=v;v=B,B=U,T=S}T||(T=e,R(w,g,T));const M=Y(w*2,m),C=a(T,M,v,d+1,u+w);let E;if(C===Zt){const U=l(w),G=h(w)-U;E=c(U,G,!0,d+1,u+w,T)}else E=C&&i(w,r,a,c,f,u,d+1);if(E)return!0;S=n,R(A,g,S);const F=Y(A*2,m),L=a(S,F,B,d+1,u+A);let J;if(L===Zt){const U=l(A),G=h(A)-U;J=c(U,G,!0,d+1,u+A,S)}else J=L&&i(A,r,a,c,f,u,d+1);return!!J}}}(),Qn=function(){const e=new H,n=new H,t=new dt,s=new V,i=new V;return function o(r,a,c,f,u=null){let d=r*2,l=rt,h=Z,P=W;if(u===null&&(c.boundingBox||c.computeBoundingBox(),s.set(c.boundingBox.min,c.boundingBox.max,f),u=s),Y(d,h)){const m=a,p=m.index,x=m.attributes.position,y=c.index,b=c.attributes.position,w=it(r,P),A=ht(d,h);if(t.copy(f).invert(),c.boundsTree)return R(r,l,i),i.matrix.copy(t),i.needsUpdate=!0,c.boundsTree.shapecast({intersectsBounds:B=>i.intersectsBox(B),intersectsTriangle:B=>{B.a.applyMatrix4(f),B.b.applyMatrix4(f),B.c.applyMatrix4(f),B.needsUpdate=!0;for(let T=w*3,S=(A+w)*3;T<S;T+=3)if(_(n,T,p,x),n.needsUpdate=!0,B.intersectsTriangle(n))return!0;return!1}});for(let v=w*3,B=A+w*3;v<B;v+=3){_(e,v,p,x),e.a.applyMatrix4(t),e.b.applyMatrix4(t),e.c.applyMatrix4(t),e.needsUpdate=!0;for(let T=0,S=y.count;T<S;T+=3)if(_(n,T,y,b),n.needsUpdate=!0,e.intersectsTriangle(n))return!0}}else{const m=r+8,p=P[r+6];return R(m,l,st),!!(u.intersectsBox(st)&&o(m,a,c,f,u)||(R(p,l,st),u.intersectsBox(st)&&o(p,a,c,f,u)))}}}();function Ft(e,n,t,s){return R(e,n,st),t.intersectBox(st,s)}const Ot=[];let Ct,rt,Z,W;function ut(e){Ct&&Ot.push(Ct),Ct=e,rt=new Float32Array(e),Z=new Uint16Array(e),W=new Uint32Array(e)}function gt(){Ct=null,rt=null,Z=null,W=null,Ot.length&&ut(Ot.pop())}const Dt=Symbol("skip tree generation"),_t=new ot,Rt=new ot,et=new dt,$=new V,at=new V,lt=new I,St=new I,te=new I,ne=new I,ee=new I,sn=new ot,D=new yn(()=>new H);class pt{static serialize(n,t={}){if(t.isBufferGeometry)return console.warn("MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature."),pt.serialize(arguments[0],{cloneBuffers:arguments[2]===void 0?!0:arguments[2]});t={cloneBuffers:!0,...t};const s=n.geometry,i=n._roots,o=s.getIndex();let r;return t.cloneBuffers?r={roots:i.map(a=>a.slice()),index:o.array.slice()}:r={roots:i,index:o.array},r}static deserialize(n,t,s={}){if(typeof s=="boolean")return console.warn("MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature."),pt.deserialize(arguments[0],arguments[1],{setIndex:arguments[2]===void 0?!0:arguments[2]});s={setIndex:!0,...s};const{index:i,roots:o}=n,r=new pt(t,{...s,[Dt]:!0});if(r._roots=o,s.setIndex){const a=t.getIndex();if(a===null){const c=new fn(n.index,1,!1);t.setIndex(c)}else a.array!==i&&(a.array.set(i),a.needsUpdate=!0)}return r}constructor(n,t={}){if(n.isBufferGeometry){if(n.index&&n.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t=Object.assign({strategy:dn,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,[Dt]:!1},t),t.useSharedArrayBuffer&&typeof SharedArrayBuffer>"u")throw new Error("MeshBVH: SharedArrayBuffer is not available.");this._roots=null,t[Dt]||(this._roots=On(n,t),!n.boundingBox&&t.setBoundingBox&&(n.boundingBox=this.getBoundingBox(new ot))),this.geometry=n}refit(n=null){n&&Array.isArray(n)&&(n=new Set(n));const t=this.geometry,s=t.index.array,i=t.attributes.position;let o,r,a,c,f=0;const u=this._roots;for(let l=0,h=u.length;l<h;l++)o=u[l],r=new Uint32Array(o),a=new Uint16Array(o),c=new Float32Array(o),d(0,f),f+=o.byteLength;function d(l,h,P=!1){const g=l*2;if(a[g+15]===Nt){const p=r[l+6],x=a[g+14];let y=1/0,b=1/0,w=1/0,A=-1/0,v=-1/0,B=-1/0;for(let T=3*p,S=3*(p+x);T<S;T++){const M=s[T],C=i.getX(M),E=i.getY(M),F=i.getZ(M);C<y&&(y=C),C>A&&(A=C),E<b&&(b=E),E>v&&(v=E),F<w&&(w=F),F>B&&(B=F)}return c[l+0]!==y||c[l+1]!==b||c[l+2]!==w||c[l+3]!==A||c[l+4]!==v||c[l+5]!==B?(c[l+0]=y,c[l+1]=b,c[l+2]=w,c[l+3]=A,c[l+4]=v,c[l+5]=B,!0):!1}else{const p=l+8,x=r[l+6],y=p+h,b=x+h;let w=P,A=!1,v=!1;n?w||(A=n.has(y),v=n.has(b),w=!A&&!v):(A=!0,v=!0);const B=w||A,T=w||v;let S=!1;B&&(S=d(p,h,w));let M=!1;T&&(M=d(x,h,w));const C=S||M;if(C)for(let E=0;E<3;E++){const F=p+E,L=x+E,J=c[F],U=c[F+3],xt=c[L],G=c[L+3];c[l+E]=J<xt?J:xt,c[l+E+3]=U>G?U:G}return C}}}traverse(n,t=0){const s=this._roots[t],i=new Uint32Array(s),o=new Uint16Array(s);r(0);function r(a,c=0){const f=a*2,u=o[f+15]===Nt;if(u){const d=i[a+6],l=o[f+14];n(c,u,new Float32Array(s,a*4,6),d,l)}else{const d=a+It/4,l=i[a+6],h=i[a+7];n(c,u,new Float32Array(s,a*4,6),h)||(r(d,c+1),r(l,c+1))}}}raycast(n,t=Xt){const s=this._roots,i=this.geometry,o=[],r=t.isMaterial,a=Array.isArray(t),c=i.groups,f=r?t.side:t;for(let u=0,d=s.length;u<d;u++){const l=a?t[c[u].materialIndex].side:f,h=o.length;if(ut(s[u]),qt(0,i,l,n,o),gt(),a){const P=c[u].materialIndex;for(let g=h,m=o.length;g<m;g++)o[g].face.materialIndex=P}}return o}raycastFirst(n,t=Xt){const s=this._roots,i=this.geometry,o=t.isMaterial,r=Array.isArray(t);let a=null;const c=i.groups,f=o?t.side:t;for(let u=0,d=s.length;u<d;u++){const l=r?t[c[u].materialIndex].side:f;ut(s[u]);const h=kt(0,i,l,n);gt(),h!=null&&(a==null||h.distance<a.distance)&&(a=h,r&&(h.face.materialIndex=c[u].materialIndex))}return a}intersectsGeometry(n,t){const s=this.geometry;let i=!1;for(const o of this._roots)if(ut(o),i=Qn(0,s,n,t),gt(),i)break;return i}shapecast(n,t,s){const i=this.geometry;if(n instanceof Function){if(t){const l=t;t=(h,P,g,m)=>{const p=P*3;return l(h,p,p+1,p+2,g,m)}}n={boundsTraverseOrder:s,intersectsBounds:n,intersectsTriangle:t,intersectsRange:null},console.warn("MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.")}const o=D.getPrimitive();let{boundsTraverseOrder:r,intersectsBounds:a,intersectsRange:c,intersectsTriangle:f}=n;if(c&&f){const l=c;c=(h,P,g,m,p)=>l(h,P,g,m,p)?!0:en(h,P,i,f,g,m,o)}else c||(f?c=(l,h,P,g)=>en(l,h,i,f,P,g,o):c=(l,h,P)=>P);let u=!1,d=0;for(const l of this._roots){if(ut(l),u=Gn(0,i,a,c,r,d),gt(),u)break;d+=l.byteLength}return D.releasePrimitive(o),u}bvhcast(n,t,s){let{intersectsRanges:i,intersectsTriangles:o}=s;const r=this.geometry.index,a=this.geometry.attributes.position,c=n.geometry.index,f=n.geometry.attributes.position;et.copy(t).invert();const u=D.getPrimitive(),d=D.getPrimitive();if(o){let h=function(P,g,m,p,x,y,b,w){for(let A=m,v=m+p;A<v;A++){_(d,A*3,c,f),d.a.applyMatrix4(t),d.b.applyMatrix4(t),d.c.applyMatrix4(t),d.needsUpdate=!0;for(let B=P,T=P+g;B<T;B++)if(_(u,B*3,r,a),u.needsUpdate=!0,o(u,d,B,A,x,y,b,w))return!0}return!1};if(i){const P=i;i=function(g,m,p,x,y,b,w,A){return P(g,m,p,x,y,b,w,A)?!0:h(g,m,p,x,y,b,w,A)}}else i=h}n.getBoundingBox(Rt),Rt.applyMatrix4(t);const l=this.shapecast({intersectsBounds:h=>Rt.intersectsBox(h),intersectsRange:(h,P,g,m,p,x)=>(_t.copy(x),_t.applyMatrix4(et),n.shapecast({intersectsBounds:y=>_t.intersectsBox(y),intersectsRange:(y,b,w,A,v)=>i(h,P,y,b,m,p,A,v)}))});return D.releasePrimitive(u),D.releasePrimitive(d),l}intersectsBox(n,t){return $.set(n.min,n.max,t),$.needsUpdate=!0,this.shapecast({intersectsBounds:s=>$.intersectsBox(s),intersectsTriangle:s=>$.intersectsTriangle(s)})}intersectsSphere(n){return this.shapecast({intersectsBounds:t=>n.intersectsBox(t),intersectsTriangle:t=>t.intersectsSphere(n)})}closestPointToGeometry(n,t,s={},i={},o=0,r=1/0){n.boundingBox||n.computeBoundingBox(),$.set(n.boundingBox.min,n.boundingBox.max,t),$.needsUpdate=!0;const a=this.geometry,c=a.attributes.position,f=a.index,u=n.attributes.position,d=n.index,l=D.getPrimitive(),h=D.getPrimitive();let P=St,g=te,m=null,p=null;i&&(m=ne,p=ee);let x=1/0,y=null,b=null;return et.copy(t).invert(),at.matrix.copy(et),this.shapecast({boundsTraverseOrder:w=>$.distanceToBox(w),intersectsBounds:(w,A,v)=>v<x&&v<r?(A&&(at.min.copy(w.min),at.max.copy(w.max),at.needsUpdate=!0),!0):!1,intersectsRange:(w,A)=>{if(n.boundsTree)return n.boundsTree.shapecast({boundsTraverseOrder:v=>at.distanceToBox(v),intersectsBounds:(v,B,T)=>T<x&&T<r,intersectsRange:(v,B)=>{for(let T=v*3,S=(v+B)*3;T<S;T+=3){_(h,T,d,u),h.a.applyMatrix4(t),h.b.applyMatrix4(t),h.c.applyMatrix4(t),h.needsUpdate=!0;for(let M=w*3,C=(w+A)*3;M<C;M+=3){_(l,M,f,c),l.needsUpdate=!0;const E=l.distanceToTriangle(h,P,m);if(E<x&&(g.copy(P),p&&p.copy(m),x=E,y=M/3,b=T/3),E<o)return!0}}}});{const v=d?d.count:u.count;for(let B=0,T=v;B<T;B+=3){_(h,B,d,u),h.a.applyMatrix4(t),h.b.applyMatrix4(t),h.c.applyMatrix4(t),h.needsUpdate=!0;for(let S=w*3,M=(w+A)*3;S<M;S+=3){_(l,S,f,c),l.needsUpdate=!0;const C=l.distanceToTriangle(h,P,m);if(C<x&&(g.copy(P),p&&p.copy(m),x=C,y=S/3,b=B/3),C<o)return!0}}}}}),D.releasePrimitive(l),D.releasePrimitive(h),x===1/0?null:(s.point?s.point.copy(g):s.point=g.clone(),s.distance=x,s.faceIndex=y,i&&(i.point?i.point.copy(p):i.point=p.clone(),i.point.applyMatrix4(et),g.applyMatrix4(et),i.distance=g.sub(i.point).length(),i.faceIndex=b),s)}closestPointToPoint(n,t={},s=0,i=1/0){const o=s*s,r=i*i;let a=1/0,c=null;if(this.shapecast({boundsTraverseOrder:u=>(lt.copy(n).clamp(u.min,u.max),lt.distanceToSquared(n)),intersectsBounds:(u,d,l)=>l<a&&l<r,intersectsTriangle:(u,d)=>{u.closestPointToPoint(n,lt);const l=n.distanceToSquared(lt);return l<a&&(St.copy(lt),a=l,c=d),l<o}}),a===1/0)return null;const f=Math.sqrt(a);return t.point?t.point.copy(St):t.point=St.clone(),t.distance=f,t.faceIndex=c,t}getBoundingBox(n){return n.makeEmpty(),this._roots.forEach(s=>{R(0,new Float32Array(s),sn),n.union(sn)}),n}}const Vt=new vn,on=new dt,se=pn.prototype.raycast;function ie(e,n){if(this.geometry.boundsTree){if(this.material===void 0)return;on.copy(this.matrixWorld).invert(),Vt.copy(e.ray).applyMatrix4(on);const t=this.geometry.boundsTree;if(e.firstHitOnly===!0){const s=nn(t.raycastFirst(Vt,this.material),this,e);s&&n.push(s)}else{const s=t.raycast(Vt,this.material);for(let i=0,o=s.length;i<o;i++){const r=nn(s[i],this,e);r&&n.push(r)}}}else se.call(this,e,n)}function oe(e){return this.boundsTree=new pt(this,e),this.boundsTree}function re(){this.boundsTree=null}const ce=()=>{Yt.prototype.computeBoundsTree=oe,Yt.prototype.disposeBoundsTree=re,pn.prototype.raycast=ie,ln.prototype.firstHitOnly=!0},ae=`import { MouseRaycaster } from 'trzy'

const raycaster = new MouseRaycaster({
  scene, // Alternatively, pass objects: THREE.Object3D[]
  camera,
  renderer,
  recursive: true,
})

raycaster.on('move', (event) => console.log(event.intersections))
raycaster.on('click', (event) => console.log(event.intersections))

// Later
raycaster.dispose()
`,de={title:"Mouse Raycaster",parameters:{docs:{source:{code:ae}}}},le=()=>{ce(),Bn();const{scene:e,camera:n,renderer:t}=gn(),s=new I(1,1,1),i=new In({renderer:t});i.recursive=!0,i.camera=n.current;let o=!1,r=.1;return Mn().then(a=>{e.add(a),a.traverse(c=>{var f,u;return(u=(f=c.geometry)==null?void 0:f.computeBoundsTree)==null?void 0:u.call(f)}),i.objects=[a],Sn(()=>a.scale.lerp(s,r))}),i.on("move",a=>{a.intersections.length>0?(r=.1,s.setScalar(.12)):(r=.1,s.setScalar(.1)),o=a.intersections.length>0}),i.on("click",a=>{a.intersections.length!==0&&(r=.2,s.setScalar(s.x===.17?o?.12:.1:.17))}),t.domElement},Mt={render:le};var rn,cn,an;Mt.parameters={...Mt.parameters,docs:{...(rn=Mt.parameters)==null?void 0:rn.docs,source:{originalSource:`{
  render
}`,...(an=(cn=Mt.parameters)==null?void 0:cn.docs)==null?void 0:an.source}}};const he=["Primary"];export{Mt as Primary,he as __namedExportsOrder,de as default};
//# sourceMappingURL=mouse-raycaster.stories-b2be82a6.js.map
