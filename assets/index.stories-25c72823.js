var ye=Object.defineProperty;var me=(n,e,t)=>e in n?ye(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t;var D=(n,e,t)=>(me(n,typeof e!="symbol"?e+"":e,t),t),xe=(n,e,t)=>{if(!e.has(n))throw TypeError("Cannot "+t)};var J=(n,e,t)=>(xe(n,e,"read from private field"),t?t.call(n):e.get(n)),Ht=(n,e,t)=>{if(e.has(n))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(n):e.set(n,t)};import{c as we,V as j,R as ae,d as le,e as M,f as fe,L as H,T as pt,g as be,h as yt,i as Ae,D as Pe,j as ct,F as Xt,k as Te,M as ue,l as Yt,t as ve}from"./teleport-97191997.js";import{s as Be}from"./setup-ff5f1186.js";var O;class ge extends we{constructor(t){super();D(this,"camera");D(this,"raycaster");D(this,"objects",[]);D(this,"pointerDown",new j);D(this,"pointerUp",new j);D(this,"pointerMove",new j);D(this,"recursive",!0);D(this,"renderer");Ht(this,O,{click:0,move:0});D(this,"onPointerDown",t=>{this.getNormalizedCoordinates(t,this.pointerDown)});D(this,"onPointerUp",t=>{if(this.camera===void 0||(this.getNormalizedCoordinates(t,this.pointerUp),this.pointerDown.sub(this.pointerUp).lengthSq()>.001))return;this.raycaster.setFromCamera(this.pointerUp,this.camera);const s=this.raycaster.intersectObjects(this.objects,this.recursive);this.dispatchEvent({type:"click",intersections:s})});D(this,"onPointerMove",t=>{if(this.camera===void 0)return;this.getNormalizedCoordinates(t,this.pointerMove),this.raycaster.setFromCamera(this.pointerMove,this.camera);const s=this.raycaster.intersectObjects(this.objects,this.recursive);this.dispatchEvent({type:"move",intersections:s})});this.camera=t.camera,this.renderer=t.renderer,this.raycaster=t.raycaster??new ae,this.objects=t.objects??(t.scene?[t.scene]:[]),this.recursive=t.recursive??!0}on(t,s){super.addEventListener(t,s);const i=this.renderer.domElement;t==="move"&&J(this,O).move===0?i.addEventListener("pointermove",this.onPointerMove,{passive:!0}):t==="click"&&J(this,O).click===0&&(i.addEventListener("pointerdown",this.onPointerDown,{passive:!0}),i.addEventListener("pointerup",this.onPointerUp,{passive:!0})),J(this,O)[t]+=1}off(t,s){super.removeEventListener(t,s);const i=this.renderer.domElement;J(this,O)[t]-=1,t==="move"&&J(this,O).move<=0?i.removeEventListener("pointermove",this.onPointerMove):t==="click"&&J(this,O).click<=0&&(i.addEventListener("pointerdown",this.onPointerDown,{passive:!0}),i.addEventListener("pointerup",this.onPointerUp,{passive:!0}))}getNormalizedCoordinates(t,s){const i=this.renderer.domElement,o=i.getBoundingClientRect();s.x=(t.clientX-o.x)/i.clientWidth*2-1,s.y=-((t.clientY-o.y)/i.clientHeight*2)+1}dispose(){const t=this.renderer.domElement;t.removeEventListener("pointerdown",this.onPointerDown),t.removeEventListener("pointerup",this.onPointerUp),t.removeEventListener("pointermove",this.onPointerMove)}}O=new WeakMap;const pe=0,Se=1,Me=2,Zt=2,zt=1.25,Wt=1,Ct=6*4+4+4,Vt=65535,Ie=Math.pow(2,-24);class bt{constructor(){}}function V(n,e,t){return t.min.x=e[n],t.min.y=e[n+1],t.min.z=e[n+2],t.max.x=e[n+3],t.max.y=e[n+4],t.max.z=e[n+5],t}function $t(n){let e=-1,t=-1/0;for(let s=0;s<3;s++){const i=n[s+3]-n[s];i>t&&(t=i,e=s)}return e}function Kt(n,e){e.set(n)}function Gt(n,e,t){let s,i;for(let o=0;o<3;o++){const r=o+3;s=n[o],i=e[o],t[o]=s<i?s:i,s=n[r],i=e[r],t[r]=s>i?s:i}}function At(n,e,t){for(let s=0;s<3;s++){const i=e[n+2*s],o=e[n+2*s+1],r=i-o,f=i+o;r<t[s]&&(t[s]=r),f>t[s+3]&&(t[s+3]=f)}}function lt(n){const e=n[3]-n[0],t=n[4]-n[1],s=n[5]-n[2];return 2*(e*t+t*s+s*e)}function Ce(n,e){if(!n.index){const t=n.attributes.position.count,s=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;let i;t>65535?i=new Uint32Array(new s(4*t)):i=new Uint16Array(new s(2*t)),n.setIndex(new le(i,1));for(let o=0;o<t;o++)i[o]=o}}function Ee(n){if(!n.groups||!n.groups.length)return[{offset:0,count:n.index.count/3}];const e=[],t=new Set;for(const i of n.groups)t.add(i.start),t.add(i.start+i.count);const s=Array.from(t.values()).sort((i,o)=>i-o);for(let i=0;i<s.length-1;i++){const o=s[i],r=s[i+1];e.push({offset:o/3,count:(r-o)/3})}return e}function Ut(n,e,t,s,i=null){let o=1/0,r=1/0,f=1/0,c=-1/0,l=-1/0,a=-1/0,p=1/0,u=1/0,d=1/0,x=-1/0,B=-1/0,A=-1/0;const h=i!==null;for(let m=e*6,y=(e+t)*6;m<y;m+=6){const b=n[m+0],P=n[m+1],w=b-P,T=b+P;w<o&&(o=w),T>c&&(c=T),h&&b<p&&(p=b),h&&b>x&&(x=b);const v=n[m+2],g=n[m+3],S=v-g,I=v+g;S<r&&(r=S),I>l&&(l=I),h&&v<u&&(u=v),h&&v>B&&(B=v);const C=n[m+4],E=n[m+5],F=C-E,L=C+E;F<f&&(f=F),L>a&&(a=L),h&&C<d&&(d=C),h&&C>A&&(A=C)}s[0]=o,s[1]=r,s[2]=f,s[3]=c,s[4]=l,s[5]=a,h&&(i[0]=p,i[1]=u,i[2]=d,i[3]=x,i[4]=B,i[5]=A)}function Fe(n,e,t,s){let i=1/0,o=1/0,r=1/0,f=-1/0,c=-1/0,l=-1/0;for(let a=e*6,p=(e+t)*6;a<p;a+=6){const u=n[a+0];u<i&&(i=u),u>f&&(f=u);const d=n[a+2];d<o&&(o=d),d>c&&(c=d);const x=n[a+4];x<r&&(r=x),x>l&&(l=x)}s[0]=i,s[1]=o,s[2]=r,s[3]=f,s[4]=c,s[5]=l}function Le(n,e,t,s,i){let o=t,r=t+s-1;const f=i.pos,c=i.axis*2;for(;;){for(;o<=r&&e[o*6+c]<f;)o++;for(;o<=r&&e[r*6+c]>=f;)r--;if(o<r){for(let l=0;l<3;l++){let a=n[o*3+l];n[o*3+l]=n[r*3+l],n[r*3+l]=a;let p=e[o*6+l*2+0];e[o*6+l*2+0]=e[r*6+l*2+0],e[r*6+l*2+0]=p;let u=e[o*6+l*2+1];e[o*6+l*2+1]=e[r*6+l*2+1],e[r*6+l*2+1]=u}o++,r--}else return o}}const k=32,ze=(n,e)=>n.candidate-e.candidate,W=new Array(k).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),Pt=new Float32Array(6);function Ue(n,e,t,s,i,o){let r=-1,f=0;if(o===pe)r=$t(e),r!==-1&&(f=(e[r]+e[r+3])/2);else if(o===Se)r=$t(n),r!==-1&&(f=De(t,s,i,r));else if(o===Me){const c=lt(n);let l=zt*i;const a=s*6,p=(s+i)*6;for(let u=0;u<3;u++){const d=e[u],A=(e[u+3]-d)/k;if(i<k/4){const h=[...W];h.length=i;let m=0;for(let b=a;b<p;b+=6,m++){const P=h[m];P.candidate=t[b+2*u],P.count=0;const{bounds:w,leftCacheBounds:T,rightCacheBounds:v}=P;for(let g=0;g<3;g++)v[g]=1/0,v[g+3]=-1/0,T[g]=1/0,T[g+3]=-1/0,w[g]=1/0,w[g+3]=-1/0;At(b,t,w)}h.sort(ze);let y=i;for(let b=0;b<y;b++){const P=h[b];for(;b+1<y&&h[b+1].candidate===P.candidate;)h.splice(b+1,1),y--}for(let b=a;b<p;b+=6){const P=t[b+2*u];for(let w=0;w<y;w++){const T=h[w];P>=T.candidate?At(b,t,T.rightCacheBounds):(At(b,t,T.leftCacheBounds),T.count++)}}for(let b=0;b<y;b++){const P=h[b],w=P.count,T=i-P.count,v=P.leftCacheBounds,g=P.rightCacheBounds;let S=0;w!==0&&(S=lt(v)/c);let I=0;T!==0&&(I=lt(g)/c);const C=Wt+zt*(S*w+I*T);C<l&&(r=u,l=C,f=P.candidate)}}else{for(let y=0;y<k;y++){const b=W[y];b.count=0,b.candidate=d+A+y*A;const P=b.bounds;for(let w=0;w<3;w++)P[w]=1/0,P[w+3]=-1/0}for(let y=a;y<p;y+=6){let w=~~((t[y+2*u]-d)/A);w>=k&&(w=k-1);const T=W[w];T.count++,At(y,t,T.bounds)}const h=W[k-1];Kt(h.bounds,h.rightCacheBounds);for(let y=k-2;y>=0;y--){const b=W[y],P=W[y+1];Gt(b.bounds,P.rightCacheBounds,b.rightCacheBounds)}let m=0;for(let y=0;y<k-1;y++){const b=W[y],P=b.count,w=b.bounds,v=W[y+1].rightCacheBounds;P!==0&&(m===0?Kt(w,Pt):Gt(w,Pt,Pt)),m+=P;let g=0,S=0;m!==0&&(g=lt(Pt)/c);const I=i-m;I!==0&&(S=lt(v)/c);const C=Wt+zt*(g*m+S*I);C<l&&(r=u,l=C,f=b.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${o} used.`);return{axis:r,pos:f}}function De(n,e,t,s){let i=0;for(let o=e,r=e+t;o<r;o++)i+=n[o*6+s*2];return i/t}function _e(n,e){const t=n.attributes.position,s=n.index.array,i=s.length/3,o=new Float32Array(i*6),r=t.normalized,f=t.array,c=t.offset||0;let l=3;t.isInterleavedBufferAttribute&&(l=t.data.stride);const a=["getX","getY","getZ"];for(let p=0;p<i;p++){const u=p*3,d=p*6;let x,B,A;r?(x=s[u+0],B=s[u+1],A=s[u+2]):(x=s[u+0]*l+c,B=s[u+1]*l+c,A=s[u+2]*l+c);for(let h=0;h<3;h++){let m,y,b;r?(m=t[a[h]](x),y=t[a[h]](B),b=t[a[h]](A)):(m=f[x+h],y=f[B+h],b=f[A+h]);let P=m;y<P&&(P=y),b<P&&(P=b);let w=m;y>w&&(w=y),b>w&&(w=b);const T=(w-P)/2,v=h*2;o[d+v+0]=P+T,o[d+v+1]=T+(Math.abs(P)+T)*Ie,P<e[h]&&(e[h]=P),w>e[h+3]&&(e[h+3]=w)}}return o}function Re(n,e){function t(h){u&&u(h/d)}function s(h,m,y,b=null,P=0){if(!x&&P>=c&&(x=!0,l&&(console.warn(`MeshBVH: Max depth of ${c} reached when generating BVH. Consider increasing maxDepth.`),console.warn(n))),y<=a||P>=c)return t(m+y),h.offset=m,h.count=y,h;const w=Ue(h.boundingData,b,r,m,y,p);if(w.axis===-1)return t(m+y),h.offset=m,h.count=y,h;const T=Le(f,r,m,y,w);if(T===m||T===m+y)t(m+y),h.offset=m,h.count=y;else{h.splitAxis=w.axis;const v=new bt,g=m,S=T-m;h.left=v,v.boundingData=new Float32Array(6),Ut(r,g,S,v.boundingData,o),s(v,g,S,o,P+1);const I=new bt,C=T,E=y-S;h.right=I,I.boundingData=new Float32Array(6),Ut(r,C,E,I.boundingData,o),s(I,C,E,o,P+1)}return h}Ce(n,e);const i=new Float32Array(6),o=new Float32Array(6),r=_e(n,i),f=n.index.array,c=e.maxDepth,l=e.verbose,a=e.maxLeafTris,p=e.strategy,u=e.onProgress,d=n.index.count/3;let x=!1;const B=[],A=Ee(n);if(A.length===1){const h=A[0],m=new bt;m.boundingData=i,Fe(r,h.offset,h.count,o),s(m,h.offset,h.count,o),B.push(m)}else for(let h of A){const m=new bt;m.boundingData=new Float32Array(6),Ut(r,h.offset,h.count,m.boundingData,o),s(m,h.offset,h.count,o),B.push(m)}return B}function Ne(n,e){const t=Re(n,e);let s,i,o;const r=[],f=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;for(let a=0;a<t.length;a++){const p=t[a];let u=c(p);const d=new f(Ct*u);s=new Float32Array(d),i=new Uint32Array(d),o=new Uint16Array(d),l(0,p),r.push(d)}return r;function c(a){return a.count?1:1+c(a.left)+c(a.right)}function l(a,p){const u=a/4,d=a/2,x=!!p.count,B=p.boundingData;for(let A=0;A<6;A++)s[u+A]=B[A];if(x){const A=p.offset,h=p.count;return i[u+6]=A,o[d+14]=h,o[d+15]=Vt,a+Ct}else{const A=p.left,h=p.right,m=p.splitAxis;let y;if(y=l(a+Ct,A),y/4>Math.pow(2,32))throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return i[u+6]=y/4,y=l(y,h),i[u+7]=m,y}}}class X{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(e,t){let s=1/0,i=-1/0;for(let o=0,r=e.length;o<r;o++){const c=e[o][t];s=c<s?c:s,i=c>i?c:i}this.min=s,this.max=i}setFromPoints(e,t){let s=1/0,i=-1/0;for(let o=0,r=t.length;o<r;o++){const f=t[o],c=e.dot(f);s=c<s?c:s,i=c>i?c:i}this.min=s,this.max=i}isSeparated(e){return this.min>e.max||e.min>this.max}}X.prototype.setFromBox=function(){const n=new M;return function(t,s){const i=s.min,o=s.max;let r=1/0,f=-1/0;for(let c=0;c<=1;c++)for(let l=0;l<=1;l++)for(let a=0;a<=1;a++){n.x=i.x*c+o.x*(1-c),n.y=i.y*l+o.y*(1-l),n.z=i.z*a+o.z*(1-a);const p=t.dot(n);r=Math.min(p,r),f=Math.max(p,f)}this.min=r,this.max=f}}();const Ve=function(){const n=new M,e=new M,t=new M;return function(i,o,r){const f=i.start,c=n,l=o.start,a=e;t.subVectors(f,l),n.subVectors(i.end,i.start),e.subVectors(o.end,o.start);const p=t.dot(a),u=a.dot(c),d=a.dot(a),x=t.dot(c),A=c.dot(c)*d-u*u;let h,m;A!==0?h=(p*u-x*d)/A:h=0,m=(p+h*u)/d,r.x=h,r.y=m}}(),jt=function(){const n=new j,e=new M,t=new M;return function(i,o,r,f){Ve(i,o,n);let c=n.x,l=n.y;if(c>=0&&c<=1&&l>=0&&l<=1){i.at(c,r),o.at(l,f);return}else if(c>=0&&c<=1){l<0?o.at(0,f):o.at(1,f),i.closestPointToPoint(f,!0,r);return}else if(l>=0&&l<=1){c<0?i.at(0,r):i.at(1,r),o.closestPointToPoint(r,!0,f);return}else{let a;c<0?a=i.start:a=i.end;let p;l<0?p=o.start:p=o.end;const u=e,d=t;if(i.closestPointToPoint(p,!0,e),o.closestPointToPoint(a,!0,t),u.distanceToSquared(p)<=d.distanceToSquared(a)){r.copy(u),f.copy(p);return}else{r.copy(a),f.copy(d);return}}}}(),qe=function(){const n=new M,e=new M,t=new fe,s=new H;return function(o,r){const{radius:f,center:c}=o,{a:l,b:a,c:p}=r;if(s.start=l,s.end=a,s.closestPointToPoint(c,!0,n).distanceTo(c)<=f||(s.start=l,s.end=p,s.closestPointToPoint(c,!0,n).distanceTo(c)<=f)||(s.start=a,s.end=p,s.closestPointToPoint(c,!0,n).distanceTo(c)<=f))return!0;const B=r.getPlane(t);if(Math.abs(B.distanceToPoint(c))<=f){const h=B.projectPoint(c,e);if(r.containsPoint(h))return!0}return!1}}(),ke=1e-15;function tt(n){return Math.abs(n)<ke}class Y extends pt{constructor(...e){super(...e),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new M),this.satBounds=new Array(4).fill().map(()=>new X),this.points=[this.a,this.b,this.c],this.sphere=new be,this.plane=new fe,this.needsUpdate=!0}intersectsSphere(e){return qe(e,this)}update(){const e=this.a,t=this.b,s=this.c,i=this.points,o=this.satAxes,r=this.satBounds,f=o[0],c=r[0];this.getNormal(f),c.setFromPoints(f,i);const l=o[1],a=r[1];l.subVectors(e,t),a.setFromPoints(l,i);const p=o[2],u=r[2];p.subVectors(t,s),u.setFromPoints(p,i);const d=o[3],x=r[3];d.subVectors(s,e),x.setFromPoints(d,i),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(f,e),this.needsUpdate=!1}}Y.prototype.closestPointToSegment=function(){const n=new M,e=new M,t=new H;return function(i,o=null,r=null){const{start:f,end:c}=i,l=this.points;let a,p=1/0;for(let u=0;u<3;u++){const d=(u+1)%3;t.start.copy(l[u]),t.end.copy(l[d]),jt(t,i,n,e),a=n.distanceToSquared(e),a<p&&(p=a,o&&o.copy(n),r&&r.copy(e))}return this.closestPointToPoint(f,n),a=f.distanceToSquared(n),a<p&&(p=a,o&&o.copy(n),r&&r.copy(f)),this.closestPointToPoint(c,n),a=c.distanceToSquared(n),a<p&&(p=a,o&&o.copy(n),r&&r.copy(c)),Math.sqrt(p)}}();Y.prototype.intersectsTriangle=function(){const n=new Y,e=new Array(3),t=new Array(3),s=new X,i=new X,o=new M,r=new M,f=new M,c=new M,l=new H,a=new H,p=new H;return function(d,x=null,B=!1){this.needsUpdate&&this.update(),d.isExtendedTriangle?d.needsUpdate&&d.update():(n.copy(d),n.update(),d=n);const A=this.plane,h=d.plane;if(Math.abs(A.normal.dot(h.normal))>1-1e-10){const m=this.satBounds,y=this.satAxes;t[0]=d.a,t[1]=d.b,t[2]=d.c;for(let w=0;w<4;w++){const T=m[w],v=y[w];if(s.setFromPoints(v,t),T.isSeparated(s))return!1}const b=d.satBounds,P=d.satAxes;e[0]=this.a,e[1]=this.b,e[2]=this.c;for(let w=0;w<4;w++){const T=b[w],v=P[w];if(s.setFromPoints(v,e),T.isSeparated(s))return!1}for(let w=0;w<4;w++){const T=y[w];for(let v=0;v<4;v++){const g=P[v];if(o.crossVectors(T,g),s.setFromPoints(o,e),i.setFromPoints(o,t),s.isSeparated(i))return!1}}return x&&(B||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),x.start.set(0,0,0),x.end.set(0,0,0)),!0}else{const m=this.points;let y=!1,b=0;for(let F=0;F<3;F++){const L=m[F],U=m[(F+1)%3];l.start.copy(L),l.end.copy(U),l.delta(r);const z=y?a.start:a.end,_=tt(h.distanceToPoint(L));if(tt(h.normal.dot(r))&&_){a.copy(l),b=2;break}if((h.intersectLine(l,z)||_)&&!tt(z.distanceTo(U))){if(b++,y)break;y=!0}}if(b===1&&d.containsPoint(a.end))return x&&(x.start.copy(a.end),x.end.copy(a.end)),!0;if(b!==2)return!1;const P=d.points;let w=!1,T=0;for(let F=0;F<3;F++){const L=P[F],U=P[(F+1)%3];l.start.copy(L),l.end.copy(U),l.delta(f);const z=w?p.start:p.end,_=tt(A.distanceToPoint(L));if(tt(A.normal.dot(f))&&_){p.copy(l),T=2;break}if((A.intersectLine(l,z)||_)&&!tt(z.distanceTo(U))){if(T++,w)break;w=!0}}if(T===1&&this.containsPoint(p.end))return x&&(x.start.copy(p.end),x.end.copy(p.end)),!0;if(T!==2)return!1;if(a.delta(r),p.delta(f),r.dot(f)<0){let F=p.start;p.start=p.end,p.end=F}const v=a.start.dot(r),g=a.end.dot(r),S=p.start.dot(r),I=p.end.dot(r),C=g<S,E=v<I;return v!==I&&S!==g&&C===E?!1:(x&&(c.subVectors(a.start,p.start),c.dot(r)>0?x.start.copy(a.start):x.start.copy(p.start),c.subVectors(a.end,p.end),c.dot(r)<0?x.end.copy(a.end):x.end.copy(p.end)),!0)}}}();Y.prototype.distanceToPoint=function(){const n=new M;return function(t){return this.closestPointToPoint(t,n),t.distanceTo(n)}}();Y.prototype.distanceToTriangle=function(){const n=new M,e=new M,t=["a","b","c"],s=new H,i=new H;return function(r,f=null,c=null){const l=f||c?s:null;if(this.intersectsTriangle(r,l))return(f||c)&&(f&&l.getCenter(f),c&&l.getCenter(c)),0;let a=1/0;for(let p=0;p<3;p++){let u;const d=t[p],x=r[d];this.closestPointToPoint(x,n),u=x.distanceToSquared(n),u<a&&(a=u,f&&f.copy(n),c&&c.copy(x));const B=this[d];r.closestPointToPoint(B,n),u=B.distanceToSquared(n),u<a&&(a=u,f&&f.copy(B),c&&c.copy(n))}for(let p=0;p<3;p++){const u=t[p],d=t[(p+1)%3];s.set(this[u],this[d]);for(let x=0;x<3;x++){const B=t[x],A=t[(x+1)%3];i.set(r[B],r[A]),jt(s,i,n,e);const h=n.distanceToSquared(e);h<a&&(a=h,f&&f.copy(n),c&&c.copy(e))}}return Math.sqrt(a)}}();class q{constructor(e,t,s){this.isOrientedBox=!0,this.min=new M,this.max=new M,this.matrix=new yt,this.invMatrix=new yt,this.points=new Array(8).fill().map(()=>new M),this.satAxes=new Array(3).fill().map(()=>new M),this.satBounds=new Array(3).fill().map(()=>new X),this.alignedSatBounds=new Array(3).fill().map(()=>new X),this.needsUpdate=!1,e&&this.min.copy(e),t&&this.max.copy(t),s&&this.matrix.copy(s)}set(e,t,s){this.min.copy(e),this.max.copy(t),this.matrix.copy(s),this.needsUpdate=!0}copy(e){this.min.copy(e.min),this.max.copy(e.max),this.matrix.copy(e.matrix),this.needsUpdate=!0}}q.prototype.update=function(){return function(){const e=this.matrix,t=this.min,s=this.max,i=this.points;for(let l=0;l<=1;l++)for(let a=0;a<=1;a++)for(let p=0;p<=1;p++){const u=1*l|2*a|4*p,d=i[u];d.x=l?s.x:t.x,d.y=a?s.y:t.y,d.z=p?s.z:t.z,d.applyMatrix4(e)}const o=this.satBounds,r=this.satAxes,f=i[0];for(let l=0;l<3;l++){const a=r[l],p=o[l],u=1<<l,d=i[u];a.subVectors(f,d),p.setFromPoints(a,i)}const c=this.alignedSatBounds;c[0].setFromPointsField(i,"x"),c[1].setFromPointsField(i,"y"),c[2].setFromPointsField(i,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();q.prototype.intersectsBox=function(){const n=new X;return function(t){this.needsUpdate&&this.update();const s=t.min,i=t.max,o=this.satBounds,r=this.satAxes,f=this.alignedSatBounds;if(n.min=s.x,n.max=i.x,f[0].isSeparated(n)||(n.min=s.y,n.max=i.y,f[1].isSeparated(n))||(n.min=s.z,n.max=i.z,f[2].isSeparated(n)))return!1;for(let c=0;c<3;c++){const l=r[c],a=o[c];if(n.setFromBox(l,t),a.isSeparated(n))return!1}return!0}}();q.prototype.intersectsTriangle=function(){const n=new Y,e=new Array(3),t=new X,s=new X,i=new M;return function(r){this.needsUpdate&&this.update(),r.isExtendedTriangle?r.needsUpdate&&r.update():(n.copy(r),n.update(),r=n);const f=this.satBounds,c=this.satAxes;e[0]=r.a,e[1]=r.b,e[2]=r.c;for(let u=0;u<3;u++){const d=f[u],x=c[u];if(t.setFromPoints(x,e),d.isSeparated(t))return!1}const l=r.satBounds,a=r.satAxes,p=this.points;for(let u=0;u<3;u++){const d=l[u],x=a[u];if(t.setFromPoints(x,p),d.isSeparated(t))return!1}for(let u=0;u<3;u++){const d=c[u];for(let x=0;x<4;x++){const B=a[x];if(i.crossVectors(d,B),t.setFromPoints(i,e),s.setFromPoints(i,p),t.isSeparated(s))return!1}}return!0}}();q.prototype.closestPointToPoint=function(){return function(e,t){return this.needsUpdate&&this.update(),t.copy(e).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),t}}();q.prototype.distanceToPoint=function(){const n=new M;return function(t){return this.closestPointToPoint(t,n),t.distanceTo(n)}}();q.prototype.distanceToBox=function(){const n=["x","y","z"],e=new Array(12).fill().map(()=>new H),t=new Array(12).fill().map(()=>new H),s=new M,i=new M;return function(r,f=0,c=null,l=null){if(this.needsUpdate&&this.update(),this.intersectsBox(r))return(c||l)&&(r.getCenter(i),this.closestPointToPoint(i,s),r.closestPointToPoint(s,i),c&&c.copy(s),l&&l.copy(i)),0;const a=f*f,p=r.min,u=r.max,d=this.points;let x=1/0;for(let A=0;A<8;A++){const h=d[A];i.copy(h).clamp(p,u);const m=h.distanceToSquared(i);if(m<x&&(x=m,c&&c.copy(h),l&&l.copy(i),m<a))return Math.sqrt(m)}let B=0;for(let A=0;A<3;A++)for(let h=0;h<=1;h++)for(let m=0;m<=1;m++){const y=(A+1)%3,b=(A+2)%3,P=h<<y|m<<b,w=1<<A|h<<y|m<<b,T=d[P],v=d[w];e[B].set(T,v);const S=n[A],I=n[y],C=n[b],E=t[B],F=E.start,L=E.end;F[S]=p[S],F[I]=h?p[I]:u[I],F[C]=m?p[C]:u[I],L[S]=u[S],L[I]=h?p[I]:u[I],L[C]=m?p[C]:u[I],B++}for(let A=0;A<=1;A++)for(let h=0;h<=1;h++)for(let m=0;m<=1;m++){i.x=A?u.x:p.x,i.y=h?u.y:p.y,i.z=m?u.z:p.z,this.closestPointToPoint(i,s);const y=i.distanceToSquared(s);if(y<x&&(x=y,c&&c.copy(s),l&&l.copy(i),y<a))return Math.sqrt(y)}for(let A=0;A<12;A++){const h=e[A];for(let m=0;m<12;m++){const y=t[m];jt(h,y,s,i);const b=s.distanceToSquared(i);if(b<x&&(x=b,c&&c.copy(s),l&&l.copy(i),b<a))return Math.sqrt(b)}}return Math.sqrt(x)}}();const et=new M,nt=new M,st=new M,Tt=new j,vt=new j,Bt=new j,Jt=new M,Qt=new M,te=new M,gt=new M;function Oe(n,e,t,s,i,o){let r;return o===Ae?r=n.intersectTriangle(s,t,e,!0,i):r=n.intersectTriangle(e,t,s,o!==Pe,i),r===null?null:{distance:n.origin.distanceTo(i),point:i.clone()}}function je(n,e,t,s,i,o,r,f,c){et.fromBufferAttribute(e,o),nt.fromBufferAttribute(e,r),st.fromBufferAttribute(e,f);const l=Oe(n,et,nt,st,gt,c);if(l){s&&(Tt.fromBufferAttribute(s,o),vt.fromBufferAttribute(s,r),Bt.fromBufferAttribute(s,f),l.uv=pt.getInterpolation(gt,et,nt,st,Tt,vt,Bt,new j)),i&&(Tt.fromBufferAttribute(i,o),vt.fromBufferAttribute(i,r),Bt.fromBufferAttribute(i,f),l.uv1=pt.getInterpolation(gt,et,nt,st,Tt,vt,Bt,new j)),t&&(Jt.fromBufferAttribute(t,o),Qt.fromBufferAttribute(t,r),te.fromBufferAttribute(t,f),l.normal=pt.getInterpolation(gt,et,nt,st,Jt,Qt,te,new M),l.normal.dot(n.direction)>0&&l.normal.multiplyScalar(-1));const a={a:o,b:r,c:f,normal:new M,materialIndex:0};pt.getNormal(et,nt,st,a.normal),l.face=a,l.faceIndex=o}return l}function de(n,e,t,s,i){const o=s*3,r=n.index.getX(o),f=n.index.getX(o+1),c=n.index.getX(o+2),{position:l,normal:a,uv:p,uv1:u}=n.attributes,d=je(t,l,a,p,u,r,f,c,e);return d?(d.faceIndex=s,i&&i.push(d),d):null}function He(n,e,t,s,i,o){for(let r=s,f=s+i;r<f;r++)de(n,e,t,r,o)}function Xe(n,e,t,s,i){let o=1/0,r=null;for(let f=s,c=s+i;f<c;f++){const l=de(n,e,t,f);l&&l.distance<o&&(r=l,o=l.distance)}return r}function ee(n,e,t){return n===null||(n.point.applyMatrix4(e.matrixWorld),n.distance=n.point.distanceTo(t.ray.origin),n.object=e,n.distance<t.near||n.distance>t.far)?null:n}function N(n,e,t,s){const i=n.a,o=n.b,r=n.c;let f=e,c=e+1,l=e+2;t&&(f=t.getX(e),c=t.getX(e+1),l=t.getX(e+2)),i.x=s.getX(f),i.y=s.getY(f),i.z=s.getZ(f),o.x=s.getX(c),o.y=s.getY(c),o.z=s.getZ(c),r.x=s.getX(l),r.y=s.getY(l),r.z=s.getZ(l)}function ne(n,e,t,s,i,o,r){const f=t.index,c=t.attributes.position;for(let l=n,a=e+n;l<a;l++)if(N(r,l*3,f,c),r.needsUpdate=!0,s(r,l,i,o))return!0;return!1}class he{constructor(e){this._getNewPrimitive=e,this._primitives=[]}getPrimitive(){const e=this._primitives;return e.length===0?this._getNewPrimitive():e.pop()}releasePrimitive(e){this._primitives.push(e)}}function $(n,e){return e[n+15]===65535}function rt(n,e){return e[n+6]}function mt(n,e){return e[n+14]}function xt(n){return n+8}function wt(n,e){return e[n+6]}function Ye(n,e){return e[n+7]}const ot=new ct,Ft=new M,Ze=["x","y","z"];function qt(n,e,t,s,i){let o=n*2,r=at,f=K,c=G;if($(o,f)){const a=rt(n,c),p=mt(o,f);He(e,t,s,a,p,i)}else{const a=xt(n);Lt(a,r,s,Ft)&&qt(a,e,t,s,i);const p=wt(n,c);Lt(p,r,s,Ft)&&qt(p,e,t,s,i)}}function kt(n,e,t,s){let i=n*2,o=at,r=K,f=G;if($(i,r)){const l=rt(n,f),a=mt(i,r);return Xe(e,t,s,l,a)}else{const l=Ye(n,f),a=Ze[l],u=s.direction[a]>=0;let d,x;u?(d=xt(n),x=wt(n,f)):(d=wt(n,f),x=xt(n));const A=Lt(d,o,s,Ft)?kt(d,e,t,s):null;if(A){const y=A.point[a];if(u?y<=o[x+l]:y>=o[x+l+3])return A}const m=Lt(x,o,s,Ft)?kt(x,e,t,s):null;return A&&m?A.distance<=m.distance?A:m:A||m||null}}const We=function(){let n,e;const t=[],s=new he(()=>new ct);return function(...r){n=s.getPrimitive(),e=s.getPrimitive(),t.push(n,e);const f=i(...r);s.releasePrimitive(n),s.releasePrimitive(e),t.pop(),t.pop();const c=t.length;return c>0&&(e=t[c-1],n=t[c-2]),f};function i(o,r,f,c,l=null,a=0,p=0){function u(y){let b=y*2,P=K,w=G;for(;!$(b,P);)y=xt(y),b=y*2;return rt(y,w)}function d(y){let b=y*2,P=K,w=G;for(;!$(b,P);)y=wt(y,w),b=y*2;return rt(y,w)+mt(b,P)}let x=o*2,B=at,A=K,h=G;if($(x,A)){const y=rt(o,h),b=mt(x,A);return V(o,B,n),c(y,b,!1,p,a+o,n)}else{const y=xt(o),b=wt(o,h);let P=y,w=b,T,v,g,S;if(l&&(g=n,S=e,V(P,B,g),V(w,B,S),T=l(g),v=l(S),v<T)){P=b,w=y;const z=T;T=v,v=z,g=S}g||(g=n,V(P,B,g));const I=$(P*2,A),C=f(g,I,T,p+1,a+P);let E;if(C===Zt){const z=u(P),Z=d(P)-z;E=c(z,Z,!0,p+1,a+P,g)}else E=C&&i(P,r,f,c,l,a,p+1);if(E)return!0;S=e,V(w,B,S);const F=$(w*2,A),L=f(S,F,v,p+1,a+w);let U;if(L===Zt){const z=u(w),Z=d(w)-z;U=c(z,Z,!0,p+1,a+w,S)}else U=L&&i(w,r,f,c,l,a,p+1);return!!U}}}(),$e=function(){const n=new Y,e=new Y,t=new yt,s=new q,i=new q;return function o(r,f,c,l,a=null){let p=r*2,u=at,d=K,x=G;if(a===null&&(c.boundingBox||c.computeBoundingBox(),s.set(c.boundingBox.min,c.boundingBox.max,l),a=s),$(p,d)){const A=f,h=A.index,m=A.attributes.position,y=c.index,b=c.attributes.position,P=rt(r,x),w=mt(p,d);if(t.copy(l).invert(),c.boundsTree)return V(r,u,i),i.matrix.copy(t),i.needsUpdate=!0,c.boundsTree.shapecast({intersectsBounds:v=>i.intersectsBox(v),intersectsTriangle:v=>{v.a.applyMatrix4(l),v.b.applyMatrix4(l),v.c.applyMatrix4(l),v.needsUpdate=!0;for(let g=P*3,S=(w+P)*3;g<S;g+=3)if(N(e,g,h,m),e.needsUpdate=!0,v.intersectsTriangle(e))return!0;return!1}});for(let T=P*3,v=w+P*3;T<v;T+=3){N(n,T,h,m),n.a.applyMatrix4(t),n.b.applyMatrix4(t),n.c.applyMatrix4(t),n.needsUpdate=!0;for(let g=0,S=y.count;g<S;g+=3)if(N(e,g,y,b),e.needsUpdate=!0,n.intersectsTriangle(e))return!0}}else{const A=r+8,h=x[r+6];return V(A,u,ot),!!(a.intersectsBox(ot)&&o(A,f,c,l,a)||(V(h,u,ot),a.intersectsBox(ot)&&o(h,f,c,l,a)))}}}();function Lt(n,e,t,s){return V(n,e,ot),t.intersectBox(ot,s)}const Ot=[];let Et,at,K,G;function dt(n){Et&&Ot.push(Et),Et=n,at=new Float32Array(n),K=new Uint16Array(n),G=new Uint32Array(n)}function St(){Et=null,at=null,K=null,G=null,Ot.length&&dt(Ot.pop())}const Dt=Symbol("skip tree generation"),_t=new ct,Rt=new ct,it=new yt,Q=new q,ft=new q,ut=new M,Mt=new M,Ke=new M,Ge=new M,Je=new M,se=new ct,R=new he(()=>new Y);class ht{static serialize(e,t={}){if(t.isBufferGeometry)return console.warn("MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature."),ht.serialize(arguments[0],{cloneBuffers:arguments[2]===void 0?!0:arguments[2]});t={cloneBuffers:!0,...t};const s=e.geometry,i=e._roots,o=s.getIndex();let r;return t.cloneBuffers?r={roots:i.map(f=>f.slice()),index:o.array.slice()}:r={roots:i,index:o.array},r}static deserialize(e,t,s={}){if(typeof s=="boolean")return console.warn("MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature."),ht.deserialize(arguments[0],arguments[1],{setIndex:arguments[2]===void 0?!0:arguments[2]});s={setIndex:!0,...s};const{index:i,roots:o}=e,r=new ht(t,{...s,[Dt]:!0});if(r._roots=o,s.setIndex){const f=t.getIndex();if(f===null){const c=new le(e.index,1,!1);t.setIndex(c)}else f.array!==i&&(f.array.set(i),f.needsUpdate=!0)}return r}constructor(e,t={}){if(e.isBufferGeometry){if(e.index&&e.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t=Object.assign({strategy:pe,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,[Dt]:!1},t),t.useSharedArrayBuffer&&typeof SharedArrayBuffer>"u")throw new Error("MeshBVH: SharedArrayBuffer is not available.");this._roots=null,t[Dt]||(this._roots=Ne(e,t),!e.boundingBox&&t.setBoundingBox&&(e.boundingBox=this.getBoundingBox(new ct))),this.geometry=e}refit(e=null){e&&Array.isArray(e)&&(e=new Set(e));const t=this.geometry,s=t.index.array,i=t.attributes.position;let o,r,f,c,l=0;const a=this._roots;for(let u=0,d=a.length;u<d;u++)o=a[u],r=new Uint32Array(o),f=new Uint16Array(o),c=new Float32Array(o),p(0,l),l+=o.byteLength;function p(u,d,x=!1){const B=u*2;if(f[B+15]===Vt){const h=r[u+6],m=f[B+14];let y=1/0,b=1/0,P=1/0,w=-1/0,T=-1/0,v=-1/0;for(let g=3*h,S=3*(h+m);g<S;g++){const I=s[g],C=i.getX(I),E=i.getY(I),F=i.getZ(I);C<y&&(y=C),C>w&&(w=C),E<b&&(b=E),E>T&&(T=E),F<P&&(P=F),F>v&&(v=F)}return c[u+0]!==y||c[u+1]!==b||c[u+2]!==P||c[u+3]!==w||c[u+4]!==T||c[u+5]!==v?(c[u+0]=y,c[u+1]=b,c[u+2]=P,c[u+3]=w,c[u+4]=T,c[u+5]=v,!0):!1}else{const h=u+8,m=r[u+6],y=h+d,b=m+d;let P=x,w=!1,T=!1;e?P||(w=e.has(y),T=e.has(b),P=!w&&!T):(w=!0,T=!0);const v=P||w,g=P||T;let S=!1;v&&(S=p(h,d,P));let I=!1;g&&(I=p(m,d,P));const C=S||I;if(C)for(let E=0;E<3;E++){const F=h+E,L=m+E,U=c[F],z=c[F+3],_=c[L],Z=c[L+3];c[u+E]=U<_?U:_,c[u+E+3]=z>Z?z:Z}return C}}}traverse(e,t=0){const s=this._roots[t],i=new Uint32Array(s),o=new Uint16Array(s);r(0);function r(f,c=0){const l=f*2,a=o[l+15]===Vt;if(a){const p=i[f+6],u=o[l+14];e(c,a,new Float32Array(s,f*4,6),p,u)}else{const p=f+Ct/4,u=i[f+6],d=i[f+7];e(c,a,new Float32Array(s,f*4,6),d)||(r(p,c+1),r(u,c+1))}}}raycast(e,t=Xt){const s=this._roots,i=this.geometry,o=[],r=t.isMaterial,f=Array.isArray(t),c=i.groups,l=r?t.side:t;for(let a=0,p=s.length;a<p;a++){const u=f?t[c[a].materialIndex].side:l,d=o.length;if(dt(s[a]),qt(0,i,u,e,o),St(),f){const x=c[a].materialIndex;for(let B=d,A=o.length;B<A;B++)o[B].face.materialIndex=x}}return o}raycastFirst(e,t=Xt){const s=this._roots,i=this.geometry,o=t.isMaterial,r=Array.isArray(t);let f=null;const c=i.groups,l=o?t.side:t;for(let a=0,p=s.length;a<p;a++){const u=r?t[c[a].materialIndex].side:l;dt(s[a]);const d=kt(0,i,u,e);St(),d!=null&&(f==null||d.distance<f.distance)&&(f=d,r&&(d.face.materialIndex=c[a].materialIndex))}return f}intersectsGeometry(e,t){const s=this.geometry;let i=!1;for(const o of this._roots)if(dt(o),i=$e(0,s,e,t),St(),i)break;return i}shapecast(e,t,s){const i=this.geometry;if(e instanceof Function){if(t){const u=t;t=(d,x,B,A)=>{const h=x*3;return u(d,h,h+1,h+2,B,A)}}e={boundsTraverseOrder:s,intersectsBounds:e,intersectsTriangle:t,intersectsRange:null},console.warn("MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.")}const o=R.getPrimitive();let{boundsTraverseOrder:r,intersectsBounds:f,intersectsRange:c,intersectsTriangle:l}=e;if(c&&l){const u=c;c=(d,x,B,A,h)=>u(d,x,B,A,h)?!0:ne(d,x,i,l,B,A,o)}else c||(l?c=(u,d,x,B)=>ne(u,d,i,l,x,B,o):c=(u,d,x)=>x);let a=!1,p=0;for(const u of this._roots){if(dt(u),a=We(0,i,f,c,r,p),St(),a)break;p+=u.byteLength}return R.releasePrimitive(o),a}bvhcast(e,t,s){let{intersectsRanges:i,intersectsTriangles:o}=s;const r=this.geometry.index,f=this.geometry.attributes.position,c=e.geometry.index,l=e.geometry.attributes.position;it.copy(t).invert();const a=R.getPrimitive(),p=R.getPrimitive();if(o){let d=function(x,B,A,h,m,y,b,P){for(let w=A,T=A+h;w<T;w++){N(p,w*3,c,l),p.a.applyMatrix4(t),p.b.applyMatrix4(t),p.c.applyMatrix4(t),p.needsUpdate=!0;for(let v=x,g=x+B;v<g;v++)if(N(a,v*3,r,f),a.needsUpdate=!0,o(a,p,v,w,m,y,b,P))return!0}return!1};if(i){const x=i;i=function(B,A,h,m,y,b,P,w){return x(B,A,h,m,y,b,P,w)?!0:d(B,A,h,m,y,b,P,w)}}else i=d}e.getBoundingBox(Rt),Rt.applyMatrix4(t);const u=this.shapecast({intersectsBounds:d=>Rt.intersectsBox(d),intersectsRange:(d,x,B,A,h,m)=>(_t.copy(m),_t.applyMatrix4(it),e.shapecast({intersectsBounds:y=>_t.intersectsBox(y),intersectsRange:(y,b,P,w,T)=>i(d,x,y,b,A,h,w,T)}))});return R.releasePrimitive(a),R.releasePrimitive(p),u}intersectsBox(e,t){return Q.set(e.min,e.max,t),Q.needsUpdate=!0,this.shapecast({intersectsBounds:s=>Q.intersectsBox(s),intersectsTriangle:s=>Q.intersectsTriangle(s)})}intersectsSphere(e){return this.shapecast({intersectsBounds:t=>e.intersectsBox(t),intersectsTriangle:t=>t.intersectsSphere(e)})}closestPointToGeometry(e,t,s={},i={},o=0,r=1/0){e.boundingBox||e.computeBoundingBox(),Q.set(e.boundingBox.min,e.boundingBox.max,t),Q.needsUpdate=!0;const f=this.geometry,c=f.attributes.position,l=f.index,a=e.attributes.position,p=e.index,u=R.getPrimitive(),d=R.getPrimitive();let x=Mt,B=Ke,A=null,h=null;i&&(A=Ge,h=Je);let m=1/0,y=null,b=null;return it.copy(t).invert(),ft.matrix.copy(it),this.shapecast({boundsTraverseOrder:P=>Q.distanceToBox(P),intersectsBounds:(P,w,T)=>T<m&&T<r?(w&&(ft.min.copy(P.min),ft.max.copy(P.max),ft.needsUpdate=!0),!0):!1,intersectsRange:(P,w)=>{if(e.boundsTree)return e.boundsTree.shapecast({boundsTraverseOrder:T=>ft.distanceToBox(T),intersectsBounds:(T,v,g)=>g<m&&g<r,intersectsRange:(T,v)=>{for(let g=T*3,S=(T+v)*3;g<S;g+=3){N(d,g,p,a),d.a.applyMatrix4(t),d.b.applyMatrix4(t),d.c.applyMatrix4(t),d.needsUpdate=!0;for(let I=P*3,C=(P+w)*3;I<C;I+=3){N(u,I,l,c),u.needsUpdate=!0;const E=u.distanceToTriangle(d,x,A);if(E<m&&(B.copy(x),h&&h.copy(A),m=E,y=I/3,b=g/3),E<o)return!0}}}});{const T=p?p.count:a.count;for(let v=0,g=T;v<g;v+=3){N(d,v,p,a),d.a.applyMatrix4(t),d.b.applyMatrix4(t),d.c.applyMatrix4(t),d.needsUpdate=!0;for(let S=P*3,I=(P+w)*3;S<I;S+=3){N(u,S,l,c),u.needsUpdate=!0;const C=u.distanceToTriangle(d,x,A);if(C<m&&(B.copy(x),h&&h.copy(A),m=C,y=S/3,b=v/3),C<o)return!0}}}}}),R.releasePrimitive(u),R.releasePrimitive(d),m===1/0?null:(s.point?s.point.copy(B):s.point=B.clone(),s.distance=m,s.faceIndex=y,i&&(i.point?i.point.copy(h):i.point=h.clone(),i.point.applyMatrix4(it),B.applyMatrix4(it),i.distance=B.sub(i.point).length(),i.faceIndex=b),s)}closestPointToPoint(e,t={},s=0,i=1/0){const o=s*s,r=i*i;let f=1/0,c=null;if(this.shapecast({boundsTraverseOrder:a=>(ut.copy(e).clamp(a.min,a.max),ut.distanceToSquared(e)),intersectsBounds:(a,p,u)=>u<f&&u<r,intersectsTriangle:(a,p)=>{a.closestPointToPoint(e,ut);const u=e.distanceToSquared(ut);return u<f&&(Mt.copy(ut),f=u,c=p),u<o}}),f===1/0)return null;const l=Math.sqrt(f);return t.point?t.point.copy(Mt):t.point=Mt.clone(),t.distance=l,t.faceIndex=c,t}getBoundingBox(e){return e.makeEmpty(),this._roots.forEach(s=>{V(0,new Float32Array(s),se),e.union(se)}),e}}const Nt=new Te,ie=new yt,Qe=ue.prototype.raycast;function tn(n,e){if(this.geometry.boundsTree){if(this.material===void 0)return;ie.copy(this.matrixWorld).invert(),Nt.copy(n.ray).applyMatrix4(ie);const t=this.geometry.boundsTree;if(n.firstHitOnly===!0){const s=ee(t.raycastFirst(Nt,this.material),this,n);s&&e.push(s)}else{const s=t.raycast(Nt,this.material);for(let i=0,o=s.length;i<o;i++){const r=ee(s[i],this,n);r&&e.push(r)}}}else Qe.call(this,n,e)}function en(n){return this.boundsTree=new ht(this,n),this.boundsTree}function nn(){this.boundsTree=null}const sn=()=>{Yt.prototype.computeBoundsTree=en,Yt.prototype.disposeBoundsTree=nn,ue.prototype.raycast=tn,ae.prototype.firstHitOnly=!0},on=`import { MouseRaycaster } from 'trzy'

const raycaster = new MouseRaycaster({
  scene, // alternatively, pass objects: THREE.Object3D[]
  camera,
  renderer,
  recursive: true,
})

raycaster.on('move', (event) => console.log(event.intersections))
raycaster.on('click', (event) => console.log(event.intersections))

// later
raycaster.dispose()
`,fn={title:"Mouse Raycaster",parameters:{docs:{source:{code:on}}}},rn=()=>{sn();const{scene:n,camera:e,canvas:t,renderer:s,update:i}=ve();return Be().then(()=>{const o=new M(1,1,1);let r=!1,f=.1;const c=n.getObjectByName("Strawberry");c.traverse(a=>{var p,u;return(u=(p=a.geometry)==null?void 0:p.computeBoundsTree)==null?void 0:u.call(p)});const l=new ge({renderer:s});l.recursive=!0,l.objects=[c],l.camera=e.current,l.on("move",a=>{a.intersections.length>0?(f=.1,o.setScalar(.12)):(f=.1,o.setScalar(.1)),r=a.intersections.length>0}),l.on("click",a=>{a.intersections.length!==0&&(f=.2,o.setScalar(o.x===.17?r?.12:.1:.17))}),i(()=>c.scale.lerp(o,f))}),t},It={render:rn};var oe,re,ce;It.parameters={...It.parameters,docs:{...(oe=It.parameters)==null?void 0:oe.docs,source:{originalSource:`{
  render
}`,...(ce=(re=It.parameters)==null?void 0:re.docs)==null?void 0:ce.source}}};const un=["Primary"];export{It as Primary,un as __namedExportsOrder,fn as default};
//# sourceMappingURL=index.stories-25c72823.js.map
