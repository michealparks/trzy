var pe=Object.defineProperty;var de=(n,e,t)=>e in n?pe(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t;var D=(n,e,t)=>(de(n,typeof e!="symbol"?e+"":e,t),t),he=(n,e,t)=>{if(!e.has(n))throw TypeError("Cannot "+t)};var J=(n,e,t)=>(he(n,e,"read from private field"),t?t.call(n):e.get(n)),qt=(n,e,t)=>{if(e.has(n))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(n):e.set(n,t)};import{d as ye,V as $,R as oe,e as re,f as C,P as ce,L as j,T as Ut,S as me,g as ft,h as xe,D as we,i as it,F as kt,j as be,M as ae,k as Ot,t as Ae}from"./index-aa3706bc.js";import{s as Pe}from"./lib-b8bd67a6.js";var O;class Te extends ye{constructor(t){super();D(this,"camera");D(this,"raycaster");D(this,"objects",[]);D(this,"pointerDown",new $);D(this,"pointerUp",new $);D(this,"pointerMove",new $);D(this,"recursive",!0);D(this,"renderer");qt(this,O,{click:0,move:0});D(this,"onPointerDown",t=>{this.getNormalizedCoordinates(t,this.pointerDown)});D(this,"onPointerUp",t=>{if(this.getNormalizedCoordinates(t,this.pointerUp),this.pointerDown.sub(this.pointerUp).lengthSq()>.001)return;this.raycaster.setFromCamera(this.pointerUp,this.camera);const s=this.raycaster.intersectObjects(this.objects,this.recursive);this.dispatchEvent({type:"click",intersections:s})});D(this,"onPointerMove",t=>{this.getNormalizedCoordinates(t,this.pointerMove),this.raycaster.setFromCamera(this.pointerMove,this.camera);const s=this.raycaster.intersectObjects(this.objects,this.recursive);this.dispatchEvent({type:"move",intersections:s})});this.camera=t.camera,this.renderer=t.renderer,this.raycaster=t.raycaster??new oe,this.objects=t.objects??(t.scene?[t.scene]:[]),this.recursive=t.recursive??!0}on(t,s){super.addEventListener(t,s);const i=this.renderer.domElement;t==="move"&&J(this,O).move===0?i.addEventListener("pointermove",this.onPointerMove,{passive:!0}):t==="click"&&J(this,O).click===0&&(i.addEventListener("pointerdown",this.onPointerDown,{passive:!0}),i.addEventListener("pointerup",this.onPointerUp,{passive:!0})),J(this,O)[t]+=1}off(t,s){super.removeEventListener(t,s);const i=this.renderer.domElement;J(this,O)[t]-=1,t==="move"&&J(this,O).move<=0?i.removeEventListener("pointermove",this.onPointerMove):t==="click"&&J(this,O).click<=0&&(i.addEventListener("pointerdown",this.onPointerDown,{passive:!0}),i.addEventListener("pointerup",this.onPointerUp,{passive:!0}))}getNormalizedCoordinates(t,s){const i=this.renderer.domElement,o=i.getBoundingClientRect();s.x=(t.clientX-o.x)/i.clientWidth*2-1,s.y=-((t.clientY-o.y)/i.clientHeight*2)+1}dispose(){const t=this.renderer.domElement;t.removeEventListener("pointerdown",this.onPointerDown),t.removeEventListener("pointerup",this.onPointerUp),t.removeEventListener("pointermove",this.onPointerMove)}}O=new WeakMap;const le=0,ve=1,Be=2,jt=2,It=1.25,Ht=1,Bt=6*4+4+4,Dt=65535,ge=Math.pow(2,-24);class yt{constructor(){}}function V(n,e,t){return t.min.x=e[n],t.min.y=e[n+1],t.min.z=e[n+2],t.max.x=e[n+3],t.max.y=e[n+4],t.max.z=e[n+5],t}function Xt(n){let e=-1,t=-1/0;for(let s=0;s<3;s++){const i=n[s+3]-n[s];i>t&&(t=i,e=s)}return e}function Yt(n,e){e.set(n)}function Zt(n,e,t){let s,i;for(let o=0;o<3;o++){const r=o+3;s=n[o],i=e[o],t[o]=s<i?s:i,s=n[r],i=e[r],t[r]=s>i?s:i}}function mt(n,e,t){for(let s=0;s<3;s++){const i=e[n+2*s],o=e[n+2*s+1],r=i-o,l=i+o;r<t[s]&&(t[s]=r),l>t[s+3]&&(t[s+3]=l)}}function rt(n){const e=n[3]-n[0],t=n[4]-n[1],s=n[5]-n[2];return 2*(e*t+t*s+s*e)}function Se(n,e){if(!n.index){const t=n.attributes.position.count,s=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;let i;t>65535?i=new Uint32Array(new s(4*t)):i=new Uint16Array(new s(2*t)),n.setIndex(new re(i,1));for(let o=0;o<t;o++)i[o]=o}}function Me(n){if(!n.groups||!n.groups.length)return[{offset:0,count:n.index.count/3}];const e=[],t=new Set;for(const i of n.groups)t.add(i.start),t.add(i.start+i.count);const s=Array.from(t.values()).sort((i,o)=>i-o);for(let i=0;i<s.length-1;i++){const o=s[i],r=s[i+1];e.push({offset:o/3,count:(r-o)/3})}return e}function Ct(n,e,t,s,i=null){let o=1/0,r=1/0,l=1/0,c=-1/0,u=-1/0,a=-1/0,p=1/0,f=1/0,h=1/0,x=-1/0,B=-1/0,A=-1/0;const d=i!==null;for(let m=e*6,y=(e+t)*6;m<y;m+=6){const b=n[m+0],P=n[m+1],w=b-P,T=b+P;w<o&&(o=w),T>c&&(c=T),d&&b<p&&(p=b),d&&b>x&&(x=b);const v=n[m+2],g=n[m+3],S=v-g,M=v+g;S<r&&(r=S),M>u&&(u=M),d&&v<f&&(f=v),d&&v>B&&(B=v);const I=n[m+4],E=n[m+5],F=I-E,L=I+E;F<l&&(l=F),L>a&&(a=L),d&&I<h&&(h=I),d&&I>A&&(A=I)}s[0]=o,s[1]=r,s[2]=l,s[3]=c,s[4]=u,s[5]=a,d&&(i[0]=p,i[1]=f,i[2]=h,i[3]=x,i[4]=B,i[5]=A)}function Ie(n,e,t,s){let i=1/0,o=1/0,r=1/0,l=-1/0,c=-1/0,u=-1/0;for(let a=e*6,p=(e+t)*6;a<p;a+=6){const f=n[a+0];f<i&&(i=f),f>l&&(l=f);const h=n[a+2];h<o&&(o=h),h>c&&(c=h);const x=n[a+4];x<r&&(r=x),x>u&&(u=x)}s[0]=i,s[1]=o,s[2]=r,s[3]=l,s[4]=c,s[5]=u}function Ce(n,e,t,s,i){let o=t,r=t+s-1;const l=i.pos,c=i.axis*2;for(;;){for(;o<=r&&e[o*6+c]<l;)o++;for(;o<=r&&e[r*6+c]>=l;)r--;if(o<r){for(let u=0;u<3;u++){let a=n[o*3+u];n[o*3+u]=n[r*3+u],n[r*3+u]=a;let p=e[o*6+u*2+0];e[o*6+u*2+0]=e[r*6+u*2+0],e[r*6+u*2+0]=p;let f=e[o*6+u*2+1];e[o*6+u*2+1]=e[r*6+u*2+1],e[r*6+u*2+1]=f}o++,r--}else return o}}const k=32,Ee=(n,e)=>n.candidate-e.candidate,Z=new Array(k).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),xt=new Float32Array(6);function Fe(n,e,t,s,i,o){let r=-1,l=0;if(o===le)r=Xt(e),r!==-1&&(l=(e[r]+e[r+3])/2);else if(o===ve)r=Xt(n),r!==-1&&(l=Le(t,s,i,r));else if(o===Be){const c=rt(n);let u=It*i;const a=s*6,p=(s+i)*6;for(let f=0;f<3;f++){const h=e[f],A=(e[f+3]-h)/k;if(i<k/4){const d=[...Z];d.length=i;let m=0;for(let b=a;b<p;b+=6,m++){const P=d[m];P.candidate=t[b+2*f],P.count=0;const{bounds:w,leftCacheBounds:T,rightCacheBounds:v}=P;for(let g=0;g<3;g++)v[g]=1/0,v[g+3]=-1/0,T[g]=1/0,T[g+3]=-1/0,w[g]=1/0,w[g+3]=-1/0;mt(b,t,w)}d.sort(Ee);let y=i;for(let b=0;b<y;b++){const P=d[b];for(;b+1<y&&d[b+1].candidate===P.candidate;)d.splice(b+1,1),y--}for(let b=a;b<p;b+=6){const P=t[b+2*f];for(let w=0;w<y;w++){const T=d[w];P>=T.candidate?mt(b,t,T.rightCacheBounds):(mt(b,t,T.leftCacheBounds),T.count++)}}for(let b=0;b<y;b++){const P=d[b],w=P.count,T=i-P.count,v=P.leftCacheBounds,g=P.rightCacheBounds;let S=0;w!==0&&(S=rt(v)/c);let M=0;T!==0&&(M=rt(g)/c);const I=Ht+It*(S*w+M*T);I<u&&(r=f,u=I,l=P.candidate)}}else{for(let y=0;y<k;y++){const b=Z[y];b.count=0,b.candidate=h+A+y*A;const P=b.bounds;for(let w=0;w<3;w++)P[w]=1/0,P[w+3]=-1/0}for(let y=a;y<p;y+=6){let w=~~((t[y+2*f]-h)/A);w>=k&&(w=k-1);const T=Z[w];T.count++,mt(y,t,T.bounds)}const d=Z[k-1];Yt(d.bounds,d.rightCacheBounds);for(let y=k-2;y>=0;y--){const b=Z[y],P=Z[y+1];Zt(b.bounds,P.rightCacheBounds,b.rightCacheBounds)}let m=0;for(let y=0;y<k-1;y++){const b=Z[y],P=b.count,w=b.bounds,v=Z[y+1].rightCacheBounds;P!==0&&(m===0?Yt(w,xt):Zt(w,xt,xt)),m+=P;let g=0,S=0;m!==0&&(g=rt(xt)/c);const M=i-m;M!==0&&(S=rt(v)/c);const I=Ht+It*(g*m+S*M);I<u&&(r=f,u=I,l=b.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${o} used.`);return{axis:r,pos:l}}function Le(n,e,t,s){let i=0;for(let o=e,r=e+t;o<r;o++)i+=n[o*6+s*2];return i/t}function ze(n,e){const t=n.attributes.position,s=n.index.array,i=s.length/3,o=new Float32Array(i*6),r=t.normalized,l=t.array,c=t.offset||0;let u=3;t.isInterleavedBufferAttribute&&(u=t.data.stride);const a=["getX","getY","getZ"];for(let p=0;p<i;p++){const f=p*3,h=p*6;let x,B,A;r?(x=s[f+0],B=s[f+1],A=s[f+2]):(x=s[f+0]*u+c,B=s[f+1]*u+c,A=s[f+2]*u+c);for(let d=0;d<3;d++){let m,y,b;r?(m=t[a[d]](x),y=t[a[d]](B),b=t[a[d]](A)):(m=l[x+d],y=l[B+d],b=l[A+d]);let P=m;y<P&&(P=y),b<P&&(P=b);let w=m;y>w&&(w=y),b>w&&(w=b);const T=(w-P)/2,v=d*2;o[h+v+0]=P+T,o[h+v+1]=T+(Math.abs(P)+T)*ge,P<e[d]&&(e[d]=P),w>e[d+3]&&(e[d+3]=w)}}return o}function Ue(n,e){function t(d){f&&f(d/h)}function s(d,m,y,b=null,P=0){if(!x&&P>=c&&(x=!0,u&&(console.warn(`MeshBVH: Max depth of ${c} reached when generating BVH. Consider increasing maxDepth.`),console.warn(n))),y<=a||P>=c)return t(m+y),d.offset=m,d.count=y,d;const w=Fe(d.boundingData,b,r,m,y,p);if(w.axis===-1)return t(m+y),d.offset=m,d.count=y,d;const T=Ce(l,r,m,y,w);if(T===m||T===m+y)t(m+y),d.offset=m,d.count=y;else{d.splitAxis=w.axis;const v=new yt,g=m,S=T-m;d.left=v,v.boundingData=new Float32Array(6),Ct(r,g,S,v.boundingData,o),s(v,g,S,o,P+1);const M=new yt,I=T,E=y-S;d.right=M,M.boundingData=new Float32Array(6),Ct(r,I,E,M.boundingData,o),s(M,I,E,o,P+1)}return d}Se(n,e);const i=new Float32Array(6),o=new Float32Array(6),r=ze(n,i),l=n.index.array,c=e.maxDepth,u=e.verbose,a=e.maxLeafTris,p=e.strategy,f=e.onProgress,h=n.index.count/3;let x=!1;const B=[],A=Me(n);if(A.length===1){const d=A[0],m=new yt;m.boundingData=i,Ie(r,d.offset,d.count,o),s(m,d.offset,d.count,o),B.push(m)}else for(let d of A){const m=new yt;m.boundingData=new Float32Array(6),Ct(r,d.offset,d.count,m.boundingData,o),s(m,d.offset,d.count,o),B.push(m)}return B}function De(n,e){const t=Ue(n,e);let s,i,o;const r=[],l=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;for(let a=0;a<t.length;a++){const p=t[a];let f=c(p);const h=new l(Bt*f);s=new Float32Array(h),i=new Uint32Array(h),o=new Uint16Array(h),u(0,p),r.push(h)}return r;function c(a){return a.count?1:1+c(a.left)+c(a.right)}function u(a,p){const f=a/4,h=a/2,x=!!p.count,B=p.boundingData;for(let A=0;A<6;A++)s[f+A]=B[A];if(x){const A=p.offset,d=p.count;return i[f+6]=A,o[h+14]=d,o[h+15]=Dt,a+Bt}else{const A=p.left,d=p.right,m=p.splitAxis;let y;if(y=u(a+Bt,A),y/4>Math.pow(2,32))throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return i[f+6]=y/4,y=u(y,d),i[f+7]=m,y}}}class H{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(e,t){let s=1/0,i=-1/0;for(let o=0,r=e.length;o<r;o++){const c=e[o][t];s=c<s?c:s,i=c>i?c:i}this.min=s,this.max=i}setFromPoints(e,t){let s=1/0,i=-1/0;for(let o=0,r=t.length;o<r;o++){const l=t[o],c=e.dot(l);s=c<s?c:s,i=c>i?c:i}this.min=s,this.max=i}isSeparated(e){return this.min>e.max||e.min>this.max}}H.prototype.setFromBox=function(){const n=new C;return function(t,s){const i=s.min,o=s.max;let r=1/0,l=-1/0;for(let c=0;c<=1;c++)for(let u=0;u<=1;u++)for(let a=0;a<=1;a++){n.x=i.x*c+o.x*(1-c),n.y=i.y*u+o.y*(1-u),n.z=i.z*a+o.z*(1-a);const p=t.dot(n);r=Math.min(p,r),l=Math.max(p,l)}this.min=r,this.max=l}}();const Re=function(){const n=new C,e=new C,t=new C;return function(i,o,r){const l=i.start,c=n,u=o.start,a=e;t.subVectors(l,u),n.subVectors(i.end,i.start),e.subVectors(o.end,o.start);const p=t.dot(a),f=a.dot(c),h=a.dot(a),x=t.dot(c),A=c.dot(c)*h-f*f;let d,m;A!==0?d=(p*f-x*h)/A:d=0,m=(p+d*f)/h,r.x=d,r.y=m}}(),Vt=function(){const n=new $,e=new C,t=new C;return function(i,o,r,l){Re(i,o,n);let c=n.x,u=n.y;if(c>=0&&c<=1&&u>=0&&u<=1){i.at(c,r),o.at(u,l);return}else if(c>=0&&c<=1){u<0?o.at(0,l):o.at(1,l),i.closestPointToPoint(l,!0,r);return}else if(u>=0&&u<=1){c<0?i.at(0,r):i.at(1,r),o.closestPointToPoint(r,!0,l);return}else{let a;c<0?a=i.start:a=i.end;let p;u<0?p=o.start:p=o.end;const f=e,h=t;if(i.closestPointToPoint(p,!0,e),o.closestPointToPoint(a,!0,t),f.distanceToSquared(p)<=h.distanceToSquared(a)){r.copy(f),l.copy(p);return}else{r.copy(a),l.copy(h);return}}}}(),_e=function(){const n=new C,e=new C,t=new ce,s=new j;return function(o,r){const{radius:l,center:c}=o,{a:u,b:a,c:p}=r;if(s.start=u,s.end=a,s.closestPointToPoint(c,!0,n).distanceTo(c)<=l||(s.start=u,s.end=p,s.closestPointToPoint(c,!0,n).distanceTo(c)<=l)||(s.start=a,s.end=p,s.closestPointToPoint(c,!0,n).distanceTo(c)<=l))return!0;const B=r.getPlane(t);if(Math.abs(B.distanceToPoint(c))<=l){const d=B.projectPoint(c,e);if(r.containsPoint(d))return!0}return!1}}(),Ne=1e-15;function tt(n){return Math.abs(n)<Ne}class X extends Ut{constructor(...e){super(...e),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new C),this.satBounds=new Array(4).fill().map(()=>new H),this.points=[this.a,this.b,this.c],this.sphere=new me,this.plane=new ce,this.needsUpdate=!0}intersectsSphere(e){return _e(e,this)}update(){const e=this.a,t=this.b,s=this.c,i=this.points,o=this.satAxes,r=this.satBounds,l=o[0],c=r[0];this.getNormal(l),c.setFromPoints(l,i);const u=o[1],a=r[1];u.subVectors(e,t),a.setFromPoints(u,i);const p=o[2],f=r[2];p.subVectors(t,s),f.setFromPoints(p,i);const h=o[3],x=r[3];h.subVectors(s,e),x.setFromPoints(h,i),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(l,e),this.needsUpdate=!1}}X.prototype.closestPointToSegment=function(){const n=new C,e=new C,t=new j;return function(i,o=null,r=null){const{start:l,end:c}=i,u=this.points;let a,p=1/0;for(let f=0;f<3;f++){const h=(f+1)%3;t.start.copy(u[f]),t.end.copy(u[h]),Vt(t,i,n,e),a=n.distanceToSquared(e),a<p&&(p=a,o&&o.copy(n),r&&r.copy(e))}return this.closestPointToPoint(l,n),a=l.distanceToSquared(n),a<p&&(p=a,o&&o.copy(n),r&&r.copy(l)),this.closestPointToPoint(c,n),a=c.distanceToSquared(n),a<p&&(p=a,o&&o.copy(n),r&&r.copy(c)),Math.sqrt(p)}}();X.prototype.intersectsTriangle=function(){const n=new X,e=new Array(3),t=new Array(3),s=new H,i=new H,o=new C,r=new C,l=new C,c=new C,u=new j,a=new j,p=new j;return function(h,x=null,B=!1){this.needsUpdate&&this.update(),h.isExtendedTriangle?h.needsUpdate&&h.update():(n.copy(h),n.update(),h=n);const A=this.plane,d=h.plane;if(Math.abs(A.normal.dot(d.normal))>1-1e-10){const m=this.satBounds,y=this.satAxes;t[0]=h.a,t[1]=h.b,t[2]=h.c;for(let w=0;w<4;w++){const T=m[w],v=y[w];if(s.setFromPoints(v,t),T.isSeparated(s))return!1}const b=h.satBounds,P=h.satAxes;e[0]=this.a,e[1]=this.b,e[2]=this.c;for(let w=0;w<4;w++){const T=b[w],v=P[w];if(s.setFromPoints(v,e),T.isSeparated(s))return!1}for(let w=0;w<4;w++){const T=y[w];for(let v=0;v<4;v++){const g=P[v];if(o.crossVectors(T,g),s.setFromPoints(o,e),i.setFromPoints(o,t),s.isSeparated(i))return!1}}return x&&(B||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),x.start.set(0,0,0),x.end.set(0,0,0)),!0}else{const m=this.points;let y=!1,b=0;for(let F=0;F<3;F++){const L=m[F],U=m[(F+1)%3];u.start.copy(L),u.end.copy(U),u.delta(r);const z=y?a.start:a.end,R=tt(d.distanceToPoint(L));if(tt(d.normal.dot(r))&&R){a.copy(u),b=2;break}if((d.intersectLine(u,z)||R)&&!tt(z.distanceTo(U))){if(b++,y)break;y=!0}}if(b===1&&h.containsPoint(a.end))return x&&(x.start.copy(a.end),x.end.copy(a.end)),!0;if(b!==2)return!1;const P=h.points;let w=!1,T=0;for(let F=0;F<3;F++){const L=P[F],U=P[(F+1)%3];u.start.copy(L),u.end.copy(U),u.delta(l);const z=w?p.start:p.end,R=tt(A.distanceToPoint(L));if(tt(A.normal.dot(l))&&R){p.copy(u),T=2;break}if((A.intersectLine(u,z)||R)&&!tt(z.distanceTo(U))){if(T++,w)break;w=!0}}if(T===1&&this.containsPoint(p.end))return x&&(x.start.copy(p.end),x.end.copy(p.end)),!0;if(T!==2)return!1;if(a.delta(r),p.delta(l),r.dot(l)<0){let F=p.start;p.start=p.end,p.end=F}const v=a.start.dot(r),g=a.end.dot(r),S=p.start.dot(r),M=p.end.dot(r),I=g<S,E=v<M;return v!==M&&S!==g&&I===E?!1:(x&&(c.subVectors(a.start,p.start),c.dot(r)>0?x.start.copy(a.start):x.start.copy(p.start),c.subVectors(a.end,p.end),c.dot(r)<0?x.end.copy(a.end):x.end.copy(p.end)),!0)}}}();X.prototype.distanceToPoint=function(){const n=new C;return function(t){return this.closestPointToPoint(t,n),t.distanceTo(n)}}();X.prototype.distanceToTriangle=function(){const n=new C,e=new C,t=["a","b","c"],s=new j,i=new j;return function(r,l=null,c=null){const u=l||c?s:null;if(this.intersectsTriangle(r,u))return(l||c)&&(l&&u.getCenter(l),c&&u.getCenter(c)),0;let a=1/0;for(let p=0;p<3;p++){let f;const h=t[p],x=r[h];this.closestPointToPoint(x,n),f=x.distanceToSquared(n),f<a&&(a=f,l&&l.copy(n),c&&c.copy(x));const B=this[h];r.closestPointToPoint(B,n),f=B.distanceToSquared(n),f<a&&(a=f,l&&l.copy(B),c&&c.copy(n))}for(let p=0;p<3;p++){const f=t[p],h=t[(p+1)%3];s.set(this[f],this[h]);for(let x=0;x<3;x++){const B=t[x],A=t[(x+1)%3];i.set(r[B],r[A]),Vt(s,i,n,e);const d=n.distanceToSquared(e);d<a&&(a=d,l&&l.copy(n),c&&c.copy(e))}}return Math.sqrt(a)}}();class q{constructor(e,t,s){this.isOrientedBox=!0,this.min=new C,this.max=new C,this.matrix=new ft,this.invMatrix=new ft,this.points=new Array(8).fill().map(()=>new C),this.satAxes=new Array(3).fill().map(()=>new C),this.satBounds=new Array(3).fill().map(()=>new H),this.alignedSatBounds=new Array(3).fill().map(()=>new H),this.needsUpdate=!1,e&&this.min.copy(e),t&&this.max.copy(t),s&&this.matrix.copy(s)}set(e,t,s){this.min.copy(e),this.max.copy(t),this.matrix.copy(s),this.needsUpdate=!0}copy(e){this.min.copy(e.min),this.max.copy(e.max),this.matrix.copy(e.matrix),this.needsUpdate=!0}}q.prototype.update=function(){return function(){const e=this.matrix,t=this.min,s=this.max,i=this.points;for(let u=0;u<=1;u++)for(let a=0;a<=1;a++)for(let p=0;p<=1;p++){const f=1*u|2*a|4*p,h=i[f];h.x=u?s.x:t.x,h.y=a?s.y:t.y,h.z=p?s.z:t.z,h.applyMatrix4(e)}const o=this.satBounds,r=this.satAxes,l=i[0];for(let u=0;u<3;u++){const a=r[u],p=o[u],f=1<<u,h=i[f];a.subVectors(l,h),p.setFromPoints(a,i)}const c=this.alignedSatBounds;c[0].setFromPointsField(i,"x"),c[1].setFromPointsField(i,"y"),c[2].setFromPointsField(i,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();q.prototype.intersectsBox=function(){const n=new H;return function(t){this.needsUpdate&&this.update();const s=t.min,i=t.max,o=this.satBounds,r=this.satAxes,l=this.alignedSatBounds;if(n.min=s.x,n.max=i.x,l[0].isSeparated(n)||(n.min=s.y,n.max=i.y,l[1].isSeparated(n))||(n.min=s.z,n.max=i.z,l[2].isSeparated(n)))return!1;for(let c=0;c<3;c++){const u=r[c],a=o[c];if(n.setFromBox(u,t),a.isSeparated(n))return!1}return!0}}();q.prototype.intersectsTriangle=function(){const n=new X,e=new Array(3),t=new H,s=new H,i=new C;return function(r){this.needsUpdate&&this.update(),r.isExtendedTriangle?r.needsUpdate&&r.update():(n.copy(r),n.update(),r=n);const l=this.satBounds,c=this.satAxes;e[0]=r.a,e[1]=r.b,e[2]=r.c;for(let f=0;f<3;f++){const h=l[f],x=c[f];if(t.setFromPoints(x,e),h.isSeparated(t))return!1}const u=r.satBounds,a=r.satAxes,p=this.points;for(let f=0;f<3;f++){const h=u[f],x=a[f];if(t.setFromPoints(x,p),h.isSeparated(t))return!1}for(let f=0;f<3;f++){const h=c[f];for(let x=0;x<4;x++){const B=a[x];if(i.crossVectors(h,B),t.setFromPoints(i,e),s.setFromPoints(i,p),t.isSeparated(s))return!1}}return!0}}();q.prototype.closestPointToPoint=function(){return function(e,t){return this.needsUpdate&&this.update(),t.copy(e).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),t}}();q.prototype.distanceToPoint=function(){const n=new C;return function(t){return this.closestPointToPoint(t,n),t.distanceTo(n)}}();q.prototype.distanceToBox=function(){const n=["x","y","z"],e=new Array(12).fill().map(()=>new j),t=new Array(12).fill().map(()=>new j),s=new C,i=new C;return function(r,l=0,c=null,u=null){if(this.needsUpdate&&this.update(),this.intersectsBox(r))return(c||u)&&(r.getCenter(i),this.closestPointToPoint(i,s),r.closestPointToPoint(s,i),c&&c.copy(s),u&&u.copy(i)),0;const a=l*l,p=r.min,f=r.max,h=this.points;let x=1/0;for(let A=0;A<8;A++){const d=h[A];i.copy(d).clamp(p,f);const m=d.distanceToSquared(i);if(m<x&&(x=m,c&&c.copy(d),u&&u.copy(i),m<a))return Math.sqrt(m)}let B=0;for(let A=0;A<3;A++)for(let d=0;d<=1;d++)for(let m=0;m<=1;m++){const y=(A+1)%3,b=(A+2)%3,P=d<<y|m<<b,w=1<<A|d<<y|m<<b,T=h[P],v=h[w];e[B].set(T,v);const S=n[A],M=n[y],I=n[b],E=t[B],F=E.start,L=E.end;F[S]=p[S],F[M]=d?p[M]:f[M],F[I]=m?p[I]:f[M],L[S]=f[S],L[M]=d?p[M]:f[M],L[I]=m?p[I]:f[M],B++}for(let A=0;A<=1;A++)for(let d=0;d<=1;d++)for(let m=0;m<=1;m++){i.x=A?f.x:p.x,i.y=d?f.y:p.y,i.z=m?f.z:p.z,this.closestPointToPoint(i,s);const y=i.distanceToSquared(s);if(y<x&&(x=y,c&&c.copy(s),u&&u.copy(i),y<a))return Math.sqrt(y)}for(let A=0;A<12;A++){const d=e[A];for(let m=0;m<12;m++){const y=t[m];Vt(d,y,s,i);const b=s.distanceToSquared(i);if(b<x&&(x=b,c&&c.copy(s),u&&u.copy(i),b<a))return Math.sqrt(b)}}return Math.sqrt(x)}}();const wt=new C,bt=new C,At=new C,Wt=new $,$t=new $,Kt=new $,Gt=new C;function Ve(n,e,t,s,i,o){let r;return o===xe?r=n.intersectTriangle(s,t,e,!0,i):r=n.intersectTriangle(e,t,s,o!==we,i),r===null?null:{distance:n.origin.distanceTo(i),point:i.clone()}}function qe(n,e,t,s,i,o,r){wt.fromBufferAttribute(e,s),bt.fromBufferAttribute(e,i),At.fromBufferAttribute(e,o);const l=Ve(n,wt,bt,At,Gt,r);if(l){t&&(Wt.fromBufferAttribute(t,s),$t.fromBufferAttribute(t,i),Kt.fromBufferAttribute(t,o),l.uv=Ut.getUV(Gt,wt,bt,At,Wt,$t,Kt,new $));const c={a:s,b:i,c:o,normal:new C,materialIndex:0};Ut.getNormal(wt,bt,At,c.normal),l.face=c,l.faceIndex=s}return l}function ue(n,e,t,s,i){const o=s*3,r=n.index.getX(o),l=n.index.getX(o+1),c=n.index.getX(o+2),u=qe(t,n.attributes.position,n.attributes.uv,r,l,c,e);return u?(u.faceIndex=s,i&&i.push(u),u):null}function ke(n,e,t,s,i,o){for(let r=s,l=s+i;r<l;r++)ue(n,e,t,r,o)}function Oe(n,e,t,s,i){let o=1/0,r=null;for(let l=s,c=s+i;l<c;l++){const u=ue(n,e,t,l);u&&u.distance<o&&(r=u,o=u.distance)}return r}function Jt(n,e,t){return n===null||(n.point.applyMatrix4(e.matrixWorld),n.distance=n.point.distanceTo(t.ray.origin),n.object=e,n.distance<t.near||n.distance>t.far)?null:n}function N(n,e,t,s){const i=n.a,o=n.b,r=n.c;let l=e,c=e+1,u=e+2;t&&(l=t.getX(e),c=t.getX(e+1),u=t.getX(e+2)),i.x=s.getX(l),i.y=s.getY(l),i.z=s.getZ(l),o.x=s.getX(c),o.y=s.getY(c),o.z=s.getZ(c),r.x=s.getX(u),r.y=s.getY(u),r.z=s.getZ(u)}function Qt(n,e,t,s,i,o,r){const l=t.index,c=t.attributes.position;for(let u=n,a=e+n;u<a;u++)if(N(r,u*3,l,c),r.needsUpdate=!0,s(r,u,i,o))return!0;return!1}class fe{constructor(e){this._getNewPrimitive=e,this._primitives=[]}getPrimitive(){const e=this._primitives;return e.length===0?this._getNewPrimitive():e.pop()}releasePrimitive(e){this._primitives.push(e)}}function W(n,e){return e[n+15]===65535}function st(n,e){return e[n+6]}function pt(n,e){return e[n+14]}function dt(n){return n+8}function ht(n,e){return e[n+6]}function je(n,e){return e[n+7]}const nt=new it,St=new C,He=["x","y","z"];function Rt(n,e,t,s,i){let o=n*2,r=ot,l=K,c=G;if(W(o,l)){const a=st(n,c),p=pt(o,l);ke(e,t,s,a,p,i)}else{const a=dt(n);Mt(a,r,s,St)&&Rt(a,e,t,s,i);const p=ht(n,c);Mt(p,r,s,St)&&Rt(p,e,t,s,i)}}function _t(n,e,t,s){let i=n*2,o=ot,r=K,l=G;if(W(i,r)){const u=st(n,l),a=pt(i,r);return Oe(e,t,s,u,a)}else{const u=je(n,l),a=He[u],f=s.direction[a]>=0;let h,x;f?(h=dt(n),x=ht(n,l)):(h=ht(n,l),x=dt(n));const A=Mt(h,o,s,St)?_t(h,e,t,s):null;if(A){const y=A.point[a];if(f?y<=o[x+u]:y>=o[x+u+3])return A}const m=Mt(x,o,s,St)?_t(x,e,t,s):null;return A&&m?A.distance<=m.distance?A:m:A||m||null}}const Xe=function(){let n,e;const t=[],s=new fe(()=>new it);return function(...r){n=s.getPrimitive(),e=s.getPrimitive(),t.push(n,e);const l=i(...r);s.releasePrimitive(n),s.releasePrimitive(e),t.pop(),t.pop();const c=t.length;return c>0&&(e=t[c-1],n=t[c-2]),l};function i(o,r,l,c,u=null,a=0,p=0){function f(y){let b=y*2,P=K,w=G;for(;!W(b,P);)y=dt(y),b=y*2;return st(y,w)}function h(y){let b=y*2,P=K,w=G;for(;!W(b,P);)y=ht(y,w),b=y*2;return st(y,w)+pt(b,P)}let x=o*2,B=ot,A=K,d=G;if(W(x,A)){const y=st(o,d),b=pt(x,A);return V(o,B,n),c(y,b,!1,p,a+o,n)}else{const y=dt(o),b=ht(o,d);let P=y,w=b,T,v,g,S;if(u&&(g=n,S=e,V(P,B,g),V(w,B,S),T=u(g),v=u(S),v<T)){P=b,w=y;const z=T;T=v,v=z,g=S}g||(g=n,V(P,B,g));const M=W(P*2,A),I=l(g,M,T,p+1,a+P);let E;if(I===jt){const z=f(P),Y=h(P)-z;E=c(z,Y,!0,p+1,a+P,g)}else E=I&&i(P,r,l,c,u,a,p+1);if(E)return!0;S=e,V(w,B,S);const F=W(w*2,A),L=l(S,F,v,p+1,a+w);let U;if(L===jt){const z=f(w),Y=h(w)-z;U=c(z,Y,!0,p+1,a+w,S)}else U=L&&i(w,r,l,c,u,a,p+1);return!!U}}}(),Ye=function(){const n=new X,e=new X,t=new ft,s=new q,i=new q;return function o(r,l,c,u,a=null){let p=r*2,f=ot,h=K,x=G;if(a===null&&(c.boundingBox||c.computeBoundingBox(),s.set(c.boundingBox.min,c.boundingBox.max,u),a=s),W(p,h)){const A=l,d=A.index,m=A.attributes.position,y=c.index,b=c.attributes.position,P=st(r,x),w=pt(p,h);if(t.copy(u).invert(),c.boundsTree)return V(r,f,i),i.matrix.copy(t),i.needsUpdate=!0,c.boundsTree.shapecast({intersectsBounds:v=>i.intersectsBox(v),intersectsTriangle:v=>{v.a.applyMatrix4(u),v.b.applyMatrix4(u),v.c.applyMatrix4(u),v.needsUpdate=!0;for(let g=P*3,S=(w+P)*3;g<S;g+=3)if(N(e,g,d,m),e.needsUpdate=!0,v.intersectsTriangle(e))return!0;return!1}});for(let T=P*3,v=w+P*3;T<v;T+=3){N(n,T,d,m),n.a.applyMatrix4(t),n.b.applyMatrix4(t),n.c.applyMatrix4(t),n.needsUpdate=!0;for(let g=0,S=y.count;g<S;g+=3)if(N(e,g,y,b),e.needsUpdate=!0,n.intersectsTriangle(e))return!0}}else{const A=r+8,d=x[r+6];return V(A,f,nt),!!(a.intersectsBox(nt)&&o(A,l,c,u,a)||(V(d,f,nt),a.intersectsBox(nt)&&o(d,l,c,u,a)))}}}();function Mt(n,e,t,s){return V(n,e,nt),t.intersectBox(nt,s)}const Nt=[];let gt,ot,K,G;function lt(n){gt&&Nt.push(gt),gt=n,ot=new Float32Array(n),K=new Uint16Array(n),G=new Uint32Array(n)}function Pt(){gt=null,ot=null,K=null,G=null,Nt.length&&lt(Nt.pop())}const Et=Symbol("skip tree generation"),Ft=new it,Lt=new it,et=new ft,Q=new q,ct=new q,at=new C,Tt=new C,Ze=new C,We=new C,$e=new C,te=new it,_=new fe(()=>new X);class ut{static serialize(e,t={}){if(t.isBufferGeometry)return console.warn("MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature."),ut.serialize(arguments[0],{cloneBuffers:arguments[2]===void 0?!0:arguments[2]});t={cloneBuffers:!0,...t};const s=e.geometry,i=e._roots,o=s.getIndex();let r;return t.cloneBuffers?r={roots:i.map(l=>l.slice()),index:o.array.slice()}:r={roots:i,index:o.array},r}static deserialize(e,t,s={}){if(typeof s=="boolean")return console.warn("MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature."),ut.deserialize(arguments[0],arguments[1],{setIndex:arguments[2]===void 0?!0:arguments[2]});s={setIndex:!0,...s};const{index:i,roots:o}=e,r=new ut(t,{...s,[Et]:!0});if(r._roots=o,s.setIndex){const l=t.getIndex();if(l===null){const c=new re(e.index,1,!1);t.setIndex(c)}else l.array!==i&&(l.array.set(i),l.needsUpdate=!0)}return r}constructor(e,t={}){if(e.isBufferGeometry){if(e.index&&e.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t=Object.assign({strategy:le,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,[Et]:!1},t),t.useSharedArrayBuffer&&typeof SharedArrayBuffer>"u")throw new Error("MeshBVH: SharedArrayBuffer is not available.");this._roots=null,t[Et]||(this._roots=De(e,t),!e.boundingBox&&t.setBoundingBox&&(e.boundingBox=this.getBoundingBox(new it))),this.geometry=e}refit(e=null){e&&Array.isArray(e)&&(e=new Set(e));const t=this.geometry,s=t.index.array,i=t.attributes.position;let o,r,l,c,u=0;const a=this._roots;for(let f=0,h=a.length;f<h;f++)o=a[f],r=new Uint32Array(o),l=new Uint16Array(o),c=new Float32Array(o),p(0,u),u+=o.byteLength;function p(f,h,x=!1){const B=f*2;if(l[B+15]===Dt){const d=r[f+6],m=l[B+14];let y=1/0,b=1/0,P=1/0,w=-1/0,T=-1/0,v=-1/0;for(let g=3*d,S=3*(d+m);g<S;g++){const M=s[g],I=i.getX(M),E=i.getY(M),F=i.getZ(M);I<y&&(y=I),I>w&&(w=I),E<b&&(b=E),E>T&&(T=E),F<P&&(P=F),F>v&&(v=F)}return c[f+0]!==y||c[f+1]!==b||c[f+2]!==P||c[f+3]!==w||c[f+4]!==T||c[f+5]!==v?(c[f+0]=y,c[f+1]=b,c[f+2]=P,c[f+3]=w,c[f+4]=T,c[f+5]=v,!0):!1}else{const d=f+8,m=r[f+6],y=d+h,b=m+h;let P=x,w=!1,T=!1;e?P||(w=e.has(y),T=e.has(b),P=!w&&!T):(w=!0,T=!0);const v=P||w,g=P||T;let S=!1;v&&(S=p(d,h,P));let M=!1;g&&(M=p(m,h,P));const I=S||M;if(I)for(let E=0;E<3;E++){const F=d+E,L=m+E,U=c[F],z=c[F+3],R=c[L],Y=c[L+3];c[f+E]=U<R?U:R,c[f+E+3]=z>Y?z:Y}return I}}}traverse(e,t=0){const s=this._roots[t],i=new Uint32Array(s),o=new Uint16Array(s);r(0);function r(l,c=0){const u=l*2,a=o[u+15]===Dt;if(a){const p=i[l+6],f=o[u+14];e(c,a,new Float32Array(s,l*4,6),p,f)}else{const p=l+Bt/4,f=i[l+6],h=i[l+7];e(c,a,new Float32Array(s,l*4,6),h)||(r(p,c+1),r(f,c+1))}}}raycast(e,t=kt){const s=this._roots,i=this.geometry,o=[],r=t.isMaterial,l=Array.isArray(t),c=i.groups,u=r?t.side:t;for(let a=0,p=s.length;a<p;a++){const f=l?t[c[a].materialIndex].side:u,h=o.length;if(lt(s[a]),Rt(0,i,f,e,o),Pt(),l){const x=c[a].materialIndex;for(let B=h,A=o.length;B<A;B++)o[B].face.materialIndex=x}}return o}raycastFirst(e,t=kt){const s=this._roots,i=this.geometry,o=t.isMaterial,r=Array.isArray(t);let l=null;const c=i.groups,u=o?t.side:t;for(let a=0,p=s.length;a<p;a++){const f=r?t[c[a].materialIndex].side:u;lt(s[a]);const h=_t(0,i,f,e);Pt(),h!=null&&(l==null||h.distance<l.distance)&&(l=h,r&&(h.face.materialIndex=c[a].materialIndex))}return l}intersectsGeometry(e,t){const s=this.geometry;let i=!1;for(const o of this._roots)if(lt(o),i=Ye(0,s,e,t),Pt(),i)break;return i}shapecast(e,t,s){const i=this.geometry;if(e instanceof Function){if(t){const f=t;t=(h,x,B,A)=>{const d=x*3;return f(h,d,d+1,d+2,B,A)}}e={boundsTraverseOrder:s,intersectsBounds:e,intersectsTriangle:t,intersectsRange:null},console.warn("MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.")}const o=_.getPrimitive();let{boundsTraverseOrder:r,intersectsBounds:l,intersectsRange:c,intersectsTriangle:u}=e;if(c&&u){const f=c;c=(h,x,B,A,d)=>f(h,x,B,A,d)?!0:Qt(h,x,i,u,B,A,o)}else c||(u?c=(f,h,x,B)=>Qt(f,h,i,u,x,B,o):c=(f,h,x)=>x);let a=!1,p=0;for(const f of this._roots){if(lt(f),a=Xe(0,i,l,c,r,p),Pt(),a)break;p+=f.byteLength}return _.releasePrimitive(o),a}bvhcast(e,t,s){let{intersectsRanges:i,intersectsTriangles:o}=s;const r=this.geometry.index,l=this.geometry.attributes.position,c=e.geometry.index,u=e.geometry.attributes.position;et.copy(t).invert();const a=_.getPrimitive(),p=_.getPrimitive();if(o){let h=function(x,B,A,d,m,y,b,P){for(let w=A,T=A+d;w<T;w++){N(p,w*3,c,u),p.a.applyMatrix4(t),p.b.applyMatrix4(t),p.c.applyMatrix4(t),p.needsUpdate=!0;for(let v=x,g=x+B;v<g;v++)if(N(a,v*3,r,l),a.needsUpdate=!0,o(a,p,v,w,m,y,b,P))return!0}return!1};if(i){const x=i;i=function(B,A,d,m,y,b,P,w){return x(B,A,d,m,y,b,P,w)?!0:h(B,A,d,m,y,b,P,w)}}else i=h}e.getBoundingBox(Lt),Lt.applyMatrix4(t);const f=this.shapecast({intersectsBounds:h=>Lt.intersectsBox(h),intersectsRange:(h,x,B,A,d,m)=>(Ft.copy(m),Ft.applyMatrix4(et),e.shapecast({intersectsBounds:y=>Ft.intersectsBox(y),intersectsRange:(y,b,P,w,T)=>i(h,x,y,b,A,d,w,T)}))});return _.releasePrimitive(a),_.releasePrimitive(p),f}intersectsBox(e,t){return Q.set(e.min,e.max,t),Q.needsUpdate=!0,this.shapecast({intersectsBounds:s=>Q.intersectsBox(s),intersectsTriangle:s=>Q.intersectsTriangle(s)})}intersectsSphere(e){return this.shapecast({intersectsBounds:t=>e.intersectsBox(t),intersectsTriangle:t=>t.intersectsSphere(e)})}closestPointToGeometry(e,t,s={},i={},o=0,r=1/0){e.boundingBox||e.computeBoundingBox(),Q.set(e.boundingBox.min,e.boundingBox.max,t),Q.needsUpdate=!0;const l=this.geometry,c=l.attributes.position,u=l.index,a=e.attributes.position,p=e.index,f=_.getPrimitive(),h=_.getPrimitive();let x=Tt,B=Ze,A=null,d=null;i&&(A=We,d=$e);let m=1/0,y=null,b=null;return et.copy(t).invert(),ct.matrix.copy(et),this.shapecast({boundsTraverseOrder:P=>Q.distanceToBox(P),intersectsBounds:(P,w,T)=>T<m&&T<r?(w&&(ct.min.copy(P.min),ct.max.copy(P.max),ct.needsUpdate=!0),!0):!1,intersectsRange:(P,w)=>{if(e.boundsTree)return e.boundsTree.shapecast({boundsTraverseOrder:T=>ct.distanceToBox(T),intersectsBounds:(T,v,g)=>g<m&&g<r,intersectsRange:(T,v)=>{for(let g=T*3,S=(T+v)*3;g<S;g+=3){N(h,g,p,a),h.a.applyMatrix4(t),h.b.applyMatrix4(t),h.c.applyMatrix4(t),h.needsUpdate=!0;for(let M=P*3,I=(P+w)*3;M<I;M+=3){N(f,M,u,c),f.needsUpdate=!0;const E=f.distanceToTriangle(h,x,A);if(E<m&&(B.copy(x),d&&d.copy(A),m=E,y=M/3,b=g/3),E<o)return!0}}}});{const T=p?p.count:a.count;for(let v=0,g=T;v<g;v+=3){N(h,v,p,a),h.a.applyMatrix4(t),h.b.applyMatrix4(t),h.c.applyMatrix4(t),h.needsUpdate=!0;for(let S=P*3,M=(P+w)*3;S<M;S+=3){N(f,S,u,c),f.needsUpdate=!0;const I=f.distanceToTriangle(h,x,A);if(I<m&&(B.copy(x),d&&d.copy(A),m=I,y=S/3,b=v/3),I<o)return!0}}}}}),_.releasePrimitive(f),_.releasePrimitive(h),m===1/0?null:(s.point?s.point.copy(B):s.point=B.clone(),s.distance=m,s.faceIndex=y,i&&(i.point?i.point.copy(d):i.point=d.clone(),i.point.applyMatrix4(et),B.applyMatrix4(et),i.distance=B.sub(i.point).length(),i.faceIndex=b),s)}closestPointToPoint(e,t={},s=0,i=1/0){const o=s*s,r=i*i;let l=1/0,c=null;if(this.shapecast({boundsTraverseOrder:a=>(at.copy(e).clamp(a.min,a.max),at.distanceToSquared(e)),intersectsBounds:(a,p,f)=>f<l&&f<r,intersectsTriangle:(a,p)=>{a.closestPointToPoint(e,at);const f=e.distanceToSquared(at);return f<l&&(Tt.copy(at),l=f,c=p),f<o}}),l===1/0)return null;const u=Math.sqrt(l);return t.point?t.point.copy(Tt):t.point=Tt.clone(),t.distance=u,t.faceIndex=c,t}getBoundingBox(e){return e.makeEmpty(),this._roots.forEach(s=>{V(0,new Float32Array(s),te),e.union(te)}),e}}const zt=new be,ee=new ft,Ke=ae.prototype.raycast;function Ge(n,e){if(this.geometry.boundsTree){if(this.material===void 0)return;ee.copy(this.matrixWorld).invert(),zt.copy(n.ray).applyMatrix4(ee);const t=this.geometry.boundsTree;if(n.firstHitOnly===!0){const s=Jt(t.raycastFirst(zt,this.material),this,n);s&&e.push(s)}else{const s=t.raycast(zt,this.material);for(let i=0,o=s.length;i<o;i++){const r=Jt(s[i],this,n);r&&e.push(r)}}}else Ke.call(this,n,e)}function Je(n){return this.boundsTree=new ut(this,n),this.boundsTree}function Qe(){this.boundsTree=null}const tn=()=>{Ot.prototype.computeBoundsTree=Je,Ot.prototype.disposeBoundsTree=Qe,ae.prototype.raycast=Ge,oe.prototype.firstHitOnly=!0},en=`import { MouseRaycaster } from 'trzy'

const raycaster = new MouseRaycaster({
  scene, // alternatively, pass objects: THREE.Object3D[]
  camera,
  renderer,
  recursive: true,
})

raycaster.on('move', (event) => console.log(event.intersections))
raycaster.on('click', (event) => console.log(event.intersections))

// later
raycaster.dispose()
`,cn={title:"Mouse Raycaster",parameters:{docs:{source:{code:en}}}},nn=()=>{tn();const{scene:n,camera:e,canvas:t,renderer:s,update:i}=Ae();return Pe({scene:n,camera:e,canvas:t,update:i,controls:!0}).then(()=>{let o=new C(1,1,1),r=!1,l=.1;const c=n.getObjectByName("Strawberry");c.traverse(a=>{var p,f;return(f=(p=a.geometry)==null?void 0:p.computeBoundsTree)==null?void 0:f.call(p)});const u=new Te({scene:n,camera:e,renderer:s,recursive:!0,objects:[c]});u.on("move",a=>{a.intersections.length>0?(l=.1,o.setScalar(1.2)):(l=.1,o.setScalar(1)),a.intersections.length>0?r=!0:r=!1}),u.on("click",a=>{a.intersections.length!==0&&(l=.2,o.setScalar(o.x===1.7?r?1.2:1:1.7))}),i(()=>c.scale.lerp(o,l))}),t},vt={render:nn};var ne,se,ie;vt.parameters={...vt.parameters,docs:{...(ne=vt.parameters)==null?void 0:ne.docs,source:{originalSource:`{
  render
}`,...(ie=(se=vt.parameters)==null?void 0:se.docs)==null?void 0:ie.source}}};const an=["Primary"];export{vt as Primary,an as __namedExportsOrder,cn as default};
//# sourceMappingURL=mouse-raycaster.stories-11e0dc94.js.map
