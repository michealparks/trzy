var J=Object.defineProperty;var K=(o,t,n)=>t in o?J(o,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):o[t]=n;var i=(o,t,n)=>(K(o,typeof t!="symbol"?t+"":t,n),n);import{s as Q,o as V,n as W}from"../chunks/scheduler.b0c1c2c3.js";import{S as Z,i as ee,r as B,u as L,v as M,d as T,t as D,w as I,g as te,s as Y,h as ne,z as se,c as H,a as G,f as O}from"../chunks/index.f44ac6f0.js";import{E as ae,G as oe,a as re,s as ce,u as ie,b as le,C as me}from"../chunks/setup.f293222f.js";import{D as ue,C as fe}from"../chunks/code.749cf45e.js";const pe=.5*(Math.sqrt(3)-1),v=(3-Math.sqrt(3))/6,U=o=>Math.floor(o)|0,X=new Float64Array([1,1,-1,1,1,-1,-1,-1,1,0,-1,0,1,0,-1,0,0,1,0,-1,0,1,0,-1]);function A(o=Math.random){const t=he(o),n=new Float64Array(t).map(s=>X[s%12*2]),e=new Float64Array(t).map(s=>X[s%12*2+1]);return function(r,c){let l=0,a=0,m=0;const _=(r+c)*pe,u=U(r+_),y=U(c+_),d=(u+y)*v,F=u-d,k=y-d,f=r-F,g=c-k;let j,C;f>g?(j=1,C=0):(j=0,C=1);const R=f-j+v,q=g-C+v,z=f-1+2*v,E=g-1+2*v,N=u&255,P=y&255;let b=.5-f*f-g*g;if(b>=0){const p=N+t[P],x=n[p],S=e[p];b*=b,l=b*b*(x*f+S*g)}let $=.5-R*R-q*q;if($>=0){const p=N+j+t[P+C],x=n[p],S=e[p];$*=$,a=$*$*(x*R+S*q)}let w=.5-z*z-E*E;if(w>=0){const p=N+1+t[P+1],x=n[p],S=e[p];w*=w,m=w*w*(x*z+S*E)}return 70*(l+a+m)}}function he(o){const n=new Uint8Array(512);for(let e=0;e<512/2;e++)n[e]=e;for(let e=0;e<512/2-1;e++){const s=e+~~(o()*(256-e)),r=n[e];n[e]=n[s],n[s]=r}for(let e=256;e<512;e++)n[e]=n[e-256];return n}class ye{constructor(t){i(this,"decay",!1);i(this,"decayRate",.65);i(this,"intensity",.5);i(this,"maxPitch",.05);i(this,"maxRoll",.05);i(this,"maxYaw",.05);i(this,"pitchFrequency",5e-4);i(this,"rollFrequency",5e-4);i(this,"yawFrequency",5e-4);i(this,"object");i(this,"enabled",!0);i(this,"saveRotation");i(this,"update");const n=new ae,e=A(),s=A(),r=A();let c=!0,l=0,a=performance.now();const m=()=>{n.copy(this.object.rotation)},_=()=>{const u=performance.now(),y=u-a;l+=y,a=u;const d=this.intensity**2,F=this.maxYaw*d*e(l*this.yawFrequency,1),k=this.maxPitch*d*s(l*this.pitchFrequency,1),f=this.maxRoll*d*r(l*this.rollFrequency,1);this.object.rotation.set(n.x+k,n.y+F,n.z+f),this.decay&&this.intensity>0&&(this.intensity-=this.decayRate*y,this.intensity<0?this.intensity=0:this.intensity>1&&(this.intensity=1))};Object.defineProperty(this,"enabled",{get(){return c},set(u){c=u,c&&m()},enumerable:!0,configurable:!0}),this.object=t,this.saveRotation=m,this.update=_}}class de extends ye{constructor(n){super(n);i(this,"controls");let e;Object.defineProperty(this,"controls",{get(){return e},set(s){e!==void 0&&e.removeEventListener("change",this.saveRotation),e=s,e!==void 0&&e.addEventListener("change",this.saveRotation)},enumerable:!0,configurable:!0})}}const ge=`
import * as THREE from 'three'
import { CameraShake } from 'trzy'

const camera = new THREE.PerspectiveCamera()
const cameraShake = new CameraShake(camera)

// If using controls, register them
cameraShake.controls = orbitControls

// In your game loop, before rendering your scene
cameraShake.update()

// If you wish to disable
cameraShake.enabled = false
`,be=new oe;let h;const $e=async()=>{if(h)return h;const o=await be.loadAsync("./glb/strawberry.glb");return h=new re,h.add(o.scene.getObjectByName("Stem"),o.scene.getObjectByName("Seeds"),o.scene.getObjectByName("Leaves"),o.scene.getObjectByName("Body")),h.name="Strawberry",h.scale.setScalar(.5),h};function we(o){let t,n="Uses simplex noise to shake the camera.",e,s,r,c,l;return s=new me({}),c=new fe({props:{code:ge}}),{c(){t=te("p"),t.textContent=n,e=Y(),B(s.$$.fragment),r=Y(),B(c.$$.fragment)},l(a){t=ne(a,"P",{"data-svelte-h":!0}),se(t)!=="svelte-1395g4f"&&(t.textContent=n),e=H(a),L(s.$$.fragment,a),r=H(a),L(c.$$.fragment,a)},m(a,m){G(a,t,m),G(a,e,m),M(s,a,m),G(a,r,m),M(c,a,m),l=!0},p:W,i(a){l||(T(s.$$.fragment,a),T(c.$$.fragment,a),l=!0)},o(a){D(s.$$.fragment,a),D(c.$$.fragment,a),l=!1},d(a){a&&(O(t),O(e),O(r)),I(s,a),I(c,a)}}}function xe(o){let t,n;return t=new ue({props:{title:"CameraShake",$$slots:{default:[we]},$$scope:{ctx:o}}}),{c(){B(t.$$.fragment)},l(e){L(t.$$.fragment,e)},m(e,s){M(t,e,s),n=!0},p(e,[s]){const r={};s&1&&(r.$$scope={dirty:s,ctx:e}),t.$set(r)},i(e){n||(T(t.$$.fragment,e),n=!0)},o(e){D(t.$$.fragment,e),n=!1},d(e){I(t,e)}}}function Se(o){return V(()=>{const t=ce(),{scene:n,camera:e}=ie(),s=new de(e.current);s.controls=t,s.enabled=!0;const{stop:r}=le(()=>s.update());return $e().then(c=>n.add(c)),()=>{r()}}),[]}class ke extends Z{constructor(t){super(),ee(this,t,Se,xe,Q,{})}}export{ke as component};
