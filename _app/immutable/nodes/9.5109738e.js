import{s as Be,o as Se,n as Me}from"../chunks/scheduler.b0c1c2c3.js";import{S as Ie,i as Ee,r as qt,u as kt,v as Nt,d as Ht,t as jt,w as Xt,g as Ce,s as Qt,h as _e,z as ze,c as te,a as _t,f as zt}from"../chunks/index.f44ac6f0.js";import{e as I,f as we,V as E,g as nt,P as be,L as V,T as lt,S as Fe,h as pt,i as Le,D as Re,j as st,F as ee,R as De,M as St,k as ot,l as ne,m as Ae,n as ve,u as Ue,s as Oe,c as $e,o as Ve,b as qe,C as ke}from"../chunks/setup.a495d355.js";import{D as Ne,C as He}from"../chunks/code.93479f81.js";const je=()=>{let e=0,t=0;return new ResizeObserver(([s])=>{e=(s==null?void 0:s.contentRect.width)??0,t=(s==null?void 0:s.contentRect.height)??0}).observe(I.target),s=>{I.pointer.set(s.offsetX/e*2-1,-(s.offsetY/t*2)+1),I.raycaster.setFromCamera(I.pointer,I.camera)}},Te=0,Xe=1,Ye=2,se=2,Ft=1.25,ie=1,Mt=6*4+4+4,Yt=65535,Ze=Math.pow(2,-24);class xt{constructor(){}}function U(e,t,n){return n.min.x=t[e],n.min.y=t[e+1],n.min.z=t[e+2],n.max.x=t[e+3],n.max.y=t[e+4],n.max.z=t[e+5],n}function We(e){e[0]=e[1]=e[2]=1/0,e[3]=e[4]=e[5]=-1/0}function oe(e){let t=-1,n=-1/0;for(let s=0;s<3;s++){const i=e[s+3]-e[s];i>n&&(n=i,t=s)}return t}function re(e,t){t.set(e)}function ce(e,t,n){let s,i;for(let c=0;c<3;c++){const r=c+3;s=e[c],i=t[c],n[c]=s<i?s:i,s=e[r],i=t[r],n[r]=s>i?s:i}}function wt(e,t,n){for(let s=0;s<3;s++){const i=t[e+2*s],c=t[e+2*s+1],r=i-c,l=i+c;r<n[s]&&(n[s]=r),l>n[s+3]&&(n[s+3]=l)}}function rt(e){const t=e[3]-e[0],n=e[4]-e[1],s=e[5]-e[2];return 2*(t*n+n*s+s*t)}function Ge(e,t){if(!e.index){const n=e.attributes.position.count,s=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;let i;n>65535?i=new Uint32Array(new s(4*n)):i=new Uint16Array(new s(2*n)),e.setIndex(new we(i,1));for(let c=0;c<n;c++)i[c]=c}}function Ke(e){if(!e.groups||!e.groups.length)return[{offset:0,count:e.index.count/3}];const t=[],n=new Set;for(const i of e.groups)n.add(i.start),n.add(i.start+i.count);const s=Array.from(n.values()).sort((i,c)=>i-c);for(let i=0;i<s.length-1;i++){const c=s[i],r=s[i+1];t.push({offset:c/3,count:(r-c)/3})}return t}function Lt(e,t,n,s,i=null){let c=1/0,r=1/0,l=1/0,o=-1/0,u=-1/0,f=-1/0,p=1/0,a=1/0,h=1/0,v=-1/0,B=-1/0,y=-1/0;const d=i!==null;for(let x=t*6,m=(t+n)*6;x<m;x+=6){const b=e[x+0],w=e[x+1],A=b-w,P=b+w;A<c&&(c=A),P>o&&(o=P),d&&b<p&&(p=b),d&&b>v&&(v=b);const g=e[x+2],T=e[x+3],S=g-T,M=g+T;S<r&&(r=S),M>u&&(u=M),d&&g<a&&(a=g),d&&g>B&&(B=g);const C=e[x+4],_=e[x+5],z=C-_,F=C+_;z<l&&(l=z),F>f&&(f=F),d&&C<h&&(h=C),d&&C>y&&(y=C)}s[0]=c,s[1]=r,s[2]=l,s[3]=o,s[4]=u,s[5]=f,d&&(i[0]=p,i[1]=a,i[2]=h,i[3]=v,i[4]=B,i[5]=y)}function Je(e,t,n,s){let i=1/0,c=1/0,r=1/0,l=-1/0,o=-1/0,u=-1/0;for(let f=t*6,p=(t+n)*6;f<p;f+=6){const a=e[f+0];a<i&&(i=a),a>l&&(l=a);const h=e[f+2];h<c&&(c=h),h>o&&(o=h);const v=e[f+4];v<r&&(r=v),v>u&&(u=v)}s[0]=i,s[1]=c,s[2]=r,s[3]=l,s[4]=o,s[5]=u}function Qe(e,t,n,s,i){let c=n,r=n+s-1;const l=i.pos,o=i.axis*2;for(;;){for(;c<=r&&t[c*6+o]<l;)c++;for(;c<=r&&t[r*6+o]>=l;)r--;if(c<r){for(let u=0;u<3;u++){let f=e[c*3+u];e[c*3+u]=e[r*3+u],e[r*3+u]=f;let p=t[c*6+u*2+0];t[c*6+u*2+0]=t[r*6+u*2+0],t[r*6+u*2+0]=p;let a=t[c*6+u*2+1];t[c*6+u*2+1]=t[r*6+u*2+1],t[r*6+u*2+1]=a}c++,r--}else return c}}const $=32,tn=(e,t)=>e.candidate-t.candidate,N=new Array($).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),bt=new Float32Array(6);function en(e,t,n,s,i,c){let r=-1,l=0;if(c===Te)r=oe(t),r!==-1&&(l=(t[r]+t[r+3])/2);else if(c===Xe)r=oe(e),r!==-1&&(l=nn(n,s,i,r));else if(c===Ye){const o=rt(e);let u=Ft*i;const f=s*6,p=(s+i)*6;for(let a=0;a<3;a++){const h=t[a],y=(t[a+3]-h)/$;if(i<$/4){const d=[...N];d.length=i;let x=0;for(let b=f;b<p;b+=6,x++){const w=d[x];w.candidate=n[b+2*a],w.count=0;const{bounds:A,leftCacheBounds:P,rightCacheBounds:g}=w;for(let T=0;T<3;T++)g[T]=1/0,g[T+3]=-1/0,P[T]=1/0,P[T+3]=-1/0,A[T]=1/0,A[T+3]=-1/0;wt(b,n,A)}d.sort(tn);let m=i;for(let b=0;b<m;b++){const w=d[b];for(;b+1<m&&d[b+1].candidate===w.candidate;)d.splice(b+1,1),m--}for(let b=f;b<p;b+=6){const w=n[b+2*a];for(let A=0;A<m;A++){const P=d[A];w>=P.candidate?wt(b,n,P.rightCacheBounds):(wt(b,n,P.leftCacheBounds),P.count++)}}for(let b=0;b<m;b++){const w=d[b],A=w.count,P=i-w.count,g=w.leftCacheBounds,T=w.rightCacheBounds;let S=0;A!==0&&(S=rt(g)/o);let M=0;P!==0&&(M=rt(T)/o);const C=ie+Ft*(S*A+M*P);C<u&&(r=a,u=C,l=w.candidate)}}else{for(let m=0;m<$;m++){const b=N[m];b.count=0,b.candidate=h+y+m*y;const w=b.bounds;for(let A=0;A<3;A++)w[A]=1/0,w[A+3]=-1/0}for(let m=f;m<p;m+=6){let A=~~((n[m+2*a]-h)/y);A>=$&&(A=$-1);const P=N[A];P.count++,wt(m,n,P.bounds)}const d=N[$-1];re(d.bounds,d.rightCacheBounds);for(let m=$-2;m>=0;m--){const b=N[m],w=N[m+1];ce(b.bounds,w.rightCacheBounds,b.rightCacheBounds)}let x=0;for(let m=0;m<$-1;m++){const b=N[m],w=b.count,A=b.bounds,g=N[m+1].rightCacheBounds;w!==0&&(x===0?re(A,bt):ce(A,bt,bt)),x+=w;let T=0,S=0;x!==0&&(T=rt(bt)/o);const M=i-x;M!==0&&(S=rt(g)/o);const C=ie+Ft*(T*x+S*M);C<u&&(r=a,u=C,l=b.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${c} used.`);return{axis:r,pos:l}}function nn(e,t,n,s){let i=0;for(let c=t,r=t+n;c<r;c++)i+=e[c*6+s*2];return i/n}function sn(e,t){We(t);const n=e.attributes.position,s=e.index.array,i=s.length/3,c=new Float32Array(i*6),r=n.normalized,l=n.array,o=n.offset||0;let u=3;n.isInterleavedBufferAttribute&&(u=n.data.stride);const f=["getX","getY","getZ"];for(let p=0;p<i;p++){const a=p*3,h=p*6;let v,B,y;r?(v=s[a+0],B=s[a+1],y=s[a+2]):(v=s[a+0]*u+o,B=s[a+1]*u+o,y=s[a+2]*u+o);for(let d=0;d<3;d++){let x,m,b;r?(x=n[f[d]](v),m=n[f[d]](B),b=n[f[d]](y)):(x=l[v+d],m=l[B+d],b=l[y+d]);let w=x;m<w&&(w=m),b<w&&(w=b);let A=x;m>A&&(A=m),b>A&&(A=b);const P=(A-w)/2,g=d*2;c[h+g+0]=w+P,c[h+g+1]=P+(Math.abs(w)+P)*Ze,w<t[d]&&(t[d]=w),A>t[d+3]&&(t[d+3]=A)}}return c}function on(e,t){function n(d){a&&a(d/h)}function s(d,x,m,b=null,w=0){if(!v&&w>=o&&(v=!0,u&&(console.warn(`MeshBVH: Max depth of ${o} reached when generating BVH. Consider increasing maxDepth.`),console.warn(e))),m<=f||w>=o)return n(x+m),d.offset=x,d.count=m,d;const A=en(d.boundingData,b,r,x,m,p);if(A.axis===-1)return n(x+m),d.offset=x,d.count=m,d;const P=Qe(l,r,x,m,A);if(P===x||P===x+m)n(x+m),d.offset=x,d.count=m;else{d.splitAxis=A.axis;const g=new xt,T=x,S=P-x;d.left=g,g.boundingData=new Float32Array(6),Lt(r,T,S,g.boundingData,c),s(g,T,S,c,w+1);const M=new xt,C=P,_=m-S;d.right=M,M.boundingData=new Float32Array(6),Lt(r,C,_,M.boundingData,c),s(M,C,_,c,w+1)}return d}Ge(e,t);const i=new Float32Array(6),c=new Float32Array(6),r=sn(e,i),l=e.index.array,o=t.maxDepth,u=t.verbose,f=t.maxLeafTris,p=t.strategy,a=t.onProgress,h=e.index.count/3;let v=!1;const B=[],y=Ke(e);if(y.length===1){const d=y[0],x=new xt;x.boundingData=i,Je(r,d.offset,d.count,c),s(x,d.offset,d.count,c),B.push(x)}else for(let d of y){const x=new xt;x.boundingData=new Float32Array(6),Lt(r,d.offset,d.count,x.boundingData,c),s(x,d.offset,d.count,c),B.push(x)}return B}function rn(e,t){const n=on(e,t);let s,i,c;const r=[],l=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;for(let f=0;f<n.length;f++){const p=n[f];let a=o(p);const h=new l(Mt*a);s=new Float32Array(h),i=new Uint32Array(h),c=new Uint16Array(h),u(0,p),r.push(h)}return r;function o(f){return f.count?1:1+o(f.left)+o(f.right)}function u(f,p){const a=f/4,h=f/2,v=!!p.count,B=p.boundingData;for(let y=0;y<6;y++)s[a+y]=B[y];if(v){const y=p.offset,d=p.count;return i[a+6]=y,c[h+14]=d,c[h+15]=Yt,f+Mt}else{const y=p.left,d=p.right,x=p.splitAxis;let m;if(m=u(f+Mt,y),m/4>Math.pow(2,32))throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return i[a+6]=m/4,m=u(m,d),i[a+7]=x,m}}}class q{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,n){let s=1/0,i=-1/0;for(let c=0,r=t.length;c<r;c++){const o=t[c][n];s=o<s?o:s,i=o>i?o:i}this.min=s,this.max=i}setFromPoints(t,n){let s=1/0,i=-1/0;for(let c=0,r=n.length;c<r;c++){const l=n[c],o=t.dot(l);s=o<s?o:s,i=o>i?o:i}this.min=s,this.max=i}isSeparated(t){return this.min>t.max||t.min>this.max}}q.prototype.setFromBox=function(){const e=new E;return function(n,s){const i=s.min,c=s.max;let r=1/0,l=-1/0;for(let o=0;o<=1;o++)for(let u=0;u<=1;u++)for(let f=0;f<=1;f++){e.x=i.x*o+c.x*(1-o),e.y=i.y*u+c.y*(1-u),e.z=i.z*f+c.z*(1-f);const p=n.dot(e);r=Math.min(p,r),l=Math.max(p,l)}this.min=r,this.max=l}}();const cn=function(){const e=new E,t=new E,n=new E;return function(i,c,r){const l=i.start,o=e,u=c.start,f=t;n.subVectors(l,u),e.subVectors(i.end,i.start),t.subVectors(c.end,c.start);const p=n.dot(f),a=f.dot(o),h=f.dot(f),v=n.dot(o),y=o.dot(o)*h-a*a;let d,x;y!==0?d=(p*a-v*h)/y:d=0,x=(p+d*a)/h,r.x=d,r.y=x}}(),Kt=function(){const e=new nt,t=new E,n=new E;return function(i,c,r,l){cn(i,c,e);let o=e.x,u=e.y;if(o>=0&&o<=1&&u>=0&&u<=1){i.at(o,r),c.at(u,l);return}else if(o>=0&&o<=1){u<0?c.at(0,l):c.at(1,l),i.closestPointToPoint(l,!0,r);return}else if(u>=0&&u<=1){o<0?i.at(0,r):i.at(1,r),c.closestPointToPoint(r,!0,l);return}else{let f;o<0?f=i.start:f=i.end;let p;u<0?p=c.start:p=c.end;const a=t,h=n;if(i.closestPointToPoint(p,!0,t),c.closestPointToPoint(f,!0,n),a.distanceToSquared(p)<=h.distanceToSquared(f)){r.copy(a),l.copy(p);return}else{r.copy(f),l.copy(h);return}}}}(),an=function(){const e=new E,t=new E,n=new be,s=new V;return function(c,r){const{radius:l,center:o}=c,{a:u,b:f,c:p}=r;if(s.start=u,s.end=f,s.closestPointToPoint(o,!0,e).distanceTo(o)<=l||(s.start=u,s.end=p,s.closestPointToPoint(o,!0,e).distanceTo(o)<=l)||(s.start=f,s.end=p,s.closestPointToPoint(o,!0,e).distanceTo(o)<=l))return!0;const B=r.getPlane(n);if(Math.abs(B.distanceToPoint(o))<=l){const d=B.projectPoint(o,t);if(r.containsPoint(d))return!0}return!1}}(),ln=1e-15;function Rt(e){return Math.abs(e)<ln}class k extends lt{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new E),this.satBounds=new Array(4).fill().map(()=>new q),this.points=[this.a,this.b,this.c],this.sphere=new Fe,this.plane=new be,this.needsUpdate=!0}intersectsSphere(t){return an(t,this)}update(){const t=this.a,n=this.b,s=this.c,i=this.points,c=this.satAxes,r=this.satBounds,l=c[0],o=r[0];this.getNormal(l),o.setFromPoints(l,i);const u=c[1],f=r[1];u.subVectors(t,n),f.setFromPoints(u,i);const p=c[2],a=r[2];p.subVectors(n,s),a.setFromPoints(p,i);const h=c[3],v=r[3];h.subVectors(s,t),v.setFromPoints(h,i),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(l,t),this.needsUpdate=!1}}k.prototype.closestPointToSegment=function(){const e=new E,t=new E,n=new V;return function(i,c=null,r=null){const{start:l,end:o}=i,u=this.points;let f,p=1/0;for(let a=0;a<3;a++){const h=(a+1)%3;n.start.copy(u[a]),n.end.copy(u[h]),Kt(n,i,e,t),f=e.distanceToSquared(t),f<p&&(p=f,c&&c.copy(e),r&&r.copy(t))}return this.closestPointToPoint(l,e),f=l.distanceToSquared(e),f<p&&(p=f,c&&c.copy(e),r&&r.copy(l)),this.closestPointToPoint(o,e),f=o.distanceToSquared(e),f<p&&(p=f,c&&c.copy(e),r&&r.copy(o)),Math.sqrt(p)}}();k.prototype.intersectsTriangle=function(){const e=new k,t=new Array(3),n=new Array(3),s=new q,i=new q,c=new E,r=new E,l=new E,o=new E,u=new E,f=new V,p=new V,a=new V,h=new E;function v(B,y,d){const x=B.points;let m=0,b=-1;for(let w=0;w<3;w++){const{start:A,end:P}=f;A.copy(x[w]),P.copy(x[(w+1)%3]),f.delta(r);const g=Rt(y.distanceToPoint(A));if(Rt(y.normal.dot(r))&&g){d.copy(f),m=2;break}const T=y.intersectLine(f,h);if(!T&&g&&h.copy(A),(T||g)&&!Rt(h.distanceTo(P))){if(m<=1)(m===1?d.start:d.end).copy(h),g&&(b=m);else if(m>=2){(b===1?d.start:d.end).copy(h),m=2;break}if(m++,m===2&&b===-1)break}}return m}return function(y,d=null,x=!1){this.needsUpdate&&this.update(),y.isExtendedTriangle?y.needsUpdate&&y.update():(e.copy(y),e.update(),y=e);const m=this.plane,b=y.plane;if(Math.abs(m.normal.dot(b.normal))>1-1e-10){const w=this.satBounds,A=this.satAxes;n[0]=y.a,n[1]=y.b,n[2]=y.c;for(let T=0;T<4;T++){const S=w[T],M=A[T];if(s.setFromPoints(M,n),S.isSeparated(s))return!1}const P=y.satBounds,g=y.satAxes;t[0]=this.a,t[1]=this.b,t[2]=this.c;for(let T=0;T<4;T++){const S=P[T],M=g[T];if(s.setFromPoints(M,t),S.isSeparated(s))return!1}for(let T=0;T<4;T++){const S=A[T];for(let M=0;M<4;M++){const C=g[M];if(c.crossVectors(S,C),s.setFromPoints(c,t),i.setFromPoints(c,n),s.isSeparated(i))return!1}}return d&&(x||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),d.start.set(0,0,0),d.end.set(0,0,0)),!0}else{const w=v(this,b,p);if(w===1&&y.containsPoint(p.end))return d&&(d.start.copy(p.end),d.end.copy(p.end)),!0;if(w!==2)return!1;const A=v(y,m,a);if(A===1&&this.containsPoint(a.end))return d&&(d.start.copy(a.end),d.end.copy(a.end)),!0;if(A!==2)return!1;if(p.delta(l),a.delta(o),l.dot(o)<0){let _=a.start;a.start=a.end,a.end=_}const P=p.start.dot(l),g=p.end.dot(l),T=a.start.dot(l),S=a.end.dot(l),M=g<T,C=P<S;return P!==S&&T!==g&&M===C?!1:(d&&(u.subVectors(p.start,a.start),u.dot(l)>0?d.start.copy(p.start):d.start.copy(a.start),u.subVectors(p.end,a.end),u.dot(l)<0?d.end.copy(p.end):d.end.copy(a.end)),!0)}}}();k.prototype.distanceToPoint=function(){const e=new E;return function(n){return this.closestPointToPoint(n,e),n.distanceTo(e)}}();k.prototype.distanceToTriangle=function(){const e=new E,t=new E,n=["a","b","c"],s=new V,i=new V;return function(r,l=null,o=null){const u=l||o?s:null;if(this.intersectsTriangle(r,u))return(l||o)&&(l&&u.getCenter(l),o&&u.getCenter(o)),0;let f=1/0;for(let p=0;p<3;p++){let a;const h=n[p],v=r[h];this.closestPointToPoint(v,e),a=v.distanceToSquared(e),a<f&&(f=a,l&&l.copy(e),o&&o.copy(v));const B=this[h];r.closestPointToPoint(B,e),a=B.distanceToSquared(e),a<f&&(f=a,l&&l.copy(B),o&&o.copy(e))}for(let p=0;p<3;p++){const a=n[p],h=n[(p+1)%3];s.set(this[a],this[h]);for(let v=0;v<3;v++){const B=n[v],y=n[(v+1)%3];i.set(r[B],r[y]),Kt(s,i,e,t);const d=e.distanceToSquared(t);d<f&&(f=d,l&&l.copy(e),o&&o.copy(t))}}return Math.sqrt(f)}}();class O{constructor(t,n,s){this.isOrientedBox=!0,this.min=new E,this.max=new E,this.matrix=new pt,this.invMatrix=new pt,this.points=new Array(8).fill().map(()=>new E),this.satAxes=new Array(3).fill().map(()=>new E),this.satBounds=new Array(3).fill().map(()=>new q),this.alignedSatBounds=new Array(3).fill().map(()=>new q),this.needsUpdate=!1,t&&this.min.copy(t),n&&this.max.copy(n),s&&this.matrix.copy(s)}set(t,n,s){this.min.copy(t),this.max.copy(n),this.matrix.copy(s),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}O.prototype.update=function(){return function(){const t=this.matrix,n=this.min,s=this.max,i=this.points;for(let u=0;u<=1;u++)for(let f=0;f<=1;f++)for(let p=0;p<=1;p++){const a=1*u|2*f|4*p,h=i[a];h.x=u?s.x:n.x,h.y=f?s.y:n.y,h.z=p?s.z:n.z,h.applyMatrix4(t)}const c=this.satBounds,r=this.satAxes,l=i[0];for(let u=0;u<3;u++){const f=r[u],p=c[u],a=1<<u,h=i[a];f.subVectors(l,h),p.setFromPoints(f,i)}const o=this.alignedSatBounds;o[0].setFromPointsField(i,"x"),o[1].setFromPointsField(i,"y"),o[2].setFromPointsField(i,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();O.prototype.intersectsBox=function(){const e=new q;return function(n){this.needsUpdate&&this.update();const s=n.min,i=n.max,c=this.satBounds,r=this.satAxes,l=this.alignedSatBounds;if(e.min=s.x,e.max=i.x,l[0].isSeparated(e)||(e.min=s.y,e.max=i.y,l[1].isSeparated(e))||(e.min=s.z,e.max=i.z,l[2].isSeparated(e)))return!1;for(let o=0;o<3;o++){const u=r[o],f=c[o];if(e.setFromBox(u,n),f.isSeparated(e))return!1}return!0}}();O.prototype.intersectsTriangle=function(){const e=new k,t=new Array(3),n=new q,s=new q,i=new E;return function(r){this.needsUpdate&&this.update(),r.isExtendedTriangle?r.needsUpdate&&r.update():(e.copy(r),e.update(),r=e);const l=this.satBounds,o=this.satAxes;t[0]=r.a,t[1]=r.b,t[2]=r.c;for(let a=0;a<3;a++){const h=l[a],v=o[a];if(n.setFromPoints(v,t),h.isSeparated(n))return!1}const u=r.satBounds,f=r.satAxes,p=this.points;for(let a=0;a<3;a++){const h=u[a],v=f[a];if(n.setFromPoints(v,p),h.isSeparated(n))return!1}for(let a=0;a<3;a++){const h=o[a];for(let v=0;v<4;v++){const B=f[v];if(i.crossVectors(h,B),n.setFromPoints(i,t),s.setFromPoints(i,p),n.isSeparated(s))return!1}}return!0}}();O.prototype.closestPointToPoint=function(){return function(t,n){return this.needsUpdate&&this.update(),n.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),n}}();O.prototype.distanceToPoint=function(){const e=new E;return function(n){return this.closestPointToPoint(n,e),n.distanceTo(e)}}();O.prototype.distanceToBox=function(){const e=["x","y","z"],t=new Array(12).fill().map(()=>new V),n=new Array(12).fill().map(()=>new V),s=new E,i=new E;return function(r,l=0,o=null,u=null){if(this.needsUpdate&&this.update(),this.intersectsBox(r))return(o||u)&&(r.getCenter(i),this.closestPointToPoint(i,s),r.closestPointToPoint(s,i),o&&o.copy(s),u&&u.copy(i)),0;const f=l*l,p=r.min,a=r.max,h=this.points;let v=1/0;for(let y=0;y<8;y++){const d=h[y];i.copy(d).clamp(p,a);const x=d.distanceToSquared(i);if(x<v&&(v=x,o&&o.copy(d),u&&u.copy(i),x<f))return Math.sqrt(x)}let B=0;for(let y=0;y<3;y++)for(let d=0;d<=1;d++)for(let x=0;x<=1;x++){const m=(y+1)%3,b=(y+2)%3,w=d<<m|x<<b,A=1<<y|d<<m|x<<b,P=h[w],g=h[A];t[B].set(P,g);const S=e[y],M=e[m],C=e[b],_=n[B],z=_.start,F=_.end;z[S]=p[S],z[M]=d?p[M]:a[M],z[C]=x?p[C]:a[M],F[S]=a[S],F[M]=d?p[M]:a[M],F[C]=x?p[C]:a[M],B++}for(let y=0;y<=1;y++)for(let d=0;d<=1;d++)for(let x=0;x<=1;x++){i.x=y?a.x:p.x,i.y=d?a.y:p.y,i.z=x?a.z:p.z,this.closestPointToPoint(i,s);const m=i.distanceToSquared(s);if(m<v&&(v=m,o&&o.copy(s),u&&u.copy(i),m<f))return Math.sqrt(m)}for(let y=0;y<12;y++){const d=t[y];for(let x=0;x<12;x++){const m=n[x];Kt(d,m,s,i);const b=s.distanceToSquared(i);if(b<v&&(v=b,o&&o.copy(s),u&&u.copy(i),b<f))return Math.sqrt(b)}}return Math.sqrt(v)}}();const G=new E,K=new E,J=new E,At=new nt,vt=new nt,Tt=new nt,ae=new E,le=new E,fe=new E,Pt=new E;function fn(e,t,n,s,i,c){let r;return c===Le?r=e.intersectTriangle(s,n,t,!0,i):r=e.intersectTriangle(t,n,s,c!==Re,i),r===null?null:{distance:e.origin.distanceTo(i),point:i.clone()}}function un(e,t,n,s,i,c,r,l,o){G.fromBufferAttribute(t,c),K.fromBufferAttribute(t,r),J.fromBufferAttribute(t,l);const u=fn(e,G,K,J,Pt,o);if(u){s&&(At.fromBufferAttribute(s,c),vt.fromBufferAttribute(s,r),Tt.fromBufferAttribute(s,l),u.uv=lt.getInterpolation(Pt,G,K,J,At,vt,Tt,new nt)),i&&(At.fromBufferAttribute(i,c),vt.fromBufferAttribute(i,r),Tt.fromBufferAttribute(i,l),u.uv1=lt.getInterpolation(Pt,G,K,J,At,vt,Tt,new nt)),n&&(ae.fromBufferAttribute(n,c),le.fromBufferAttribute(n,r),fe.fromBufferAttribute(n,l),u.normal=lt.getInterpolation(Pt,G,K,J,ae,le,fe,new E),u.normal.dot(e.direction)>0&&u.normal.multiplyScalar(-1));const f={a:c,b:r,c:l,normal:new E,materialIndex:0};lt.getNormal(G,K,J,f.normal),u.face=f,u.faceIndex=c}return u}function Pe(e,t,n,s,i){const c=s*3,r=e.index.getX(c),l=e.index.getX(c+1),o=e.index.getX(c+2),{position:u,normal:f,uv:p,uv1:a}=e.attributes,h=un(n,u,f,p,a,r,l,o,t);return h?(h.faceIndex=s,i&&i.push(h),h):null}function pn(e,t,n,s,i,c){for(let r=s,l=s+i;r<l;r++)Pe(e,t,n,r,c)}function dn(e,t,n,s,i){let c=1/0,r=null;for(let l=s,o=s+i;l<o;l++){const u=Pe(e,t,n,l);u&&u.distance<c&&(r=u,c=u.distance)}return r}function ue(e,t,n){return e===null||(e.point.applyMatrix4(t.matrixWorld),e.distance=e.point.distanceTo(n.ray.origin),e.object=t,e.distance<n.near||e.distance>n.far)?null:e}function D(e,t,n,s){const i=e.a,c=e.b,r=e.c;let l=t,o=t+1,u=t+2;n&&(l=n.getX(t),o=n.getX(t+1),u=n.getX(t+2)),i.x=s.getX(l),i.y=s.getY(l),i.z=s.getZ(l),c.x=s.getX(o),c.y=s.getY(o),c.z=s.getZ(o),r.x=s.getX(u),r.y=s.getY(u),r.z=s.getZ(u)}function pe(e,t,n,s,i,c,r){const l=n.index,o=n.attributes.position;for(let u=e,f=t+e;u<f;u++)if(D(r,u*3,l,o),r.needsUpdate=!0,s(r,u,i,c))return!0;return!1}class ge{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return t.length===0?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}function H(e,t){return t[e+15]===65535}function et(e,t){return t[e+6]}function dt(e,t){return t[e+14]}function ht(e){return e+8}function mt(e,t){return t[e+6]}function hn(e,t){return t[e+7]}const tt=new st,Et=new E,mn=["x","y","z"];function Zt(e,t,n,s,i){let c=e*2,r=it,l=j,o=X;if(H(c,l)){const f=et(e,o),p=dt(c,l);pn(t,n,s,f,p,i)}else{const f=ht(e);Ct(f,r,s,Et)&&Zt(f,t,n,s,i);const p=mt(e,o);Ct(p,r,s,Et)&&Zt(p,t,n,s,i)}}function Wt(e,t,n,s){let i=e*2,c=it,r=j,l=X;if(H(i,r)){const u=et(e,l),f=dt(i,r);return dn(t,n,s,u,f)}else{const u=hn(e,l),f=mn[u],a=s.direction[f]>=0;let h,v;a?(h=ht(e),v=mt(e,l)):(h=mt(e,l),v=ht(e));const y=Ct(h,c,s,Et)?Wt(h,t,n,s):null;if(y){const m=y.point[f];if(a?m<=c[v+u]:m>=c[v+u+3])return y}const x=Ct(v,c,s,Et)?Wt(v,t,n,s):null;return y&&x?y.distance<=x.distance?y:x:y||x||null}}const yn=function(){let e,t;const n=[],s=new ge(()=>new st);return function(...r){e=s.getPrimitive(),t=s.getPrimitive(),n.push(e,t);const l=i(...r);s.releasePrimitive(e),s.releasePrimitive(t),n.pop(),n.pop();const o=n.length;return o>0&&(t=n[o-1],e=n[o-2]),l};function i(c,r,l,o,u=null,f=0,p=0){function a(m){let b=m*2,w=j,A=X;for(;!H(b,w);)m=ht(m),b=m*2;return et(m,A)}function h(m){let b=m*2,w=j,A=X;for(;!H(b,w);)m=mt(m,A),b=m*2;return et(m,A)+dt(b,w)}let v=c*2,B=it,y=j,d=X;if(H(v,y)){const m=et(c,d),b=dt(v,y);return U(c,B,e),o(m,b,!1,p,f+c,e)}else{const m=ht(c),b=mt(c,d);let w=m,A=b,P,g,T,S;if(u&&(T=e,S=t,U(w,B,T),U(A,B,S),P=u(T),g=u(S),g<P)){w=b,A=m;const L=P;P=g,g=L,T=S}T||(T=e,U(w,B,T));const M=H(w*2,y),C=l(T,M,P,p+1,f+w);let _;if(C===se){const L=a(w),W=h(w)-L;_=o(L,W,!0,p+1,f+w,T)}else _=C&&i(w,r,l,o,u,f,p+1);if(_)return!0;S=t,U(A,B,S);const z=H(A*2,y),F=l(S,z,g,p+1,f+A);let Z;if(F===se){const L=a(A),W=h(A)-L;Z=o(L,W,!0,p+1,f+A,S)}else Z=F&&i(A,r,l,o,u,f,p+1);return!!Z}}}(),xn=function(){const e=new k,t=new k,n=new pt,s=new O,i=new O;return function c(r,l,o,u,f=null){let p=r*2,a=it,h=j,v=X;if(f===null&&(o.boundingBox||o.computeBoundingBox(),s.set(o.boundingBox.min,o.boundingBox.max,u),f=s),H(p,h)){const y=l,d=y.index,x=y.attributes.position,m=o.index,b=o.attributes.position,w=et(r,v),A=dt(p,h);if(n.copy(u).invert(),o.boundsTree)return U(r,a,i),i.matrix.copy(n),i.needsUpdate=!0,o.boundsTree.shapecast({intersectsBounds:g=>i.intersectsBox(g),intersectsTriangle:g=>{g.a.applyMatrix4(u),g.b.applyMatrix4(u),g.c.applyMatrix4(u),g.needsUpdate=!0;for(let T=w*3,S=(A+w)*3;T<S;T+=3)if(D(t,T,d,x),t.needsUpdate=!0,g.intersectsTriangle(t))return!0;return!1}});for(let P=w*3,g=A+w*3;P<g;P+=3){D(e,P,d,x),e.a.applyMatrix4(n),e.b.applyMatrix4(n),e.c.applyMatrix4(n),e.needsUpdate=!0;for(let T=0,S=m.count;T<S;T+=3)if(D(t,T,m,b),t.needsUpdate=!0,e.intersectsTriangle(t))return!0}}else{const y=r+8,d=v[r+6];return U(y,a,tt),!!(f.intersectsBox(tt)&&c(y,l,o,u,f)||(U(d,a,tt),f.intersectsBox(tt)&&c(d,l,o,u,f)))}}}();function Ct(e,t,n,s){return U(e,t,tt),n.intersectBox(tt,s)}const Gt=[];let It,it,j,X;function ft(e){It&&Gt.push(It),It=e,it=new Float32Array(e),j=new Uint16Array(e),X=new Uint32Array(e)}function gt(){It=null,it=null,j=null,X=null,Gt.length&&ft(Gt.pop())}const Dt=Symbol("skip tree generation"),Ut=new st,Ot=new st,Q=new pt,Y=new O,ct=new O,at=new E,Bt=new E,wn=new E,bn=new E,An=new E,de=new st,R=new ge(()=>new k);class ut{static serialize(t,n={}){if(n.isBufferGeometry)return console.warn("MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature."),ut.serialize(arguments[0],{cloneBuffers:arguments[2]===void 0?!0:arguments[2]});n={cloneBuffers:!0,...n};const s=t.geometry,i=t._roots,c=s.getIndex();let r;return n.cloneBuffers?r={roots:i.map(l=>l.slice()),index:c.array.slice()}:r={roots:i,index:c.array},r}static deserialize(t,n,s={}){if(typeof s=="boolean")return console.warn("MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature."),ut.deserialize(arguments[0],arguments[1],{setIndex:arguments[2]===void 0?!0:arguments[2]});s={setIndex:!0,...s};const{index:i,roots:c}=t,r=new ut(n,{...s,[Dt]:!0});if(r._roots=c,s.setIndex){const l=n.getIndex();if(l===null){const o=new we(t.index,1,!1);n.setIndex(o)}else l.array!==i&&(l.array.set(i),l.needsUpdate=!0)}return r}constructor(t,n={}){if(t.isBufferGeometry){if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(n=Object.assign({strategy:Te,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,[Dt]:!1},n),n.useSharedArrayBuffer&&typeof SharedArrayBuffer>"u")throw new Error("MeshBVH: SharedArrayBuffer is not available.");this._roots=null,n[Dt]||(this._roots=rn(t,n),!t.boundingBox&&n.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new st))),this.geometry=t}refit(t=null){t&&Array.isArray(t)&&(t=new Set(t));const n=this.geometry,s=n.index.array,i=n.attributes.position;let c,r,l,o,u=0;const f=this._roots;for(let a=0,h=f.length;a<h;a++)c=f[a],r=new Uint32Array(c),l=new Uint16Array(c),o=new Float32Array(c),p(0,u),u+=c.byteLength;function p(a,h,v=!1){const B=a*2;if(l[B+15]===Yt){const d=r[a+6],x=l[B+14];let m=1/0,b=1/0,w=1/0,A=-1/0,P=-1/0,g=-1/0;for(let T=3*d,S=3*(d+x);T<S;T++){const M=s[T],C=i.getX(M),_=i.getY(M),z=i.getZ(M);C<m&&(m=C),C>A&&(A=C),_<b&&(b=_),_>P&&(P=_),z<w&&(w=z),z>g&&(g=z)}return o[a+0]!==m||o[a+1]!==b||o[a+2]!==w||o[a+3]!==A||o[a+4]!==P||o[a+5]!==g?(o[a+0]=m,o[a+1]=b,o[a+2]=w,o[a+3]=A,o[a+4]=P,o[a+5]=g,!0):!1}else{const d=a+8,x=r[a+6],m=d+h,b=x+h;let w=v,A=!1,P=!1;t?w||(A=t.has(m),P=t.has(b),w=!A&&!P):(A=!0,P=!0);const g=w||A,T=w||P;let S=!1;g&&(S=p(d,h,w));let M=!1;T&&(M=p(x,h,w));const C=S||M;if(C)for(let _=0;_<3;_++){const z=d+_,F=x+_,Z=o[z],L=o[z+3],yt=o[F],W=o[F+3];o[a+_]=Z<yt?Z:yt,o[a+_+3]=L>W?L:W}return C}}}traverse(t,n=0){const s=this._roots[n],i=new Uint32Array(s),c=new Uint16Array(s);r(0);function r(l,o=0){const u=l*2,f=c[u+15]===Yt;if(f){const p=i[l+6],a=c[u+14];t(o,f,new Float32Array(s,l*4,6),p,a)}else{const p=l+Mt/4,a=i[l+6],h=i[l+7];t(o,f,new Float32Array(s,l*4,6),h)||(r(p,o+1),r(a,o+1))}}}raycast(t,n=ee){const s=this._roots,i=this.geometry,c=[],r=n.isMaterial,l=Array.isArray(n),o=i.groups,u=r?n.side:n;for(let f=0,p=s.length;f<p;f++){const a=l?n[o[f].materialIndex].side:u,h=c.length;if(ft(s[f]),Zt(0,i,a,t,c),gt(),l){const v=o[f].materialIndex;for(let B=h,y=c.length;B<y;B++)c[B].face.materialIndex=v}}return c}raycastFirst(t,n=ee){const s=this._roots,i=this.geometry,c=n.isMaterial,r=Array.isArray(n);let l=null;const o=i.groups,u=c?n.side:n;for(let f=0,p=s.length;f<p;f++){const a=r?n[o[f].materialIndex].side:u;ft(s[f]);const h=Wt(0,i,a,t);gt(),h!=null&&(l==null||h.distance<l.distance)&&(l=h,r&&(h.face.materialIndex=o[f].materialIndex))}return l}intersectsGeometry(t,n){const s=this.geometry;let i=!1;for(const c of this._roots)if(ft(c),i=xn(0,s,t,n),gt(),i)break;return i}shapecast(t,n,s){const i=this.geometry;if(t instanceof Function){if(n){const a=n;n=(h,v,B,y)=>{const d=v*3;return a(h,d,d+1,d+2,B,y)}}t={boundsTraverseOrder:s,intersectsBounds:t,intersectsTriangle:n,intersectsRange:null},console.warn("MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.")}const c=R.getPrimitive();let{boundsTraverseOrder:r,intersectsBounds:l,intersectsRange:o,intersectsTriangle:u}=t;if(o&&u){const a=o;o=(h,v,B,y,d)=>a(h,v,B,y,d)?!0:pe(h,v,i,u,B,y,c)}else o||(u?o=(a,h,v,B)=>pe(a,h,i,u,v,B,c):o=(a,h,v)=>v);let f=!1,p=0;for(const a of this._roots){if(ft(a),f=yn(0,i,l,o,r,p),gt(),f)break;p+=a.byteLength}return R.releasePrimitive(c),f}bvhcast(t,n,s){let{intersectsRanges:i,intersectsTriangles:c}=s;const r=this.geometry.index,l=this.geometry.attributes.position,o=t.geometry.index,u=t.geometry.attributes.position;Q.copy(n).invert();const f=R.getPrimitive(),p=R.getPrimitive();if(c){let h=function(v,B,y,d,x,m,b,w){for(let A=y,P=y+d;A<P;A++){D(p,A*3,o,u),p.a.applyMatrix4(n),p.b.applyMatrix4(n),p.c.applyMatrix4(n),p.needsUpdate=!0;for(let g=v,T=v+B;g<T;g++)if(D(f,g*3,r,l),f.needsUpdate=!0,c(f,p,g,A,x,m,b,w))return!0}return!1};if(i){const v=i;i=function(B,y,d,x,m,b,w,A){return v(B,y,d,x,m,b,w,A)?!0:h(B,y,d,x,m,b,w,A)}}else i=h}t.getBoundingBox(Ot),Ot.applyMatrix4(n);const a=this.shapecast({intersectsBounds:h=>Ot.intersectsBox(h),intersectsRange:(h,v,B,y,d,x)=>(Ut.copy(x),Ut.applyMatrix4(Q),t.shapecast({intersectsBounds:m=>Ut.intersectsBox(m),intersectsRange:(m,b,w,A,P)=>i(h,v,m,b,y,d,A,P)}))});return R.releasePrimitive(f),R.releasePrimitive(p),a}intersectsBox(t,n){return Y.set(t.min,t.max,n),Y.needsUpdate=!0,this.shapecast({intersectsBounds:s=>Y.intersectsBox(s),intersectsTriangle:s=>Y.intersectsTriangle(s)})}intersectsSphere(t){return this.shapecast({intersectsBounds:n=>t.intersectsBox(n),intersectsTriangle:n=>n.intersectsSphere(t)})}closestPointToGeometry(t,n,s={},i={},c=0,r=1/0){t.boundingBox||t.computeBoundingBox(),Y.set(t.boundingBox.min,t.boundingBox.max,n),Y.needsUpdate=!0;const l=this.geometry,o=l.attributes.position,u=l.index,f=t.attributes.position,p=t.index,a=R.getPrimitive(),h=R.getPrimitive();let v=Bt,B=wn,y=null,d=null;i&&(y=bn,d=An);let x=1/0,m=null,b=null;return Q.copy(n).invert(),ct.matrix.copy(Q),this.shapecast({boundsTraverseOrder:w=>Y.distanceToBox(w),intersectsBounds:(w,A,P)=>P<x&&P<r?(A&&(ct.min.copy(w.min),ct.max.copy(w.max),ct.needsUpdate=!0),!0):!1,intersectsRange:(w,A)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:P=>ct.distanceToBox(P),intersectsBounds:(P,g,T)=>T<x&&T<r,intersectsRange:(P,g)=>{for(let T=P*3,S=(P+g)*3;T<S;T+=3){D(h,T,p,f),h.a.applyMatrix4(n),h.b.applyMatrix4(n),h.c.applyMatrix4(n),h.needsUpdate=!0;for(let M=w*3,C=(w+A)*3;M<C;M+=3){D(a,M,u,o),a.needsUpdate=!0;const _=a.distanceToTriangle(h,v,y);if(_<x&&(B.copy(v),d&&d.copy(y),x=_,m=M/3,b=T/3),_<c)return!0}}}});{const P=p?p.count:f.count;for(let g=0,T=P;g<T;g+=3){D(h,g,p,f),h.a.applyMatrix4(n),h.b.applyMatrix4(n),h.c.applyMatrix4(n),h.needsUpdate=!0;for(let S=w*3,M=(w+A)*3;S<M;S+=3){D(a,S,u,o),a.needsUpdate=!0;const C=a.distanceToTriangle(h,v,y);if(C<x&&(B.copy(v),d&&d.copy(y),x=C,m=S/3,b=g/3),C<c)return!0}}}}}),R.releasePrimitive(a),R.releasePrimitive(h),x===1/0?null:(s.point?s.point.copy(B):s.point=B.clone(),s.distance=x,s.faceIndex=m,i&&(i.point?i.point.copy(d):i.point=d.clone(),i.point.applyMatrix4(Q),B.applyMatrix4(Q),i.distance=B.sub(i.point).length(),i.faceIndex=b),s)}closestPointToPoint(t,n={},s=0,i=1/0){const c=s*s,r=i*i;let l=1/0,o=null;if(this.shapecast({boundsTraverseOrder:f=>(at.copy(t).clamp(f.min,f.max),at.distanceToSquared(t)),intersectsBounds:(f,p,a)=>a<l&&a<r,intersectsTriangle:(f,p)=>{f.closestPointToPoint(t,at);const a=t.distanceToSquared(at);return a<l&&(Bt.copy(at),l=a,o=p),a<c}}),l===1/0)return null;const u=Math.sqrt(l);return n.point?n.point.copy(Bt):n.point=Bt.clone(),n.distance=u,n.faceIndex=o,n}getBoundingBox(t){return t.makeEmpty(),this._roots.forEach(s=>{U(0,new Float32Array(s),de),t.union(de)}),t}}const $t=new De,he=new pt,vn=St.prototype.raycast;function Tn(e,t){if(this.geometry.boundsTree){if(this.material===void 0)return;he.copy(this.matrixWorld).invert(),$t.copy(e.ray).applyMatrix4(he);const n=this.geometry.boundsTree;if(e.firstHitOnly===!0){const s=ue(n.raycastFirst($t,this.material),this,e);s&&t.push(s)}else{const s=n.raycast($t,this.material);for(let i=0,c=s.length;i<c;i++){const r=ue(s[i],this,e);r&&t.push(r)}}}else vn.call(this,e,t)}function Pn(e){return this.boundsTree=new ut(this,e),this.boundsTree}function gn(){this.boundsTree=null}const Bn=(e={})=>{let{computeBoundsTree:t,disposeBoundsTree:n}=ot.prototype,{raycast:s}=St.prototype;ot.prototype.computeBoundsTree=Pn,ot.prototype.disposeBoundsTree=gn,St.prototype.raycast=Tn,ne.prototype.firstHitOnly=e.firstHitOnly??!0;const i=Ae(r=>{const l=r;l.isMesh&&l.geometry.computeBoundsTree(e)}),c=ve(r=>{const l=r;l.isMesh&&l.geometry.disposeBoundsTree()});return()=>{i(),c(),ot.prototype.computeBoundsTree=t,ot.prototype.disposeBoundsTree=n,St.prototype.raycast=s,delete ne.prototype.firstHitOnly}},Sn=e=>{I.interactiveMap[e.uuid]===void 0&&(I.interactiveObjects.push(e),I.interactiveMap[e.uuid]=e)},Mn=e=>{const t=I.interactiveObjects.indexOf(e);I.interactiveObjects.splice(t,1),delete I.interactiveMap[e.uuid]},In=()=>{const e=Ae(n=>Sn(n)),t=ve(n=>Mn(n));return()=>{e(),t()}},Jt=e=>`${(e.eventObject||e.object).uuid}/${e.index}${e.instanceId}`,me=[["click",!1],["contextmenu",!1],["dblclick",!1],["wheel",!1],["pointerdown",!0],["pointerup",!0],["pointerleave",!0],["pointerenter",!0],["pointermove",!0],["pointercancel",!0]],En=e=>{const t=e.offsetX-(I.initialClick[0]??0),n=e.offsetY-(I.initialClick[1]??0);return Math.round(Math.hypot(t,n))},Vt=e=>{I.hovered.forEach(t=>{if(e.length===0||!e.some(n=>n.object===t.object&&n.index===t.index&&n.instanceId===t.instanceId)){const{eventObject:n}=t;I.hovered.delete(Jt(t)),n.dispatchEvent({type:"pointerout",...t,intersections:e}),n.dispatchEvent({type:"pointerleave",...t,intersections:e})}})},Cn=()=>{const e=new Set,t=[];let n=I.raycaster.intersectObjects(I.interactiveObjects).sort((s,i)=>s.distance-i.distance).filter(s=>{const i=Jt(s);return e.has(i)?!1:(e.add(i),!0)});return I.filter&&(n=I.filter(n,I)),n.forEach(s=>{let i=s.object;for(;i;)t.push({...s,eventObject:i}),i=i.parent}),t},ye=(e,t)=>{t.forEach(n=>{n.dispatchEvent({type:"pointermissed",event:e})})},xe=e=>e==="pointerleave"||e==="pointercancel"?()=>{I.pointerOverTarget=!1,Vt([])}:e==="pointerenter"?()=>{I.pointerOverTarget=!0}:t=>{const n=e==="pointermove",s=e==="click"||e==="contextmenu"||e==="dblclick";I.compute(t,I);const i=I.enabled?Cn():[],c=s?En(t):0;e==="pointerdown"&&(I.initialClick=[t.offsetX,t.offsetY],I.initialHits=i.map(o=>o.eventObject)),s&&i.length===0&&c<=2&&ye(t,I.interactiveObjects),n&&Vt(i);let r=!1;const l=()=>{r=!0};for(let o=0,u=i.length;o<u;o+=1){const f=i[o],p={stopped:r,...f,intersections:i,stopPropagation(){l(),p.stopped=!0;const a=[...I.hovered.values()];if(I.hovered.size>0&&a.some(h=>h.eventObject===f.eventObject)){const h=i.slice(0,i.indexOf(f));Vt([...h,f])}},camera:I.raycaster.camera,delta:c,nativeEvent:t,pointer:I.pointer,ray:I.raycaster.ray};if(n){const a=Jt(p),h=I.hovered.get(a);h?h.stopped&&p.stopPropagation():(I.hovered.set(a,p),f.eventObject.dispatchEvent({type:"pointerover",...p}),f.eventObject.dispatchEvent({type:"pointerenter",...p})),f.eventObject.dispatchEvent({type:"pointermove",...p})}else(!s||I.initialHits.includes(f.eventObject))&&(ye(t,I.interactiveObjects.filter(a=>!I.initialHits.includes(a))),f.eventObject.dispatchEvent({type:e,...p}));if(r)break}},_n=()=>(me.forEach(([e,t])=>{I.target.addEventListener(e,xe(e),{passive:t})}),()=>{me.forEach(([e])=>{I.target.removeEventListener(e,xe(e))})}),zn=e=>{I.camera=e.camera,I.enabled=e.enabled??!0,I.target=e.target,I.filter=e.filter,I.compute=e.compute??je();const t=In(),n=_n();return{context:I,dispose:()=>{t(),n()}}},Fn=e=>{const t=2*Math.PI*Math.random();return[e*Math.cos(t),e*Math.sin(t)]},Ln=e=>{e.traverse(t=>{const n="isMesh"in t,s="isLight"in t&&!("isAmbientLight"in t)&&!("isRectAreaLight"in t);t.castShadow=n||s,t.receiveShadow=n})},Rn=`
import * as THREE from 'three'
import { pointerEvents } from 'trzy'

pointerEvents({ target: canvas, camera })

const mesh = new THREE.Mesh(
  new THREE.BoxGeometry(),
  new THREE.MeshStandardMaterial()
)

mesh.addEventListener('pointerenter', (event) => console.log(event))
mesh.addEventListener('pointerleave', (event) => console.log(event))
mesh.addEventListener('click', (event) => console.log(event))

mesh.addEventListener('pointerenter', (event) => {
  // Call stop propagation to stop events from firing on other intersections.
  event.stopPropagation()
})
`;function Dn(e){let t,n="Adds pointer events to all rendererable objects.",s,i,c,r,l;return i=new ke({}),r=new He({props:{code:Rn}}),{c(){t=Ce("p"),t.textContent=n,s=Qt(),qt(i.$$.fragment),c=Qt(),qt(r.$$.fragment)},l(o){t=_e(o,"P",{"data-svelte-h":!0}),ze(t)!=="svelte-1y787p9"&&(t.textContent=n),s=te(o),kt(i.$$.fragment,o),c=te(o),kt(r.$$.fragment,o)},m(o,u){_t(o,t,u),_t(o,s,u),Nt(i,o,u),_t(o,c,u),Nt(r,o,u),l=!0},p:Me,i(o){l||(Ht(i.$$.fragment,o),Ht(r.$$.fragment,o),l=!0)},o(o){jt(i.$$.fragment,o),jt(r.$$.fragment,o),l=!1},d(o){o&&(zt(t),zt(s),zt(c)),Xt(i,o),Xt(r,o)}}}function Un(e){let t,n;return t=new Ne({props:{title:"pointerEvents",$$slots:{default:[Dn]},$$scope:{ctx:e}}}),{c(){qt(t.$$.fragment)},l(s){kt(t.$$.fragment,s)},m(s,i){Nt(t,s,i),n=!0},p(s,[i]){const c={};i&1&&(c.$$scope={dirty:i,ctx:s}),t.$set(c)},i(s){n||(Ht(t.$$.fragment,s),n=!0)},o(s){jt(t.$$.fragment,s),n=!1},d(s){Xt(t,s)}}}function On(e){return Se(()=>{const{scene:t,camera:n,renderer:s}=Ue(),i=Bn(),{dispose:c}=zn({target:s.domElement,camera:n.current});Oe();const r=Array.from({length:100}).map(()=>{const o=new $e({color:"yellow"}),u=.1,f=Ve(o,u,u,u),[p,a]=Fn(1.5);return f.position.set(p,-.25,a),f.userData.rotation={y:(Math.random()-.5)*.1,z:(Math.random()-.5)*.1},f.addEventListener("pointerenter",h=>{h.stopPropagation(),o.color.set("hotpink")}),f.addEventListener("pointerleave",()=>o.color.set("yellow")),f.addEventListener("click",()=>o.color.set("blue")),f});t.add(...r),Ln(t);const{stop:l}=qe(()=>{r.forEach(o=>{o.rotation.y+=o.userData.rotation.y,o.rotation.z+=o.userData.rotation.z})});return()=>{i(),l(),c()}}),[]}class Nn extends Ie{constructor(t){super(),Ee(this,t,On,Un,Be,{})}}export{Nn as component};
