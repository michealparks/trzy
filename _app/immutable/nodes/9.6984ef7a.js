import{s as ie,o as re,n as oe}from"../chunks/scheduler.b0c1c2c3.js";import{S as ce,i as ae,r as ln,u as fn,v as un,d as pn,t as dn,w as yn,g as le,s as Mn,h as fe,z as ue,c as _n,a as Yt,f as Zt}from"../chunks/index.b5e22aac.js";import{e as F,f as Qn,V as E,g as dt,P as Gn,L as W,T as vt,S as pe,h as tt,i as Y,j as de,D as ye,F as Sn,R as me,M as Ht,k as Wt,l as Cn,m as wt,n as he,o as xe,u as we,s as Ae,c as ge,p as be,b as Te,C as Be}from"../chunks/setup.41a98375.js";import{D as Pe,C as ve}from"../chunks/code.017dda36.js";const Me=()=>{let n=0,t=0;return new ResizeObserver(([s])=>{n=(s==null?void 0:s.contentRect.width)??0,t=(s==null?void 0:s.contentRect.height)??0}).observe(F.target),s=>{F.pointer.set(s.offsetX/n*2-1,-(s.offsetY/t*2)+1),F.raycaster.setFromCamera(F.pointer,F.camera)}},te=0,_e=1,Se=2,En=2,Kt=1.25,Ln=1,Nt=6*4+4+4,Ot=65535,Ce=Math.pow(2,-24),Jt=Symbol("SKIP_GENERATION");function Ee(n){return n.index?n.index.count:n.attributes.position.count}function yt(n){return Ee(n)/3}function Le(n,t=ArrayBuffer){return n>65535?new Uint32Array(new t(4*n)):new Uint16Array(new t(2*n))}function Fe(n,t){if(!n.index){const e=n.attributes.position.count,s=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,i=Le(e,s);n.setIndex(new Qn(i,1));for(let a=0;a<e;a++)i[a]=a}}function ne(n){const t=yt(n),e=n.drawRange,s=e.start/3,i=(e.start+e.count)/3,a=Math.max(0,s),o=Math.min(t,i)-a;return[{offset:Math.floor(a),count:Math.floor(o)}]}function ee(n){if(!n.groups||!n.groups.length)return ne(n);const t=[],e=new Set,s=n.drawRange,i=s.start/3,a=(s.start+s.count)/3;for(const c of n.groups){const r=c.start/3,p=(c.start+c.count)/3;e.add(Math.max(i,r)),e.add(Math.min(a,p))}const o=Array.from(e.values()).sort((c,r)=>c-r);for(let c=0;c<o.length-1;c++){const r=o[c],p=o[c+1];t.push({offset:Math.floor(r),count:Math.floor(p-r)})}return t}function $e(n){if(n.groups.length===0)return!1;const t=yt(n),e=ee(n).sort((a,o)=>a.offset-o.offset),s=e[e.length-1];s.count=Math.min(t-s.offset,s.count);let i=0;return e.forEach(({count:a})=>i+=a),t!==i}function U(n,t,e){return e.min.x=t[n],e.min.y=t[n+1],e.min.z=t[n+2],e.max.x=t[n+3],e.max.y=t[n+4],e.max.z=t[n+5],e}function ze(n){n[0]=n[1]=n[2]=1/0,n[3]=n[4]=n[5]=-1/0}function Fn(n){let t=-1,e=-1/0;for(let s=0;s<3;s++){const i=n[s+3]-n[s];i>e&&(e=i,t=s)}return t}function $n(n,t){t.set(n)}function zn(n,t,e){let s,i;for(let a=0;a<3;a++){const o=a+3;s=n[a],i=t[a],e[a]=s<i?s:i,s=n[o],i=t[o],e[o]=s>i?s:i}}function _t(n,t,e){for(let s=0;s<3;s++){const i=t[n+2*s],a=t[n+2*s+1],o=i-a,c=i+a;o<e[s]&&(e[s]=o),c>e[s+3]&&(e[s+3]=c)}}function At(n){const t=n[3]-n[0],e=n[4]-n[1],s=n[5]-n[2];return 2*(t*e+e*s+s*t)}function Qt(n,t,e,s,i=null){let a=1/0,o=1/0,c=1/0,r=-1/0,p=-1/0,f=-1/0,u=1/0,l=1/0,d=1/0,m=-1/0,T=-1/0,g=-1/0;const y=i!==null;for(let x=t*6,A=(t+e)*6;x<A;x+=6){const h=n[x+0],w=n[x+1],b=h-w,v=h+w;b<a&&(a=b),v>r&&(r=v),y&&h<u&&(u=h),y&&h>m&&(m=h);const B=n[x+2],M=n[x+3],_=B-M,C=B+M;_<o&&(o=_),C>p&&(p=C),y&&B<l&&(l=B),y&&B>T&&(T=B);const P=n[x+4],S=n[x+5],L=P-S,$=P+S;L<c&&(c=L),$>f&&(f=$),y&&P<d&&(d=P),y&&P>g&&(g=P)}s[0]=a,s[1]=o,s[2]=c,s[3]=r,s[4]=p,s[5]=f,y&&(i[0]=u,i[1]=l,i[2]=d,i[3]=m,i[4]=T,i[5]=g)}function Ue(n,t,e,s){let i=1/0,a=1/0,o=1/0,c=-1/0,r=-1/0,p=-1/0;for(let f=t*6,u=(t+e)*6;f<u;f+=6){const l=n[f+0];l<i&&(i=l),l>c&&(c=l);const d=n[f+2];d<a&&(a=d),d>r&&(r=d);const m=n[f+4];m<o&&(o=m),m>p&&(p=m)}s[0]=i,s[1]=a,s[2]=o,s[3]=c,s[4]=r,s[5]=p}function Re(n,t){ze(t);const e=n.attributes.position,s=n.index?n.index.array:null,i=yt(n),a=new Float32Array(i*6),o=e.normalized,c=e.array,r=e.offset||0;let p=3;e.isInterleavedBufferAttribute&&(p=e.data.stride);const f=["getX","getY","getZ"];for(let u=0;u<i;u++){const l=u*3,d=u*6;let m=l+0,T=l+1,g=l+2;s&&(m=s[m],T=s[T],g=s[g]),o||(m=m*p+r,T=T*p+r,g=g*p+r);for(let y=0;y<3;y++){let x,A,h;o?(x=e[f[y]](m),A=e[f[y]](T),h=e[f[y]](g)):(x=c[m+y],A=c[T+y],h=c[g+y]);let w=x;A<w&&(w=A),h<w&&(w=h);let b=x;A>b&&(b=A),h>b&&(b=h);const v=(b-w)/2,B=y*2;a[d+B+0]=w+v,a[d+B+1]=v+(Math.abs(w)+v)*Ce,w<t[y]&&(t[y]=w),b>t[y+3]&&(t[y+3]=b)}}return a}const Z=32,De=(n,t)=>n.candidate-t.candidate,J=new Array(Z).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),St=new Float32Array(6);function Ie(n,t,e,s,i,a){let o=-1,c=0;if(a===te)o=Fn(t),o!==-1&&(c=(t[o]+t[o+3])/2);else if(a===_e)o=Fn(n),o!==-1&&(c=Ve(e,s,i,o));else if(a===Se){const r=At(n);let p=Kt*i;const f=s*6,u=(s+i)*6;for(let l=0;l<3;l++){const d=t[l],g=(t[l+3]-d)/Z;if(i<Z/4){const y=[...J];y.length=i;let x=0;for(let h=f;h<u;h+=6,x++){const w=y[x];w.candidate=e[h+2*l],w.count=0;const{bounds:b,leftCacheBounds:v,rightCacheBounds:B}=w;for(let M=0;M<3;M++)B[M]=1/0,B[M+3]=-1/0,v[M]=1/0,v[M+3]=-1/0,b[M]=1/0,b[M+3]=-1/0;_t(h,e,b)}y.sort(De);let A=i;for(let h=0;h<A;h++){const w=y[h];for(;h+1<A&&y[h+1].candidate===w.candidate;)y.splice(h+1,1),A--}for(let h=f;h<u;h+=6){const w=e[h+2*l];for(let b=0;b<A;b++){const v=y[b];w>=v.candidate?_t(h,e,v.rightCacheBounds):(_t(h,e,v.leftCacheBounds),v.count++)}}for(let h=0;h<A;h++){const w=y[h],b=w.count,v=i-w.count,B=w.leftCacheBounds,M=w.rightCacheBounds;let _=0;b!==0&&(_=At(B)/r);let C=0;v!==0&&(C=At(M)/r);const P=Ln+Kt*(_*b+C*v);P<p&&(o=l,p=P,c=w.candidate)}}else{for(let A=0;A<Z;A++){const h=J[A];h.count=0,h.candidate=d+g+A*g;const w=h.bounds;for(let b=0;b<3;b++)w[b]=1/0,w[b+3]=-1/0}for(let A=f;A<u;A+=6){let b=~~((e[A+2*l]-d)/g);b>=Z&&(b=Z-1);const v=J[b];v.count++,_t(A,e,v.bounds)}const y=J[Z-1];$n(y.bounds,y.rightCacheBounds);for(let A=Z-2;A>=0;A--){const h=J[A],w=J[A+1];zn(h.bounds,w.rightCacheBounds,h.rightCacheBounds)}let x=0;for(let A=0;A<Z-1;A++){const h=J[A],w=h.count,b=h.bounds,B=J[A+1].rightCacheBounds;w!==0&&(x===0?$n(b,St):zn(b,St,St)),x+=w;let M=0,_=0;x!==0&&(M=At(St)/r);const C=i-x;C!==0&&(_=At(B)/r);const P=Ln+Kt*(M*x+_*C);P<p&&(o=l,p=P,c=h.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${a} used.`);return{axis:o,pos:c}}function Ve(n,t,e,s){let i=0;for(let a=t,o=t+e;a<o;a++)i+=n[a*6+s*2];return i/e}class Ct{constructor(){}}function ke(n,t,e,s,i,a){let o=s,c=s+i-1;const r=a.pos,p=a.axis*2;for(;;){for(;o<=c&&e[o*6+p]<r;)o++;for(;o<=c&&e[c*6+p]>=r;)c--;if(o<c){for(let f=0;f<3;f++){let u=t[o*3+f];t[o*3+f]=t[c*3+f],t[c*3+f]=u}for(let f=0;f<6;f++){let u=e[o*6+f];e[o*6+f]=e[c*6+f],e[c*6+f]=u}o++,c--}else return o}}function qe(n,t,e,s,i,a){let o=s,c=s+i-1;const r=a.pos,p=a.axis*2;for(;;){for(;o<=c&&e[o*6+p]<r;)o++;for(;o<=c&&e[c*6+p]>=r;)c--;if(o<c){let f=n[o];n[o]=n[c],n[c]=f;for(let u=0;u<6;u++){let l=e[o*6+u];e[o*6+u]=e[c*6+u],e[c*6+u]=l}o++,c--}else return o}}function He(n,t){const e=(n.index?n.index.count:n.attributes.position.count)/3,s=e>2**16,i=s?4:2,a=t?new SharedArrayBuffer(e*i):new ArrayBuffer(e*i),o=s?new Uint32Array(a):new Uint16Array(a);for(let c=0,r=o.length;c<r;c++)o[c]=c;return o}function Ne(n,t){const e=n.geometry,s=e.index?e.index.array:null,i=t.maxDepth,a=t.verbose,o=t.maxLeafTris,c=t.strategy,r=t.onProgress,p=yt(e),f=n._indirectBuffer;let u=!1;const l=new Float32Array(6),d=new Float32Array(6),m=Re(e,l),T=t.indirect?qe:ke,g=[],y=t.indirect?ne(e):ee(e);if(y.length===1){const h=y[0],w=new Ct;w.boundingData=l,Ue(m,h.offset,h.count,d),A(w,h.offset,h.count,d),g.push(w)}else for(let h of y){const w=new Ct;w.boundingData=new Float32Array(6),Qt(m,h.offset,h.count,w.boundingData,d),A(w,h.offset,h.count,d),g.push(w)}return g;function x(h){r&&r(h/p)}function A(h,w,b,v=null,B=0){if(!u&&B>=i&&(u=!0,a&&(console.warn(`MeshBVH: Max depth of ${i} reached when generating BVH. Consider increasing maxDepth.`),console.warn(e))),b<=o||B>=i)return x(w+b),h.offset=w,h.count=b,h;const M=Ie(h.boundingData,v,m,w,b,c);if(M.axis===-1)return x(w+b),h.offset=w,h.count=b,h;const _=T(f,s,m,w,b,M);if(_===w||_===w+b)x(w+b),h.offset=w,h.count=b;else{h.splitAxis=M.axis;const C=new Ct,P=w,S=_-w;h.left=C,C.boundingData=new Float32Array(6),Qt(m,P,S,C.boundingData,d),A(C,P,S,d,B+1);const L=new Ct,$=_,R=b-S;h.right=L,L.boundingData=new Float32Array(6),Qt(m,$,R,L.boundingData,d),A(L,$,R,d,B+1)}return h}}function je(n,t){const e=n.geometry;t.indirect&&(n._indirectBuffer=He(e,t.useSharedArrayBuffer),$e(e)&&!t.verbose&&console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),n._indirectBuffer||Fe(e,t);const s=Ne(n,t);let i,a,o;const c=[],r=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;for(let u=0;u<s.length;u++){const l=s[u];let d=p(l);const m=new r(Nt*d);i=new Float32Array(m),a=new Uint32Array(m),o=new Uint16Array(m),f(0,l),c.push(m)}n._roots=c;return;function p(u){return u.count?1:1+p(u.left)+p(u.right)}function f(u,l){const d=u/4,m=u/2,T=!!l.count,g=l.boundingData;for(let y=0;y<6;y++)i[d+y]=g[y];if(T){const y=l.offset,x=l.count;return a[d+6]=y,o[m+14]=x,o[m+15]=Ot,u+Nt}else{const y=l.left,x=l.right,A=l.splitAxis;let h;if(h=f(u+Nt,y),h/4>Math.pow(2,32))throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return a[d+6]=h/4,h=f(h,x),a[d+7]=A,h}}}class K{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let s=1/0,i=-1/0;for(let a=0,o=t.length;a<o;a++){const r=t[a][e];s=r<s?r:s,i=r>i?r:i}this.min=s,this.max=i}setFromPoints(t,e){let s=1/0,i=-1/0;for(let a=0,o=e.length;a<o;a++){const c=e[a],r=t.dot(c);s=r<s?r:s,i=r>i?r:i}this.min=s,this.max=i}isSeparated(t){return this.min>t.max||t.min>this.max}}K.prototype.setFromBox=function(){const n=new E;return function(e,s){const i=s.min,a=s.max;let o=1/0,c=-1/0;for(let r=0;r<=1;r++)for(let p=0;p<=1;p++)for(let f=0;f<=1;f++){n.x=i.x*r+a.x*(1-r),n.y=i.y*p+a.y*(1-p),n.z=i.z*f+a.z*(1-f);const u=e.dot(n);o=Math.min(u,o),c=Math.max(u,c)}this.min=o,this.max=c}}();const Oe=function(){const n=new E,t=new E,e=new E;return function(i,a,o){const c=i.start,r=n,p=a.start,f=t;e.subVectors(c,p),n.subVectors(i.end,i.start),t.subVectors(a.end,a.start);const u=e.dot(f),l=f.dot(r),d=f.dot(f),m=e.dot(r),g=r.dot(r)*d-l*l;let y,x;g!==0?y=(u*l-m*d)/g:y=0,x=(u+y*l)/d,o.x=y,o.y=x}}(),Tn=function(){const n=new dt,t=new E,e=new E;return function(i,a,o,c){Oe(i,a,n);let r=n.x,p=n.y;if(r>=0&&r<=1&&p>=0&&p<=1){i.at(r,o),a.at(p,c);return}else if(r>=0&&r<=1){p<0?a.at(0,c):a.at(1,c),i.closestPointToPoint(c,!0,o);return}else if(p>=0&&p<=1){r<0?i.at(0,o):i.at(1,o),a.closestPointToPoint(o,!0,c);return}else{let f;r<0?f=i.start:f=i.end;let u;p<0?u=a.start:u=a.end;const l=t,d=e;if(i.closestPointToPoint(u,!0,t),a.closestPointToPoint(f,!0,e),l.distanceToSquared(u)<=d.distanceToSquared(f)){o.copy(l),c.copy(u);return}else{o.copy(f),c.copy(d);return}}}}(),Xe=function(){const n=new E,t=new E,e=new Gn,s=new W;return function(a,o){const{radius:c,center:r}=a,{a:p,b:f,c:u}=o;if(s.start=p,s.end=f,s.closestPointToPoint(r,!0,n).distanceTo(r)<=c||(s.start=p,s.end=u,s.closestPointToPoint(r,!0,n).distanceTo(r)<=c)||(s.start=f,s.end=u,s.closestPointToPoint(r,!0,n).distanceTo(r)<=c))return!0;const T=o.getPlane(e);if(Math.abs(T.distanceToPoint(r))<=c){const y=T.projectPoint(r,t);if(o.containsPoint(y))return!0}return!1}}(),Ye=1e-15;function Gt(n){return Math.abs(n)<Ye}class X extends vt{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new E),this.satBounds=new Array(4).fill().map(()=>new K),this.points=[this.a,this.b,this.c],this.sphere=new pe,this.plane=new Gn,this.needsUpdate=!0}intersectsSphere(t){return Xe(t,this)}update(){const t=this.a,e=this.b,s=this.c,i=this.points,a=this.satAxes,o=this.satBounds,c=a[0],r=o[0];this.getNormal(c),r.setFromPoints(c,i);const p=a[1],f=o[1];p.subVectors(t,e),f.setFromPoints(p,i);const u=a[2],l=o[2];u.subVectors(e,s),l.setFromPoints(u,i);const d=a[3],m=o[3];d.subVectors(s,t),m.setFromPoints(d,i),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(c,t),this.needsUpdate=!1}}X.prototype.closestPointToSegment=function(){const n=new E,t=new E,e=new W;return function(i,a=null,o=null){const{start:c,end:r}=i,p=this.points;let f,u=1/0;for(let l=0;l<3;l++){const d=(l+1)%3;e.start.copy(p[l]),e.end.copy(p[d]),Tn(e,i,n,t),f=n.distanceToSquared(t),f<u&&(u=f,a&&a.copy(n),o&&o.copy(t))}return this.closestPointToPoint(c,n),f=c.distanceToSquared(n),f<u&&(u=f,a&&a.copy(n),o&&o.copy(c)),this.closestPointToPoint(r,n),f=r.distanceToSquared(n),f<u&&(u=f,a&&a.copy(n),o&&o.copy(r)),Math.sqrt(u)}}();X.prototype.intersectsTriangle=function(){const n=new X,t=new Array(3),e=new Array(3),s=new K,i=new K,a=new E,o=new E,c=new E,r=new E,p=new E,f=new W,u=new W,l=new W,d=new E;function m(T,g,y){const x=T.points;let A=0,h=-1;for(let w=0;w<3;w++){const{start:b,end:v}=f;b.copy(x[w]),v.copy(x[(w+1)%3]),f.delta(o);const B=Gt(g.distanceToPoint(b));if(Gt(g.normal.dot(o))&&B){y.copy(f),A=2;break}const M=g.intersectLine(f,d);if(!M&&B&&d.copy(b),(M||B)&&!Gt(d.distanceTo(v))){if(A<=1)(A===1?y.start:y.end).copy(d),B&&(h=A);else if(A>=2){(h===1?y.start:y.end).copy(d),A=2;break}if(A++,A===2&&h===-1)break}}return A}return function(g,y=null,x=!1){this.needsUpdate&&this.update(),g.isExtendedTriangle?g.needsUpdate&&g.update():(n.copy(g),n.update(),g=n);const A=this.plane,h=g.plane;if(Math.abs(A.normal.dot(h.normal))>1-1e-10){const w=this.satBounds,b=this.satAxes;e[0]=g.a,e[1]=g.b,e[2]=g.c;for(let M=0;M<4;M++){const _=w[M],C=b[M];if(s.setFromPoints(C,e),_.isSeparated(s))return!1}const v=g.satBounds,B=g.satAxes;t[0]=this.a,t[1]=this.b,t[2]=this.c;for(let M=0;M<4;M++){const _=v[M],C=B[M];if(s.setFromPoints(C,t),_.isSeparated(s))return!1}for(let M=0;M<4;M++){const _=b[M];for(let C=0;C<4;C++){const P=B[C];if(a.crossVectors(_,P),s.setFromPoints(a,t),i.setFromPoints(a,e),s.isSeparated(i))return!1}}return y&&(x||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),y.start.set(0,0,0),y.end.set(0,0,0)),!0}else{const w=m(this,h,u);if(w===1&&g.containsPoint(u.end))return y&&(y.start.copy(u.end),y.end.copy(u.end)),!0;if(w!==2)return!1;const b=m(g,A,l);if(b===1&&this.containsPoint(l.end))return y&&(y.start.copy(l.end),y.end.copy(l.end)),!0;if(b!==2)return!1;if(u.delta(c),l.delta(r),c.dot(r)<0){let S=l.start;l.start=l.end,l.end=S}const v=u.start.dot(c),B=u.end.dot(c),M=l.start.dot(c),_=l.end.dot(c),C=B<M,P=v<_;return v!==_&&M!==B&&C===P?!1:(y&&(p.subVectors(u.start,l.start),p.dot(c)>0?y.start.copy(u.start):y.start.copy(l.start),p.subVectors(u.end,l.end),p.dot(c)<0?y.end.copy(u.end):y.end.copy(l.end)),!0)}}}();X.prototype.distanceToPoint=function(){const n=new E;return function(e){return this.closestPointToPoint(e,n),e.distanceTo(n)}}();X.prototype.distanceToTriangle=function(){const n=new E,t=new E,e=["a","b","c"],s=new W,i=new W;return function(o,c=null,r=null){const p=c||r?s:null;if(this.intersectsTriangle(o,p))return(c||r)&&(c&&p.getCenter(c),r&&p.getCenter(r)),0;let f=1/0;for(let u=0;u<3;u++){let l;const d=e[u],m=o[d];this.closestPointToPoint(m,n),l=m.distanceToSquared(n),l<f&&(f=l,c&&c.copy(n),r&&r.copy(m));const T=this[d];o.closestPointToPoint(T,n),l=T.distanceToSquared(n),l<f&&(f=l,c&&c.copy(T),r&&r.copy(n))}for(let u=0;u<3;u++){const l=e[u],d=e[(u+1)%3];s.set(this[l],this[d]);for(let m=0;m<3;m++){const T=e[m],g=e[(m+1)%3];i.set(o[T],o[g]),Tn(s,i,n,t);const y=n.distanceToSquared(t);y<f&&(f=y,c&&c.copy(n),r&&r.copy(t))}}return Math.sqrt(f)}}();class I{constructor(t,e,s){this.isOrientedBox=!0,this.min=new E,this.max=new E,this.matrix=new tt,this.invMatrix=new tt,this.points=new Array(8).fill().map(()=>new E),this.satAxes=new Array(3).fill().map(()=>new E),this.satBounds=new Array(3).fill().map(()=>new K),this.alignedSatBounds=new Array(3).fill().map(()=>new K),this.needsUpdate=!1,t&&this.min.copy(t),e&&this.max.copy(e),s&&this.matrix.copy(s)}set(t,e,s){this.min.copy(t),this.max.copy(e),this.matrix.copy(s),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}I.prototype.update=function(){return function(){const t=this.matrix,e=this.min,s=this.max,i=this.points;for(let p=0;p<=1;p++)for(let f=0;f<=1;f++)for(let u=0;u<=1;u++){const l=1*p|2*f|4*u,d=i[l];d.x=p?s.x:e.x,d.y=f?s.y:e.y,d.z=u?s.z:e.z,d.applyMatrix4(t)}const a=this.satBounds,o=this.satAxes,c=i[0];for(let p=0;p<3;p++){const f=o[p],u=a[p],l=1<<p,d=i[l];f.subVectors(c,d),u.setFromPoints(f,i)}const r=this.alignedSatBounds;r[0].setFromPointsField(i,"x"),r[1].setFromPointsField(i,"y"),r[2].setFromPointsField(i,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();I.prototype.intersectsBox=function(){const n=new K;return function(e){this.needsUpdate&&this.update();const s=e.min,i=e.max,a=this.satBounds,o=this.satAxes,c=this.alignedSatBounds;if(n.min=s.x,n.max=i.x,c[0].isSeparated(n)||(n.min=s.y,n.max=i.y,c[1].isSeparated(n))||(n.min=s.z,n.max=i.z,c[2].isSeparated(n)))return!1;for(let r=0;r<3;r++){const p=o[r],f=a[r];if(n.setFromBox(p,e),f.isSeparated(n))return!1}return!0}}();I.prototype.intersectsTriangle=function(){const n=new X,t=new Array(3),e=new K,s=new K,i=new E;return function(o){this.needsUpdate&&this.update(),o.isExtendedTriangle?o.needsUpdate&&o.update():(n.copy(o),n.update(),o=n);const c=this.satBounds,r=this.satAxes;t[0]=o.a,t[1]=o.b,t[2]=o.c;for(let l=0;l<3;l++){const d=c[l],m=r[l];if(e.setFromPoints(m,t),d.isSeparated(e))return!1}const p=o.satBounds,f=o.satAxes,u=this.points;for(let l=0;l<3;l++){const d=p[l],m=f[l];if(e.setFromPoints(m,u),d.isSeparated(e))return!1}for(let l=0;l<3;l++){const d=r[l];for(let m=0;m<4;m++){const T=f[m];if(i.crossVectors(d,T),e.setFromPoints(i,t),s.setFromPoints(i,u),e.isSeparated(s))return!1}}return!0}}();I.prototype.closestPointToPoint=function(){return function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e}}();I.prototype.distanceToPoint=function(){const n=new E;return function(e){return this.closestPointToPoint(e,n),e.distanceTo(n)}}();I.prototype.distanceToBox=function(){const n=["x","y","z"],t=new Array(12).fill().map(()=>new W),e=new Array(12).fill().map(()=>new W),s=new E,i=new E;return function(o,c=0,r=null,p=null){if(this.needsUpdate&&this.update(),this.intersectsBox(o))return(r||p)&&(o.getCenter(i),this.closestPointToPoint(i,s),o.closestPointToPoint(s,i),r&&r.copy(s),p&&p.copy(i)),0;const f=c*c,u=o.min,l=o.max,d=this.points;let m=1/0;for(let g=0;g<8;g++){const y=d[g];i.copy(y).clamp(u,l);const x=y.distanceToSquared(i);if(x<m&&(m=x,r&&r.copy(y),p&&p.copy(i),x<f))return Math.sqrt(x)}let T=0;for(let g=0;g<3;g++)for(let y=0;y<=1;y++)for(let x=0;x<=1;x++){const A=(g+1)%3,h=(g+2)%3,w=y<<A|x<<h,b=1<<g|y<<A|x<<h,v=d[w],B=d[b];t[T].set(v,B);const _=n[g],C=n[A],P=n[h],S=e[T],L=S.start,$=S.end;L[_]=u[_],L[C]=y?u[C]:l[C],L[P]=x?u[P]:l[C],$[_]=l[_],$[C]=y?u[C]:l[C],$[P]=x?u[P]:l[C],T++}for(let g=0;g<=1;g++)for(let y=0;y<=1;y++)for(let x=0;x<=1;x++){i.x=g?l.x:u.x,i.y=y?l.y:u.y,i.z=x?l.z:u.z,this.closestPointToPoint(i,s);const A=i.distanceToSquared(s);if(A<m&&(m=A,r&&r.copy(s),p&&p.copy(i),A<f))return Math.sqrt(A)}for(let g=0;g<12;g++){const y=t[g];for(let x=0;x<12;x++){const A=e[x];Tn(y,A,s,i);const h=s.distanceToSquared(i);if(h<m&&(m=h,r&&r.copy(s),p&&p.copy(i),h<f))return Math.sqrt(h)}}return Math.sqrt(m)}}();class Bn{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return t.length===0?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}class Ze extends Bn{constructor(){super(()=>new X)}}const q=new Ze;function V(n,t){return t[n+15]===65535}function k(n,t){return t[n+6]}function H(n,t){return t[n+14]}function N(n){return n+8}function j(n,t){return t[n+6]}function se(n,t){return t[n+7]}class We{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const t=[];let e=null;this.setBuffer=s=>{e&&t.push(e),e=s,this.float32Array=new Float32Array(s),this.uint16Array=new Uint16Array(s),this.uint32Array=new Uint32Array(s)},this.clearBuffer=()=>{e=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,t.length!==0&&this.setBuffer(t.pop())}}}const z=new We;let G,pt;const et=[],Et=new Bn(()=>new Y);function Ke(n,t,e,s,i,a){G=Et.getPrimitive(),pt=Et.getPrimitive(),et.push(G,pt),z.setBuffer(n._roots[t]);const o=mn(0,n.geometry,e,s,i,a);z.clearBuffer(),Et.releasePrimitive(G),Et.releasePrimitive(pt),et.pop(),et.pop();const c=et.length;return c>0&&(pt=et[c-1],G=et[c-2]),o}function mn(n,t,e,s,i=null,a=0,o=0){const{float32Array:c,uint16Array:r,uint32Array:p}=z;let f=n*2;if(V(f,r)){const l=k(n,p),d=H(f,r);return U(n,c,G),s(l,d,!1,o,a+n,G)}else{let _=function(P){const{uint16Array:S,uint32Array:L}=z;let $=P*2;for(;!V($,S);)P=N(P),$=P*2;return k(P,L)},C=function(P){const{uint16Array:S,uint32Array:L}=z;let $=P*2;for(;!V($,S);)P=j(P,L),$=P*2;return k(P,L)+H($,S)};const l=N(n),d=j(n,p);let m=l,T=d,g,y,x,A;if(i&&(x=G,A=pt,U(m,c,x),U(T,c,A),g=i(x),y=i(A),y<g)){m=d,T=l;const P=g;g=y,y=P,x=A}x||(x=G,U(m,c,x));const h=V(m*2,r),w=e(x,h,g,o+1,a+m);let b;if(w===En){const P=_(m),L=C(m)-P;b=s(P,L,!0,o+1,a+m,x)}else b=w&&mn(m,t,e,s,i,a,o+1);if(b)return!0;A=pt,U(T,c,A);const v=V(T*2,r),B=e(A,v,y,o+1,a+T);let M;if(B===En){const P=_(T),L=C(T)-P;M=s(P,L,!0,o+1,a+T,A)}else M=B&&mn(T,t,e,s,i,a,o+1);return!!M}}const gt=new E,tn=new E;function Je(n,t,e={},s=0,i=1/0){const a=s*s,o=i*i;let c=1/0,r=null;if(n.shapecast({boundsTraverseOrder:f=>(gt.copy(t).clamp(f.min,f.max),gt.distanceToSquared(t)),intersectsBounds:(f,u,l)=>l<c&&l<o,intersectsTriangle:(f,u)=>{f.closestPointToPoint(t,gt);const l=t.distanceToSquared(gt);return l<c&&(tn.copy(gt),c=l,r=u),l<a}}),c===1/0)return null;const p=Math.sqrt(c);return e.point?e.point.copy(tn):e.point=tn.clone(),e.distance=p,e.faceIndex=r,e}const st=new E,it=new E,rt=new E,Lt=new dt,Ft=new dt,$t=new dt,Un=new E,Rn=new E,Dn=new E,zt=new E;function Qe(n,t,e,s,i,a){let o;return a===de?o=n.intersectTriangle(s,e,t,!0,i):o=n.intersectTriangle(t,e,s,a!==ye,i),o===null?null:{distance:n.origin.distanceTo(i),point:i.clone()}}function Ge(n,t,e,s,i,a,o,c,r){st.fromBufferAttribute(t,a),it.fromBufferAttribute(t,o),rt.fromBufferAttribute(t,c);const p=Qe(n,st,it,rt,zt,r);if(p){s&&(Lt.fromBufferAttribute(s,a),Ft.fromBufferAttribute(s,o),$t.fromBufferAttribute(s,c),p.uv=vt.getInterpolation(zt,st,it,rt,Lt,Ft,$t,new dt)),i&&(Lt.fromBufferAttribute(i,a),Ft.fromBufferAttribute(i,o),$t.fromBufferAttribute(i,c),p.uv1=vt.getInterpolation(zt,st,it,rt,Lt,Ft,$t,new dt)),e&&(Un.fromBufferAttribute(e,a),Rn.fromBufferAttribute(e,o),Dn.fromBufferAttribute(e,c),p.normal=vt.getInterpolation(zt,st,it,rt,Un,Rn,Dn,new E),p.normal.dot(n.direction)>0&&p.normal.multiplyScalar(-1));const f={a,b:o,c,normal:new E,materialIndex:0};vt.getNormal(st,it,rt,f.normal),p.face=f,p.faceIndex=a}return p}function Xt(n,t,e,s,i){const a=s*3;let o=a+0,c=a+1,r=a+2;const p=n.index;n.index&&(o=p.getX(o),c=p.getX(c),r=p.getX(r));const{position:f,normal:u,uv:l,uv1:d}=n.attributes,m=Ge(e,f,u,l,d,o,c,r,t);return m?(m.faceIndex=s,i&&i.push(m),m):null}function D(n,t,e,s){const i=n.a,a=n.b,o=n.c;let c=t,r=t+1,p=t+2;e&&(c=e.getX(c),r=e.getX(r),p=e.getX(p)),i.x=s.getX(c),i.y=s.getY(c),i.z=s.getZ(c),a.x=s.getX(r),a.y=s.getY(r),a.z=s.getZ(r),o.x=s.getX(p),o.y=s.getY(p),o.z=s.getZ(p)}function ts(n,t,e,s,i,a){const{geometry:o,_indirectBuffer:c}=n;for(let r=s,p=s+i;r<p;r++)Xt(o,t,e,r,a)}function ns(n,t,e,s,i){const{geometry:a,_indirectBuffer:o}=n;let c=1/0,r=null;for(let p=s,f=s+i;p<f;p++){let u;u=Xt(a,t,e,p),u&&u.distance<c&&(r=u,c=u.distance)}return r}function es(n,t,e,s,i,a,o){const{geometry:c}=e,{index:r}=c,p=c.attributes.position;for(let f=n,u=t+n;f<u;f++){let l;if(l=f,D(o,l*3,r,p),o.needsUpdate=!0,s(o,l,i,a))return!0}return!1}function ss(n,t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=n.geometry,s=e.index?e.index.array:null,i=e.attributes.position;let a,o,c,r,p=0;const f=n._roots;for(let l=0,d=f.length;l<d;l++)a=f[l],o=new Uint32Array(a),c=new Uint16Array(a),r=new Float32Array(a),u(0,p),p+=a.byteLength;function u(l,d,m=!1){const T=l*2;if(c[T+15]===Ot){const y=o[l+6],x=c[T+14];let A=1/0,h=1/0,w=1/0,b=-1/0,v=-1/0,B=-1/0;for(let M=3*y,_=3*(y+x);M<_;M++){let C=s[M];const P=i.getX(C),S=i.getY(C),L=i.getZ(C);P<A&&(A=P),P>b&&(b=P),S<h&&(h=S),S>v&&(v=S),L<w&&(w=L),L>B&&(B=L)}return r[l+0]!==A||r[l+1]!==h||r[l+2]!==w||r[l+3]!==b||r[l+4]!==v||r[l+5]!==B?(r[l+0]=A,r[l+1]=h,r[l+2]=w,r[l+3]=b,r[l+4]=v,r[l+5]=B,!0):!1}else{const y=l+8,x=o[l+6],A=y+d,h=x+d;let w=m,b=!1,v=!1;t?w||(b=t.has(A),v=t.has(h),w=!b&&!v):(b=!0,v=!0);const B=w||b,M=w||v;let _=!1;B&&(_=u(y,d,w));let C=!1;M&&(C=u(x,d,w));const P=_||C;if(P)for(let S=0;S<3;S++){const L=y+S,$=x+S,R=r[L],mt=r[L+3],ht=r[$],xt=r[$+3];r[l+S]=R<ht?R:ht,r[l+S+3]=mt>xt?mt:xt}return P}}}const In=new Y;function nt(n,t,e,s){return U(n,t,In),e.intersectBox(In,s)}function is(n,t,e,s,i,a){const{geometry:o,_indirectBuffer:c}=n;for(let r=s,p=s+i;r<p;r++){let f=c?c[r]:r;Xt(o,t,e,f,a)}}function rs(n,t,e,s,i){const{geometry:a,_indirectBuffer:o}=n;let c=1/0,r=null;for(let p=s,f=s+i;p<f;p++){let u;u=Xt(a,t,e,o?o[p]:p),u&&u.distance<c&&(r=u,c=u.distance)}return r}function os(n,t,e,s,i,a,o){const{geometry:c}=e,{index:r}=c,p=c.attributes.position;for(let f=n,u=t+n;f<u;f++){let l;if(l=e.resolveTriangleIndex(f),D(o,l*3,r,p),o.needsUpdate=!0,s(o,l,i,a))return!0}return!1}const Vn=new E;function cs(n,t,e,s,i){z.setBuffer(n._roots[t]),hn(0,n,e,s,i),z.clearBuffer()}function hn(n,t,e,s,i){const{float32Array:a,uint16Array:o,uint32Array:c}=z,r=n*2;if(V(r,o)){const f=k(n,c),u=H(r,o);ts(t,e,s,f,u,i)}else{const f=N(n);nt(f,a,s,Vn)&&hn(f,t,e,s,i);const u=j(n,c);nt(u,a,s,Vn)&&hn(u,t,e,s,i)}}const kn=new E,as=["x","y","z"];function ls(n,t,e,s){z.setBuffer(n._roots[t]);const i=xn(0,n,e,s);return z.clearBuffer(),i}function xn(n,t,e,s){const{float32Array:i,uint16Array:a,uint32Array:o}=z;let c=n*2;if(V(c,a)){const p=k(n,o),f=H(c,a);return ns(t,e,s,p,f)}else{const p=se(n,o),f=as[p],l=s.direction[f]>=0;let d,m;l?(d=N(n),m=j(n,o)):(d=j(n,o),m=N(n));const g=nt(d,i,s,kn)?xn(d,t,e,s):null;if(g){const A=g.point[f];if(l?A<=i[m+p]:A>=i[m+p+3])return g}const x=nt(m,i,s,kn)?xn(m,t,e,s):null;return g&&x?g.distance<=x.distance?g:x:g||x||null}}const Ut=new Y,ot=new X,ct=new X,bt=new tt,qn=new I,Rt=new I;function fs(n,t,e,s){z.setBuffer(n._roots[t]);const i=wn(0,n,e,s);return z.clearBuffer(),i}function wn(n,t,e,s,i=null){const{float32Array:a,uint16Array:o,uint32Array:c}=z;let r=n*2;if(i===null&&(e.boundingBox||e.computeBoundingBox(),qn.set(e.boundingBox.min,e.boundingBox.max,s),i=qn),V(r,o)){const f=t.geometry,u=f.index,l=f.attributes.position,d=e.index,m=e.attributes.position,T=k(n,c),g=H(r,o);if(bt.copy(s).invert(),e.boundsTree)return U(n,a,Rt),Rt.matrix.copy(bt),Rt.needsUpdate=!0,e.boundsTree.shapecast({intersectsBounds:x=>Rt.intersectsBox(x),intersectsTriangle:x=>{x.a.applyMatrix4(s),x.b.applyMatrix4(s),x.c.applyMatrix4(s),x.needsUpdate=!0;for(let A=T*3,h=(g+T)*3;A<h;A+=3)if(D(ct,A,u,l),ct.needsUpdate=!0,x.intersectsTriangle(ct))return!0;return!1}});for(let y=T*3,x=(g+T)*3;y<x;y+=3){D(ot,y,u,l),ot.a.applyMatrix4(bt),ot.b.applyMatrix4(bt),ot.c.applyMatrix4(bt),ot.needsUpdate=!0;for(let A=0,h=d.count;A<h;A+=3)if(D(ct,A,d,m),ct.needsUpdate=!0,ot.intersectsTriangle(ct))return!0}}else{const f=n+8,u=c[n+6];return U(f,a,Ut),!!(i.intersectsBox(Ut)&&wn(f,t,e,s,i)||(U(u,a,Ut),i.intersectsBox(Ut)&&wn(u,t,e,s,i)))}}const Dt=new tt,nn=new I,Tt=new I,us=new E,ps=new E,ds=new E,ys=new E;function ms(n,t,e,s={},i={},a=0,o=1/0){t.boundingBox||t.computeBoundingBox(),nn.set(t.boundingBox.min,t.boundingBox.max,e),nn.needsUpdate=!0;const c=n.geometry,r=c.attributes.position,p=c.index,f=t.attributes.position,u=t.index,l=q.getPrimitive(),d=q.getPrimitive();let m=us,T=ps,g=null,y=null;i&&(g=ds,y=ys);let x=1/0,A=null,h=null;return Dt.copy(e).invert(),Tt.matrix.copy(Dt),n.shapecast({boundsTraverseOrder:w=>nn.distanceToBox(w),intersectsBounds:(w,b,v)=>v<x&&v<o?(b&&(Tt.min.copy(w.min),Tt.max.copy(w.max),Tt.needsUpdate=!0),!0):!1,intersectsRange:(w,b)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:B=>Tt.distanceToBox(B),intersectsBounds:(B,M,_)=>_<x&&_<o,intersectsRange:(B,M)=>{for(let _=B,C=B+M;_<C;_++){D(d,3*_,u,f),d.a.applyMatrix4(e),d.b.applyMatrix4(e),d.c.applyMatrix4(e),d.needsUpdate=!0;for(let P=w,S=w+b;P<S;P++){D(l,3*P,p,r),l.needsUpdate=!0;const L=l.distanceToTriangle(d,m,g);if(L<x&&(T.copy(m),y&&y.copy(g),x=L,A=P,h=_),L<a)return!0}}}});{const v=yt(t);for(let B=0,M=v;B<M;B++){D(d,3*B,u,f),d.a.applyMatrix4(e),d.b.applyMatrix4(e),d.c.applyMatrix4(e),d.needsUpdate=!0;for(let _=w,C=w+b;_<C;_++){D(l,3*_,p,r),l.needsUpdate=!0;const P=l.distanceToTriangle(d,m,g);if(P<x&&(T.copy(m),y&&y.copy(g),x=P,A=_,h=B),P<a)return!0}}}}}),q.releasePrimitive(l),q.releasePrimitive(d),x===1/0?null:(s.point?s.point.copy(T):s.point=T.clone(),s.distance=x,s.faceIndex=A,i&&(i.point?i.point.copy(y):i.point=y.clone(),i.point.applyMatrix4(Dt),T.applyMatrix4(Dt),i.distance=T.sub(i.point).length(),i.faceIndex=h),s)}function hs(n,t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=n.geometry,s=e.index?e.index.array:null,i=e.attributes.position;let a,o,c,r,p=0;const f=n._roots;for(let l=0,d=f.length;l<d;l++)a=f[l],o=new Uint32Array(a),c=new Uint16Array(a),r=new Float32Array(a),u(0,p),p+=a.byteLength;function u(l,d,m=!1){const T=l*2;if(c[T+15]===Ot){const y=o[l+6],x=c[T+14];let A=1/0,h=1/0,w=1/0,b=-1/0,v=-1/0,B=-1/0;for(let M=y,_=y+x;M<_;M++){const C=3*n.resolveTriangleIndex(M);for(let P=0;P<3;P++){let S=C+P;S=s?s[S]:S;const L=i.getX(S),$=i.getY(S),R=i.getZ(S);L<A&&(A=L),L>b&&(b=L),$<h&&(h=$),$>v&&(v=$),R<w&&(w=R),R>B&&(B=R)}}return r[l+0]!==A||r[l+1]!==h||r[l+2]!==w||r[l+3]!==b||r[l+4]!==v||r[l+5]!==B?(r[l+0]=A,r[l+1]=h,r[l+2]=w,r[l+3]=b,r[l+4]=v,r[l+5]=B,!0):!1}else{const y=l+8,x=o[l+6],A=y+d,h=x+d;let w=m,b=!1,v=!1;t?w||(b=t.has(A),v=t.has(h),w=!b&&!v):(b=!0,v=!0);const B=w||b,M=w||v;let _=!1;B&&(_=u(y,d,w));let C=!1;M&&(C=u(x,d,w));const P=_||C;if(P)for(let S=0;S<3;S++){const L=y+S,$=x+S,R=r[L],mt=r[L+3],ht=r[$],xt=r[$+3];r[l+S]=R<ht?R:ht,r[l+S+3]=mt>xt?mt:xt}return P}}}const Hn=new E;function xs(n,t,e,s,i){z.setBuffer(n._roots[t]),An(0,n,e,s,i),z.clearBuffer()}function An(n,t,e,s,i){const{float32Array:a,uint16Array:o,uint32Array:c}=z,r=n*2;if(V(r,o)){const f=k(n,c),u=H(r,o);is(t,e,s,f,u,i)}else{const f=N(n);nt(f,a,s,Hn)&&An(f,t,e,s,i);const u=j(n,c);nt(u,a,s,Hn)&&An(u,t,e,s,i)}}const Nn=new E,ws=["x","y","z"];function As(n,t,e,s){z.setBuffer(n._roots[t]);const i=gn(0,n,e,s);return z.clearBuffer(),i}function gn(n,t,e,s){const{float32Array:i,uint16Array:a,uint32Array:o}=z;let c=n*2;if(V(c,a)){const p=k(n,o),f=H(c,a);return rs(t,e,s,p,f)}else{const p=se(n,o),f=ws[p],l=s.direction[f]>=0;let d,m;l?(d=N(n),m=j(n,o)):(d=j(n,o),m=N(n));const g=nt(d,i,s,Nn)?gn(d,t,e,s):null;if(g){const A=g.point[f];if(l?A<=i[m+p]:A>=i[m+p+3])return g}const x=nt(m,i,s,Nn)?gn(m,t,e,s):null;return g&&x?g.distance<=x.distance?g:x:g||x||null}}const It=new Y,at=new X,lt=new X,Bt=new tt,jn=new I,Vt=new I;function gs(n,t,e,s){z.setBuffer(n._roots[t]);const i=bn(0,n,e,s);return z.clearBuffer(),i}function bn(n,t,e,s,i=null){const{float32Array:a,uint16Array:o,uint32Array:c}=z;let r=n*2;if(i===null&&(e.boundingBox||e.computeBoundingBox(),jn.set(e.boundingBox.min,e.boundingBox.max,s),i=jn),V(r,o)){const f=t.geometry,u=f.index,l=f.attributes.position,d=e.index,m=e.attributes.position,T=k(n,c),g=H(r,o);if(Bt.copy(s).invert(),e.boundsTree)return U(n,a,Vt),Vt.matrix.copy(Bt),Vt.needsUpdate=!0,e.boundsTree.shapecast({intersectsBounds:x=>Vt.intersectsBox(x),intersectsTriangle:x=>{x.a.applyMatrix4(s),x.b.applyMatrix4(s),x.c.applyMatrix4(s),x.needsUpdate=!0;for(let A=T,h=g+T;A<h;A++)if(D(lt,3*t.resolveTriangleIndex(A),u,l),lt.needsUpdate=!0,x.intersectsTriangle(lt))return!0;return!1}});for(let y=T,x=g+T;y<x;y++){const A=t.resolveTriangleIndex(y);D(at,3*A,u,l),at.a.applyMatrix4(Bt),at.b.applyMatrix4(Bt),at.c.applyMatrix4(Bt),at.needsUpdate=!0;for(let h=0,w=d.count;h<w;h+=3)if(D(lt,h,d,m),lt.needsUpdate=!0,at.intersectsTriangle(lt))return!0}}else{const f=n+8,u=c[n+6];return U(f,a,It),!!(i.intersectsBox(It)&&bn(f,t,e,s,i)||(U(u,a,It),i.intersectsBox(It)&&bn(u,t,e,s,i)))}}const kt=new tt,en=new I,Pt=new I,bs=new E,Ts=new E,Bs=new E,Ps=new E;function vs(n,t,e,s={},i={},a=0,o=1/0){t.boundingBox||t.computeBoundingBox(),en.set(t.boundingBox.min,t.boundingBox.max,e),en.needsUpdate=!0;const c=n.geometry,r=c.attributes.position,p=c.index,f=t.attributes.position,u=t.index,l=q.getPrimitive(),d=q.getPrimitive();let m=bs,T=Ts,g=null,y=null;i&&(g=Bs,y=Ps);let x=1/0,A=null,h=null;return kt.copy(e).invert(),Pt.matrix.copy(kt),n.shapecast({boundsTraverseOrder:w=>en.distanceToBox(w),intersectsBounds:(w,b,v)=>v<x&&v<o?(b&&(Pt.min.copy(w.min),Pt.max.copy(w.max),Pt.needsUpdate=!0),!0):!1,intersectsRange:(w,b)=>{if(t.boundsTree){const v=t.boundsTree;return v.shapecast({boundsTraverseOrder:B=>Pt.distanceToBox(B),intersectsBounds:(B,M,_)=>_<x&&_<o,intersectsRange:(B,M)=>{for(let _=B,C=B+M;_<C;_++){const P=v.resolveTriangleIndex(_);D(d,3*P,u,f),d.a.applyMatrix4(e),d.b.applyMatrix4(e),d.c.applyMatrix4(e),d.needsUpdate=!0;for(let S=w,L=w+b;S<L;S++){const $=n.resolveTriangleIndex(S);D(l,3*$,p,r),l.needsUpdate=!0;const R=l.distanceToTriangle(d,m,g);if(R<x&&(T.copy(m),y&&y.copy(g),x=R,A=S,h=_),R<a)return!0}}}})}else{const v=yt(t);for(let B=0,M=v;B<M;B++){D(d,3*B,u,f),d.a.applyMatrix4(e),d.b.applyMatrix4(e),d.c.applyMatrix4(e),d.needsUpdate=!0;for(let _=w,C=w+b;_<C;_++){const P=n.resolveTriangleIndex(_);D(l,3*P,p,r),l.needsUpdate=!0;const S=l.distanceToTriangle(d,m,g);if(S<x&&(T.copy(m),y&&y.copy(g),x=S,A=_,h=B),S<a)return!0}}}}}),q.releasePrimitive(l),q.releasePrimitive(d),x===1/0?null:(s.point?s.point.copy(T):s.point=T.clone(),s.distance=x,s.faceIndex=A,i&&(i.point?i.point.copy(y):i.point=y.clone(),i.point.applyMatrix4(kt),T.applyMatrix4(kt),i.distance=T.sub(i.point).length(),i.faceIndex=h),s)}function Ms(){return typeof SharedArrayBuffer<"u"}const Mt=new z.constructor,jt=new z.constructor,Q=new Bn(()=>new Y),ft=new Y,ut=new Y,sn=new Y,rn=new Y;let on=!1;function _s(n,t,e,s){if(on)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");on=!0;const i=n._roots,a=t._roots;let o,c=0,r=0;const p=new tt().copy(e).invert();for(let f=0,u=i.length;f<u;f++){Mt.setBuffer(i[f]),r=0;const l=Q.getPrimitive();U(0,Mt.float32Array,l),l.applyMatrix4(p);for(let d=0,m=a.length;d<m&&(jt.setBuffer(a[f]),o=O(0,0,e,p,s,c,r,0,0,l),jt.clearBuffer(),r+=a[d].length,!o);d++);if(Q.releasePrimitive(l),Mt.clearBuffer(),c+=i[f].length,o)break}return on=!1,o}function O(n,t,e,s,i,a=0,o=0,c=0,r=0,p=null,f=!1){let u,l;f?(u=jt,l=Mt):(u=Mt,l=jt);const d=u.float32Array,m=u.uint32Array,T=u.uint16Array,g=l.float32Array,y=l.uint32Array,x=l.uint16Array,A=n*2,h=t*2,w=V(A,T),b=V(h,x);let v=!1;if(b&&w)f?v=i(k(t,y),H(t*2,x),k(n,m),H(n*2,T),r,o+t,c,a+n):v=i(k(n,m),H(n*2,T),k(t,y),H(t*2,x),c,a+n,r,o+t);else if(b){const B=Q.getPrimitive();U(t,g,B),B.applyMatrix4(e);const M=N(n),_=j(n,m);U(M,d,ft),U(_,d,ut);const C=B.intersectsBox(ft),P=B.intersectsBox(ut);v=C&&O(t,M,s,e,i,o,a,r,c+1,B,!f)||P&&O(t,_,s,e,i,o,a,r,c+1,B,!f),Q.releasePrimitive(B)}else{const B=N(t),M=j(t,y);U(B,g,sn),U(M,g,rn);const _=p.intersectsBox(sn),C=p.intersectsBox(rn);if(_&&C)v=O(n,B,e,s,i,a,o,c,r+1,p,f)||O(n,M,e,s,i,a,o,c,r+1,p,f);else if(_)if(w)v=O(n,B,e,s,i,a,o,c,r+1,p,f);else{const P=Q.getPrimitive();P.copy(sn).applyMatrix4(e);const S=N(n),L=j(n,m);U(S,d,ft),U(L,d,ut);const $=P.intersectsBox(ft),R=P.intersectsBox(ut);v=$&&O(B,S,s,e,i,o,a,r,c+1,P,!f)||R&&O(B,L,s,e,i,o,a,r,c+1,P,!f),Q.releasePrimitive(P)}else if(C)if(w)v=O(n,M,e,s,i,a,o,c,r+1,p,f);else{const P=Q.getPrimitive();P.copy(rn).applyMatrix4(e);const S=N(n),L=j(n,m);U(S,d,ft),U(L,d,ut);const $=P.intersectsBox(ft),R=P.intersectsBox(ut);v=$&&O(M,S,s,e,i,o,a,r,c+1,P,!f)||R&&O(M,L,s,e,i,o,a,r,c+1,P,!f),Q.releasePrimitive(P)}}return v}const qt=new I,On=new Y;class Pn{static serialize(t,e={}){e={cloneBuffers:!0,...e};const s=t.geometry,i=t._roots,a=t._indirectBuffer,o=s.getIndex();let c;return e.cloneBuffers?c={roots:i.map(r=>r.slice()),index:o.array.slice(),indirectBuffer:a?a.slice():null}:c={roots:i,index:o.array,indirectBuffer:a},c}static deserialize(t,e,s={}){s={setIndex:!0,indirect:!!t.indirectBuffer,...s};const{index:i,roots:a,indirectBuffer:o}=t,c=new Pn(e,{...s,[Jt]:!0});if(c._roots=a,c._indirectBuffer=o||null,s.setIndex){const r=e.getIndex();if(r===null){const p=new Qn(t.index,1,!1);e.setIndex(p)}else r.array!==i&&(r.array.set(i),r.needsUpdate=!0)}return c}get indirect(){return!!this._indirectBuffer}constructor(t,e={}){if(t.isBufferGeometry){if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(e=Object.assign({strategy:te,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,[Jt]:!1},e),e.useSharedArrayBuffer&&!Ms())throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=t,this._roots=null,this._indirectBuffer=null,e[Jt]||(je(this,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new Y)));const{_indirectBuffer:s}=this;this.resolveTriangleIndex=e.indirect?i=>s[i]:i=>i}refit(t=null){return(this.indirect?hs:ss)(this,t)}traverse(t,e=0){const s=this._roots[e],i=new Uint32Array(s),a=new Uint16Array(s);o(0);function o(c,r=0){const p=c*2,f=a[p+15]===Ot;if(f){const u=i[c+6],l=a[p+14];t(r,f,new Float32Array(s,c*4,6),u,l)}else{const u=c+Nt/4,l=i[c+6],d=i[c+7];t(r,f,new Float32Array(s,c*4,6),d)||(o(u,r+1),o(l,r+1))}}}raycast(t,e=Sn){const s=this._roots,i=this.geometry,a=[],o=e.isMaterial,c=Array.isArray(e),r=i.groups,p=o?e.side:e,f=this.indirect?xs:cs;for(let u=0,l=s.length;u<l;u++){const d=c?e[r[u].materialIndex].side:p,m=a.length;if(f(this,u,d,t,a),c){const T=r[u].materialIndex;for(let g=m,y=a.length;g<y;g++)a[g].face.materialIndex=T}}return a}raycastFirst(t,e=Sn){const s=this._roots,i=this.geometry,a=e.isMaterial,o=Array.isArray(e);let c=null;const r=i.groups,p=a?e.side:e,f=this.indirect?As:ls;for(let u=0,l=s.length;u<l;u++){const d=o?e[r[u].materialIndex].side:p,m=f(this,u,d,t);m!=null&&(c==null||m.distance<c.distance)&&(c=m,o&&(m.face.materialIndex=r[u].materialIndex))}return c}intersectsGeometry(t,e){let s=!1;const i=this._roots,a=this.indirect?gs:fs;for(let o=0,c=i.length;o<c&&(s=a(this,o,t,e),!s);o++);return s}shapecast(t){const e=q.getPrimitive(),s=this.indirect?os:es;let{boundsTraverseOrder:i,intersectsBounds:a,intersectsRange:o,intersectsTriangle:c}=t;if(o&&c){const u=o;o=(l,d,m,T,g)=>u(l,d,m,T,g)?!0:s(l,d,this,c,m,T,e)}else o||(c?o=(u,l,d,m)=>s(u,l,this,c,d,m,e):o=(u,l,d)=>d);let r=!1,p=0;const f=this._roots;for(let u=0,l=f.length;u<l;u++){const d=f[u];if(r=Ke(this,u,a,o,i,p),r)break;p+=d.byteLength}return q.releasePrimitive(e),r}bvhcast(t,e,s){let{intersectsRanges:i,intersectsTriangles:a}=s;const o=q.getPrimitive(),c=this.geometry.index,r=this.geometry.attributes.position,p=this.indirect?m=>{const T=this.resolveTriangleIndex(m);D(o,T*3,c,r)}:m=>{D(o,m*3,c,r)},f=q.getPrimitive(),u=t.geometry.index,l=t.geometry.attributes.position,d=t.indirect?m=>{const T=t.resolveTriangleIndex(m);D(f,T*3,u,l)}:m=>{D(f,m*3,u,l)};if(a){const m=(T,g,y,x,A,h,w,b)=>{for(let v=y,B=y+x;v<B;v++){d(v),f.a.applyMatrix4(e),f.b.applyMatrix4(e),f.c.applyMatrix4(e),f.needsUpdate=!0;for(let M=T,_=T+g;M<_;M++)if(p(M),o.needsUpdate=!0,a(o,f,M,v,A,h,w,b))return!0}return!1};if(i){const T=i;i=function(g,y,x,A,h,w,b,v){return T(g,y,x,A,h,w,b,v)?!0:m(g,y,x,A,h,w,b,v)}}else i=m}return _s(this,t,e,i)}intersectsBox(t,e){return qt.set(t.min,t.max,e),qt.needsUpdate=!0,this.shapecast({intersectsBounds:s=>qt.intersectsBox(s),intersectsTriangle:s=>qt.intersectsTriangle(s)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,s={},i={},a=0,o=1/0){return(this.indirect?vs:ms)(this,t,e,s,i,a,o)}closestPointToPoint(t,e={},s=0,i=1/0){return Je(this,t,e,s,i)}getBoundingBox(t){return t.makeEmpty(),this._roots.forEach(s=>{U(0,new Float32Array(s),On),t.union(On)}),t}}function Xn(n,t,e){return n===null||(n.point.applyMatrix4(t.matrixWorld),n.distance=n.point.distanceTo(e.ray.origin),n.object=t,n.distance<e.near||n.distance>e.far)?null:n}const cn=new me,Yn=new tt,Ss=Ht.prototype.raycast;function Zn(n,t){if(this.geometry.boundsTree){if(this.material===void 0)return;Yn.copy(this.matrixWorld).invert(),cn.copy(n.ray).applyMatrix4(Yn);const e=this.geometry.boundsTree;if(n.firstHitOnly===!0){const s=Xn(e.raycastFirst(cn,this.material),this,n);s&&t.push(s)}else{const s=e.raycast(cn,this.material);for(let i=0,a=s.length;i<a;i++){const o=Xn(s[i],this,n);o&&t.push(o)}}}else Ss.call(this,n,t)}function Cs(n){return this.boundsTree=new Pn(this,n),this.boundsTree}function Es(){this.boundsTree=null}const Ls=(n={})=>{const{computeBoundsTree:t,disposeBoundsTree:e}=wt.prototype,{raycast:s}=Wt.prototype,{raycast:i}=Ht.prototype;return Wt.prototype.raycast=Zn,Ht.prototype.raycast=Zn,Cn.prototype.firstHitOnly=n.firstHitOnly??!0,wt.prototype.computeBoundsTree=function(c){return Cs.call(this,c??n)},wt.prototype.disposeBoundsTree=Es,()=>{wt.prototype.computeBoundsTree=t,wt.prototype.disposeBoundsTree=e,Wt.prototype.raycast=s,Ht.prototype.raycast=i,delete Cn.prototype.firstHitOnly}},Fs=n=>{F.interactiveMap[n.uuid]===void 0&&(F.interactiveObjects.push(n),F.interactiveMap[n.uuid]=n)},$s=n=>{const t=F.interactiveObjects.indexOf(n);F.interactiveObjects.splice(t,1),delete F.interactiveMap[n.uuid]},zs=()=>{const n=he(e=>Fs(e)),t=xe(e=>$s(e));return()=>{n(),t()}},vn=n=>`${(n.eventObject||n.object).uuid}/${n.index}${n.instanceId}`,Wn=[["click",!1],["contextmenu",!1],["dblclick",!1],["wheel",!1],["pointerdown",!0],["pointerup",!0],["pointerleave",!0],["pointerenter",!0],["pointermove",!0],["pointercancel",!0]],Us=n=>{const t=n.offsetX-(F.initialClick[0]??0),e=n.offsetY-(F.initialClick[1]??0);return Math.round(Math.hypot(t,e))},an=n=>{F.hovered.forEach(t=>{if(n.length===0||!n.some(e=>e.object===t.object&&e.index===t.index&&e.instanceId===t.instanceId)){const{eventObject:e}=t;F.hovered.delete(vn(t)),e.dispatchEvent({type:"pointerout",...t,intersections:n}),e.dispatchEvent({type:"pointerleave",...t,intersections:n})}})},Rs=()=>{const n=new Set,t=[];let e=F.raycaster.intersectObjects(F.interactiveObjects).sort((s,i)=>s.distance-i.distance).filter(s=>{const i=vn(s);return n.has(i)?!1:(n.add(i),!0)});return F.filter&&(e=F.filter(e,F)),e.forEach(s=>{let i=s.object;for(;i;)t.push({...s,eventObject:i}),i=i.parent}),t},Kn=(n,t)=>{t.forEach(e=>{e.dispatchEvent({type:"pointermissed",event:n})})},Jn=n=>n==="pointerleave"||n==="pointercancel"?()=>{F.pointerOverTarget=!1,an([])}:n==="pointerenter"?()=>{F.pointerOverTarget=!0}:t=>{const e=n==="pointermove",s=n==="click"||n==="contextmenu"||n==="dblclick";F.compute(t,F);const i=F.enabled?Rs():[],a=s?Us(t):0;n==="pointerdown"&&(F.initialClick=[t.offsetX,t.offsetY],F.initialHits=i.map(r=>r.eventObject)),s&&i.length===0&&a<=2&&Kn(t,F.interactiveObjects),e&&an(i);let o=!1;const c=()=>{o=!0};for(let r=0,p=i.length;r<p;r+=1){const f=i[r],u={stopped:o,...f,intersections:i,stopPropagation(){c(),u.stopped=!0;const l=[...F.hovered.values()];if(F.hovered.size>0&&l.some(d=>d.eventObject===f.eventObject)){const d=i.slice(0,i.indexOf(f));an([...d,f])}},camera:F.raycaster.camera,delta:a,nativeEvent:t,pointer:F.pointer,ray:F.raycaster.ray};if(e){const l=vn(u),d=F.hovered.get(l);d?d.stopped&&u.stopPropagation():(F.hovered.set(l,u),f.eventObject.dispatchEvent({type:"pointerover",...u}),f.eventObject.dispatchEvent({type:"pointerenter",...u})),f.eventObject.dispatchEvent({type:"pointermove",...u})}else(!s||F.initialHits.includes(f.eventObject))&&(Kn(t,F.interactiveObjects.filter(l=>!F.initialHits.includes(l))),f.eventObject.dispatchEvent({type:n,...u}));if(o)break}},Ds=()=>(Wn.forEach(([n,t])=>{F.target.addEventListener(n,Jn(n),{passive:t})}),()=>{Wn.forEach(([n])=>{F.target.removeEventListener(n,Jn(n))})}),Is=n=>{F.camera=n.camera,F.enabled=n.enabled??!0,F.target=n.target,F.filter=n.filter,F.compute=n.compute??Me();const t=zs(),e=Ds();return{context:F,dispose:()=>{t(),e()}}},Vs=n=>{const t=2*Math.PI*Math.random();return[n*Math.cos(t),n*Math.sin(t)]},ks=n=>{n.traverse(t=>{const e="isMesh"in t,s="isLight"in t&&!("isAmbientLight"in t)&&!("isRectAreaLight"in t);t.castShadow=e||s,t.receiveShadow=e})},qs=`
import * as THREE from 'three'
import { pointerEvents, useBvhRaycast } from 'trzy'

// Optionally install three-mesh-bvh
useBvhRaycast({ firstHitOnly: true })

pointerEvents({ target: canvas, camera })

const mesh = new THREE.Mesh(
  new THREE.BoxGeometry(),
  new THREE.MeshStandardMaterial()
)

// If using three-mesh-bvh
mesh.geometry.computeBoundsTree()

mesh.addEventListener('pointerenter', (event) => console.log(event))
mesh.addEventListener('pointerleave', (event) => console.log(event))
mesh.addEventListener('click', (event) => console.log(event))

mesh.addEventListener('pointerenter', (event) => {
  // Call stop propagation to stop events from firing on other intersections.
  event.stopPropagation()
})
`;function Hs(n){let t,e="Adds pointer events to all rendererable objects.",s,i,a,o,c;return i=new Be({}),o=new ve({props:{code:qs}}),{c(){t=le("p"),t.textContent=e,s=Mn(),ln(i.$$.fragment),a=Mn(),ln(o.$$.fragment)},l(r){t=fe(r,"P",{"data-svelte-h":!0}),ue(t)!=="svelte-1y787p9"&&(t.textContent=e),s=_n(r),fn(i.$$.fragment,r),a=_n(r),fn(o.$$.fragment,r)},m(r,p){Yt(r,t,p),Yt(r,s,p),un(i,r,p),Yt(r,a,p),un(o,r,p),c=!0},p:oe,i(r){c||(pn(i.$$.fragment,r),pn(o.$$.fragment,r),c=!0)},o(r){dn(i.$$.fragment,r),dn(o.$$.fragment,r),c=!1},d(r){r&&(Zt(t),Zt(s),Zt(a)),yn(i,r),yn(o,r)}}}function Ns(n){let t,e;return t=new Pe({props:{title:"pointerEvents",$$slots:{default:[Hs]},$$scope:{ctx:n}}}),{c(){ln(t.$$.fragment)},l(s){fn(t.$$.fragment,s)},m(s,i){un(t,s,i),e=!0},p(s,[i]){const a={};i&1&&(a.$$scope={dirty:i,ctx:s}),t.$set(a)},i(s){e||(pn(t.$$.fragment,s),e=!0)},o(s){dn(t.$$.fragment,s),e=!1},d(s){yn(t,s)}}}function js(n){return re(()=>{const{scene:t,camera:e,renderer:s}=we(),i=Ls({firstHitOnly:!0}),{dispose:a}=Is({target:s.domElement,camera:e.current});Ae();const o=Array.from({length:100}).map(()=>{const r=new ge({color:"yellow"}),p=.1,f=be(r,p,p,p),[u,l]=Vs(1.5);return f.position.set(u,-.25,l),f.userData.rotation={y:(Math.random()-.5)*.1,z:(Math.random()-.5)*.1},f.addEventListener("pointerenter",d=>{d.stopPropagation(),r.color.set("hotpink")}),f.addEventListener("pointerleave",()=>r.color.set("yellow")),f.addEventListener("click",()=>r.color.set("blue")),f.geometry.computeBoundsTree(),f});t.add(...o),ks(t);const{stop:c}=Te(()=>{o.forEach(r=>{r.rotation.y+=r.userData.rotation.y,r.rotation.z+=r.userData.rotation.z})});return()=>{c(),a(),o.forEach(r=>r.geometry.disposeBoundsTree()),i()}}),[]}class Ws extends ce{constructor(t){super(),ae(this,t,js,Ns,ie,{})}}export{Ws as component};
