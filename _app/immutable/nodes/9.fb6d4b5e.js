import{s as Be,o as Se,n as Me}from"../chunks/scheduler.b0c1c2c3.js";import{S as Ie,i as Ee,r as Ht,u as kt,v as Nt,d as jt,t as Xt,w as Yt,g as Ce,s as te,h as _e,z as ze,c as ee,a as _t,f as zt}from"../chunks/index.f44ac6f0.js";import{e as I,f as Ae,V as E,g as nt,P as ve,L as V,T as lt,S as Fe,h as pt,i as Le,D as Re,j as st,F as ne,R as De,M as St,k as Ft,l as se,m as ot,n as Oe,o as Ue,u as $e,s as Ve,c as qe,p as He,b as ke,C as Ne}from"../chunks/setup.ed225109.js";import{D as je,C as Xe}from"../chunks/code.2b10818d.js";const Ye=()=>{let e=0,t=0;return new ResizeObserver(([s])=>{e=(s==null?void 0:s.contentRect.width)??0,t=(s==null?void 0:s.contentRect.height)??0}).observe(I.target),s=>{I.pointer.set(s.offsetX/e*2-1,-(s.offsetY/t*2)+1),I.raycaster.setFromCamera(I.pointer,I.camera)}},Te=0,Ze=1,We=2,ie=2,Lt=1.25,oe=1,Mt=6*4+4+4,Zt=65535,Ge=Math.pow(2,-24);class xt{constructor(){}}function O(e,t,n){return n.min.x=t[e],n.min.y=t[e+1],n.min.z=t[e+2],n.max.x=t[e+3],n.max.y=t[e+4],n.max.z=t[e+5],n}function Ke(e){e[0]=e[1]=e[2]=1/0,e[3]=e[4]=e[5]=-1/0}function re(e){let t=-1,n=-1/0;for(let s=0;s<3;s++){const i=e[s+3]-e[s];i>n&&(n=i,t=s)}return t}function ce(e,t){t.set(e)}function ae(e,t,n){let s,i;for(let r=0;r<3;r++){const c=r+3;s=e[r],i=t[r],n[r]=s<i?s:i,s=e[c],i=t[c],n[c]=s>i?s:i}}function wt(e,t,n){for(let s=0;s<3;s++){const i=t[e+2*s],r=t[e+2*s+1],c=i-r,f=i+r;c<n[s]&&(n[s]=c),f>n[s+3]&&(n[s+3]=f)}}function rt(e){const t=e[3]-e[0],n=e[4]-e[1],s=e[5]-e[2];return 2*(t*n+n*s+s*t)}function Je(e,t){if(!e.index){const n=e.attributes.position.count,s=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;let i;n>65535?i=new Uint32Array(new s(4*n)):i=new Uint16Array(new s(2*n)),e.setIndex(new Ae(i,1));for(let r=0;r<n;r++)i[r]=r}}function Qe(e){if(!e.groups||!e.groups.length)return[{offset:0,count:e.index.count/3}];const t=[],n=new Set;for(const i of e.groups)n.add(i.start),n.add(i.start+i.count);const s=Array.from(n.values()).sort((i,r)=>i-r);for(let i=0;i<s.length-1;i++){const r=s[i],c=s[i+1];t.push({offset:r/3,count:(c-r)/3})}return t}function Rt(e,t,n,s,i=null){let r=1/0,c=1/0,f=1/0,o=-1/0,u=-1/0,l=-1/0,p=1/0,a=1/0,h=1/0,v=-1/0,B=-1/0,y=-1/0;const d=i!==null;for(let x=t*6,m=(t+n)*6;x<m;x+=6){const b=e[x+0],w=e[x+1],A=b-w,P=b+w;A<r&&(r=A),P>o&&(o=P),d&&b<p&&(p=b),d&&b>v&&(v=b);const g=e[x+2],T=e[x+3],S=g-T,M=g+T;S<c&&(c=S),M>u&&(u=M),d&&g<a&&(a=g),d&&g>B&&(B=g);const C=e[x+4],_=e[x+5],z=C-_,F=C+_;z<f&&(f=z),F>l&&(l=F),d&&C<h&&(h=C),d&&C>y&&(y=C)}s[0]=r,s[1]=c,s[2]=f,s[3]=o,s[4]=u,s[5]=l,d&&(i[0]=p,i[1]=a,i[2]=h,i[3]=v,i[4]=B,i[5]=y)}function tn(e,t,n,s){let i=1/0,r=1/0,c=1/0,f=-1/0,o=-1/0,u=-1/0;for(let l=t*6,p=(t+n)*6;l<p;l+=6){const a=e[l+0];a<i&&(i=a),a>f&&(f=a);const h=e[l+2];h<r&&(r=h),h>o&&(o=h);const v=e[l+4];v<c&&(c=v),v>u&&(u=v)}s[0]=i,s[1]=r,s[2]=c,s[3]=f,s[4]=o,s[5]=u}function en(e,t,n,s,i){let r=n,c=n+s-1;const f=i.pos,o=i.axis*2;for(;;){for(;r<=c&&t[r*6+o]<f;)r++;for(;r<=c&&t[c*6+o]>=f;)c--;if(r<c){for(let u=0;u<3;u++){let l=e[r*3+u];e[r*3+u]=e[c*3+u],e[c*3+u]=l;let p=t[r*6+u*2+0];t[r*6+u*2+0]=t[c*6+u*2+0],t[c*6+u*2+0]=p;let a=t[r*6+u*2+1];t[r*6+u*2+1]=t[c*6+u*2+1],t[c*6+u*2+1]=a}r++,c--}else return r}}const $=32,nn=(e,t)=>e.candidate-t.candidate,k=new Array($).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),bt=new Float32Array(6);function sn(e,t,n,s,i,r){let c=-1,f=0;if(r===Te)c=re(t),c!==-1&&(f=(t[c]+t[c+3])/2);else if(r===Ze)c=re(e),c!==-1&&(f=on(n,s,i,c));else if(r===We){const o=rt(e);let u=Lt*i;const l=s*6,p=(s+i)*6;for(let a=0;a<3;a++){const h=t[a],y=(t[a+3]-h)/$;if(i<$/4){const d=[...k];d.length=i;let x=0;for(let b=l;b<p;b+=6,x++){const w=d[x];w.candidate=n[b+2*a],w.count=0;const{bounds:A,leftCacheBounds:P,rightCacheBounds:g}=w;for(let T=0;T<3;T++)g[T]=1/0,g[T+3]=-1/0,P[T]=1/0,P[T+3]=-1/0,A[T]=1/0,A[T+3]=-1/0;wt(b,n,A)}d.sort(nn);let m=i;for(let b=0;b<m;b++){const w=d[b];for(;b+1<m&&d[b+1].candidate===w.candidate;)d.splice(b+1,1),m--}for(let b=l;b<p;b+=6){const w=n[b+2*a];for(let A=0;A<m;A++){const P=d[A];w>=P.candidate?wt(b,n,P.rightCacheBounds):(wt(b,n,P.leftCacheBounds),P.count++)}}for(let b=0;b<m;b++){const w=d[b],A=w.count,P=i-w.count,g=w.leftCacheBounds,T=w.rightCacheBounds;let S=0;A!==0&&(S=rt(g)/o);let M=0;P!==0&&(M=rt(T)/o);const C=oe+Lt*(S*A+M*P);C<u&&(c=a,u=C,f=w.candidate)}}else{for(let m=0;m<$;m++){const b=k[m];b.count=0,b.candidate=h+y+m*y;const w=b.bounds;for(let A=0;A<3;A++)w[A]=1/0,w[A+3]=-1/0}for(let m=l;m<p;m+=6){let A=~~((n[m+2*a]-h)/y);A>=$&&(A=$-1);const P=k[A];P.count++,wt(m,n,P.bounds)}const d=k[$-1];ce(d.bounds,d.rightCacheBounds);for(let m=$-2;m>=0;m--){const b=k[m],w=k[m+1];ae(b.bounds,w.rightCacheBounds,b.rightCacheBounds)}let x=0;for(let m=0;m<$-1;m++){const b=k[m],w=b.count,A=b.bounds,g=k[m+1].rightCacheBounds;w!==0&&(x===0?ce(A,bt):ae(A,bt,bt)),x+=w;let T=0,S=0;x!==0&&(T=rt(bt)/o);const M=i-x;M!==0&&(S=rt(g)/o);const C=oe+Lt*(T*x+S*M);C<u&&(c=a,u=C,f=b.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${r} used.`);return{axis:c,pos:f}}function on(e,t,n,s){let i=0;for(let r=t,c=t+n;r<c;r++)i+=e[r*6+s*2];return i/n}function rn(e,t){Ke(t);const n=e.attributes.position,s=e.index.array,i=s.length/3,r=new Float32Array(i*6),c=n.normalized,f=n.array,o=n.offset||0;let u=3;n.isInterleavedBufferAttribute&&(u=n.data.stride);const l=["getX","getY","getZ"];for(let p=0;p<i;p++){const a=p*3,h=p*6;let v,B,y;c?(v=s[a+0],B=s[a+1],y=s[a+2]):(v=s[a+0]*u+o,B=s[a+1]*u+o,y=s[a+2]*u+o);for(let d=0;d<3;d++){let x,m,b;c?(x=n[l[d]](v),m=n[l[d]](B),b=n[l[d]](y)):(x=f[v+d],m=f[B+d],b=f[y+d]);let w=x;m<w&&(w=m),b<w&&(w=b);let A=x;m>A&&(A=m),b>A&&(A=b);const P=(A-w)/2,g=d*2;r[h+g+0]=w+P,r[h+g+1]=P+(Math.abs(w)+P)*Ge,w<t[d]&&(t[d]=w),A>t[d+3]&&(t[d+3]=A)}}return r}function cn(e,t){function n(d){a&&a(d/h)}function s(d,x,m,b=null,w=0){if(!v&&w>=o&&(v=!0,u&&(console.warn(`MeshBVH: Max depth of ${o} reached when generating BVH. Consider increasing maxDepth.`),console.warn(e))),m<=l||w>=o)return n(x+m),d.offset=x,d.count=m,d;const A=sn(d.boundingData,b,c,x,m,p);if(A.axis===-1)return n(x+m),d.offset=x,d.count=m,d;const P=en(f,c,x,m,A);if(P===x||P===x+m)n(x+m),d.offset=x,d.count=m;else{d.splitAxis=A.axis;const g=new xt,T=x,S=P-x;d.left=g,g.boundingData=new Float32Array(6),Rt(c,T,S,g.boundingData,r),s(g,T,S,r,w+1);const M=new xt,C=P,_=m-S;d.right=M,M.boundingData=new Float32Array(6),Rt(c,C,_,M.boundingData,r),s(M,C,_,r,w+1)}return d}Je(e,t);const i=new Float32Array(6),r=new Float32Array(6),c=rn(e,i),f=e.index.array,o=t.maxDepth,u=t.verbose,l=t.maxLeafTris,p=t.strategy,a=t.onProgress,h=e.index.count/3;let v=!1;const B=[],y=Qe(e);if(y.length===1){const d=y[0],x=new xt;x.boundingData=i,tn(c,d.offset,d.count,r),s(x,d.offset,d.count,r),B.push(x)}else for(let d of y){const x=new xt;x.boundingData=new Float32Array(6),Rt(c,d.offset,d.count,x.boundingData,r),s(x,d.offset,d.count,r),B.push(x)}return B}function an(e,t){const n=cn(e,t);let s,i,r;const c=[],f=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;for(let l=0;l<n.length;l++){const p=n[l];let a=o(p);const h=new f(Mt*a);s=new Float32Array(h),i=new Uint32Array(h),r=new Uint16Array(h),u(0,p),c.push(h)}return c;function o(l){return l.count?1:1+o(l.left)+o(l.right)}function u(l,p){const a=l/4,h=l/2,v=!!p.count,B=p.boundingData;for(let y=0;y<6;y++)s[a+y]=B[y];if(v){const y=p.offset,d=p.count;return i[a+6]=y,r[h+14]=d,r[h+15]=Zt,l+Mt}else{const y=p.left,d=p.right,x=p.splitAxis;let m;if(m=u(l+Mt,y),m/4>Math.pow(2,32))throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return i[a+6]=m/4,m=u(m,d),i[a+7]=x,m}}}class q{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,n){let s=1/0,i=-1/0;for(let r=0,c=t.length;r<c;r++){const o=t[r][n];s=o<s?o:s,i=o>i?o:i}this.min=s,this.max=i}setFromPoints(t,n){let s=1/0,i=-1/0;for(let r=0,c=n.length;r<c;r++){const f=n[r],o=t.dot(f);s=o<s?o:s,i=o>i?o:i}this.min=s,this.max=i}isSeparated(t){return this.min>t.max||t.min>this.max}}q.prototype.setFromBox=function(){const e=new E;return function(n,s){const i=s.min,r=s.max;let c=1/0,f=-1/0;for(let o=0;o<=1;o++)for(let u=0;u<=1;u++)for(let l=0;l<=1;l++){e.x=i.x*o+r.x*(1-o),e.y=i.y*u+r.y*(1-u),e.z=i.z*l+r.z*(1-l);const p=n.dot(e);c=Math.min(p,c),f=Math.max(p,f)}this.min=c,this.max=f}}();const ln=function(){const e=new E,t=new E,n=new E;return function(i,r,c){const f=i.start,o=e,u=r.start,l=t;n.subVectors(f,u),e.subVectors(i.end,i.start),t.subVectors(r.end,r.start);const p=n.dot(l),a=l.dot(o),h=l.dot(l),v=n.dot(o),y=o.dot(o)*h-a*a;let d,x;y!==0?d=(p*a-v*h)/y:d=0,x=(p+d*a)/h,c.x=d,c.y=x}}(),Jt=function(){const e=new nt,t=new E,n=new E;return function(i,r,c,f){ln(i,r,e);let o=e.x,u=e.y;if(o>=0&&o<=1&&u>=0&&u<=1){i.at(o,c),r.at(u,f);return}else if(o>=0&&o<=1){u<0?r.at(0,f):r.at(1,f),i.closestPointToPoint(f,!0,c);return}else if(u>=0&&u<=1){o<0?i.at(0,c):i.at(1,c),r.closestPointToPoint(c,!0,f);return}else{let l;o<0?l=i.start:l=i.end;let p;u<0?p=r.start:p=r.end;const a=t,h=n;if(i.closestPointToPoint(p,!0,t),r.closestPointToPoint(l,!0,n),a.distanceToSquared(p)<=h.distanceToSquared(l)){c.copy(a),f.copy(p);return}else{c.copy(l),f.copy(h);return}}}}(),fn=function(){const e=new E,t=new E,n=new ve,s=new V;return function(r,c){const{radius:f,center:o}=r,{a:u,b:l,c:p}=c;if(s.start=u,s.end=l,s.closestPointToPoint(o,!0,e).distanceTo(o)<=f||(s.start=u,s.end=p,s.closestPointToPoint(o,!0,e).distanceTo(o)<=f)||(s.start=l,s.end=p,s.closestPointToPoint(o,!0,e).distanceTo(o)<=f))return!0;const B=c.getPlane(n);if(Math.abs(B.distanceToPoint(o))<=f){const d=B.projectPoint(o,t);if(c.containsPoint(d))return!0}return!1}}(),un=1e-15;function Dt(e){return Math.abs(e)<un}class H extends lt{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new E),this.satBounds=new Array(4).fill().map(()=>new q),this.points=[this.a,this.b,this.c],this.sphere=new Fe,this.plane=new ve,this.needsUpdate=!0}intersectsSphere(t){return fn(t,this)}update(){const t=this.a,n=this.b,s=this.c,i=this.points,r=this.satAxes,c=this.satBounds,f=r[0],o=c[0];this.getNormal(f),o.setFromPoints(f,i);const u=r[1],l=c[1];u.subVectors(t,n),l.setFromPoints(u,i);const p=r[2],a=c[2];p.subVectors(n,s),a.setFromPoints(p,i);const h=r[3],v=c[3];h.subVectors(s,t),v.setFromPoints(h,i),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(f,t),this.needsUpdate=!1}}H.prototype.closestPointToSegment=function(){const e=new E,t=new E,n=new V;return function(i,r=null,c=null){const{start:f,end:o}=i,u=this.points;let l,p=1/0;for(let a=0;a<3;a++){const h=(a+1)%3;n.start.copy(u[a]),n.end.copy(u[h]),Jt(n,i,e,t),l=e.distanceToSquared(t),l<p&&(p=l,r&&r.copy(e),c&&c.copy(t))}return this.closestPointToPoint(f,e),l=f.distanceToSquared(e),l<p&&(p=l,r&&r.copy(e),c&&c.copy(f)),this.closestPointToPoint(o,e),l=o.distanceToSquared(e),l<p&&(p=l,r&&r.copy(e),c&&c.copy(o)),Math.sqrt(p)}}();H.prototype.intersectsTriangle=function(){const e=new H,t=new Array(3),n=new Array(3),s=new q,i=new q,r=new E,c=new E,f=new E,o=new E,u=new E,l=new V,p=new V,a=new V,h=new E;function v(B,y,d){const x=B.points;let m=0,b=-1;for(let w=0;w<3;w++){const{start:A,end:P}=l;A.copy(x[w]),P.copy(x[(w+1)%3]),l.delta(c);const g=Dt(y.distanceToPoint(A));if(Dt(y.normal.dot(c))&&g){d.copy(l),m=2;break}const T=y.intersectLine(l,h);if(!T&&g&&h.copy(A),(T||g)&&!Dt(h.distanceTo(P))){if(m<=1)(m===1?d.start:d.end).copy(h),g&&(b=m);else if(m>=2){(b===1?d.start:d.end).copy(h),m=2;break}if(m++,m===2&&b===-1)break}}return m}return function(y,d=null,x=!1){this.needsUpdate&&this.update(),y.isExtendedTriangle?y.needsUpdate&&y.update():(e.copy(y),e.update(),y=e);const m=this.plane,b=y.plane;if(Math.abs(m.normal.dot(b.normal))>1-1e-10){const w=this.satBounds,A=this.satAxes;n[0]=y.a,n[1]=y.b,n[2]=y.c;for(let T=0;T<4;T++){const S=w[T],M=A[T];if(s.setFromPoints(M,n),S.isSeparated(s))return!1}const P=y.satBounds,g=y.satAxes;t[0]=this.a,t[1]=this.b,t[2]=this.c;for(let T=0;T<4;T++){const S=P[T],M=g[T];if(s.setFromPoints(M,t),S.isSeparated(s))return!1}for(let T=0;T<4;T++){const S=A[T];for(let M=0;M<4;M++){const C=g[M];if(r.crossVectors(S,C),s.setFromPoints(r,t),i.setFromPoints(r,n),s.isSeparated(i))return!1}}return d&&(x||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),d.start.set(0,0,0),d.end.set(0,0,0)),!0}else{const w=v(this,b,p);if(w===1&&y.containsPoint(p.end))return d&&(d.start.copy(p.end),d.end.copy(p.end)),!0;if(w!==2)return!1;const A=v(y,m,a);if(A===1&&this.containsPoint(a.end))return d&&(d.start.copy(a.end),d.end.copy(a.end)),!0;if(A!==2)return!1;if(p.delta(f),a.delta(o),f.dot(o)<0){let _=a.start;a.start=a.end,a.end=_}const P=p.start.dot(f),g=p.end.dot(f),T=a.start.dot(f),S=a.end.dot(f),M=g<T,C=P<S;return P!==S&&T!==g&&M===C?!1:(d&&(u.subVectors(p.start,a.start),u.dot(f)>0?d.start.copy(p.start):d.start.copy(a.start),u.subVectors(p.end,a.end),u.dot(f)<0?d.end.copy(p.end):d.end.copy(a.end)),!0)}}}();H.prototype.distanceToPoint=function(){const e=new E;return function(n){return this.closestPointToPoint(n,e),n.distanceTo(e)}}();H.prototype.distanceToTriangle=function(){const e=new E,t=new E,n=["a","b","c"],s=new V,i=new V;return function(c,f=null,o=null){const u=f||o?s:null;if(this.intersectsTriangle(c,u))return(f||o)&&(f&&u.getCenter(f),o&&u.getCenter(o)),0;let l=1/0;for(let p=0;p<3;p++){let a;const h=n[p],v=c[h];this.closestPointToPoint(v,e),a=v.distanceToSquared(e),a<l&&(l=a,f&&f.copy(e),o&&o.copy(v));const B=this[h];c.closestPointToPoint(B,e),a=B.distanceToSquared(e),a<l&&(l=a,f&&f.copy(B),o&&o.copy(e))}for(let p=0;p<3;p++){const a=n[p],h=n[(p+1)%3];s.set(this[a],this[h]);for(let v=0;v<3;v++){const B=n[v],y=n[(v+1)%3];i.set(c[B],c[y]),Jt(s,i,e,t);const d=e.distanceToSquared(t);d<l&&(l=d,f&&f.copy(e),o&&o.copy(t))}}return Math.sqrt(l)}}();class U{constructor(t,n,s){this.isOrientedBox=!0,this.min=new E,this.max=new E,this.matrix=new pt,this.invMatrix=new pt,this.points=new Array(8).fill().map(()=>new E),this.satAxes=new Array(3).fill().map(()=>new E),this.satBounds=new Array(3).fill().map(()=>new q),this.alignedSatBounds=new Array(3).fill().map(()=>new q),this.needsUpdate=!1,t&&this.min.copy(t),n&&this.max.copy(n),s&&this.matrix.copy(s)}set(t,n,s){this.min.copy(t),this.max.copy(n),this.matrix.copy(s),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}U.prototype.update=function(){return function(){const t=this.matrix,n=this.min,s=this.max,i=this.points;for(let u=0;u<=1;u++)for(let l=0;l<=1;l++)for(let p=0;p<=1;p++){const a=1*u|2*l|4*p,h=i[a];h.x=u?s.x:n.x,h.y=l?s.y:n.y,h.z=p?s.z:n.z,h.applyMatrix4(t)}const r=this.satBounds,c=this.satAxes,f=i[0];for(let u=0;u<3;u++){const l=c[u],p=r[u],a=1<<u,h=i[a];l.subVectors(f,h),p.setFromPoints(l,i)}const o=this.alignedSatBounds;o[0].setFromPointsField(i,"x"),o[1].setFromPointsField(i,"y"),o[2].setFromPointsField(i,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();U.prototype.intersectsBox=function(){const e=new q;return function(n){this.needsUpdate&&this.update();const s=n.min,i=n.max,r=this.satBounds,c=this.satAxes,f=this.alignedSatBounds;if(e.min=s.x,e.max=i.x,f[0].isSeparated(e)||(e.min=s.y,e.max=i.y,f[1].isSeparated(e))||(e.min=s.z,e.max=i.z,f[2].isSeparated(e)))return!1;for(let o=0;o<3;o++){const u=c[o],l=r[o];if(e.setFromBox(u,n),l.isSeparated(e))return!1}return!0}}();U.prototype.intersectsTriangle=function(){const e=new H,t=new Array(3),n=new q,s=new q,i=new E;return function(c){this.needsUpdate&&this.update(),c.isExtendedTriangle?c.needsUpdate&&c.update():(e.copy(c),e.update(),c=e);const f=this.satBounds,o=this.satAxes;t[0]=c.a,t[1]=c.b,t[2]=c.c;for(let a=0;a<3;a++){const h=f[a],v=o[a];if(n.setFromPoints(v,t),h.isSeparated(n))return!1}const u=c.satBounds,l=c.satAxes,p=this.points;for(let a=0;a<3;a++){const h=u[a],v=l[a];if(n.setFromPoints(v,p),h.isSeparated(n))return!1}for(let a=0;a<3;a++){const h=o[a];for(let v=0;v<4;v++){const B=l[v];if(i.crossVectors(h,B),n.setFromPoints(i,t),s.setFromPoints(i,p),n.isSeparated(s))return!1}}return!0}}();U.prototype.closestPointToPoint=function(){return function(t,n){return this.needsUpdate&&this.update(),n.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),n}}();U.prototype.distanceToPoint=function(){const e=new E;return function(n){return this.closestPointToPoint(n,e),n.distanceTo(e)}}();U.prototype.distanceToBox=function(){const e=["x","y","z"],t=new Array(12).fill().map(()=>new V),n=new Array(12).fill().map(()=>new V),s=new E,i=new E;return function(c,f=0,o=null,u=null){if(this.needsUpdate&&this.update(),this.intersectsBox(c))return(o||u)&&(c.getCenter(i),this.closestPointToPoint(i,s),c.closestPointToPoint(s,i),o&&o.copy(s),u&&u.copy(i)),0;const l=f*f,p=c.min,a=c.max,h=this.points;let v=1/0;for(let y=0;y<8;y++){const d=h[y];i.copy(d).clamp(p,a);const x=d.distanceToSquared(i);if(x<v&&(v=x,o&&o.copy(d),u&&u.copy(i),x<l))return Math.sqrt(x)}let B=0;for(let y=0;y<3;y++)for(let d=0;d<=1;d++)for(let x=0;x<=1;x++){const m=(y+1)%3,b=(y+2)%3,w=d<<m|x<<b,A=1<<y|d<<m|x<<b,P=h[w],g=h[A];t[B].set(P,g);const S=e[y],M=e[m],C=e[b],_=n[B],z=_.start,F=_.end;z[S]=p[S],z[M]=d?p[M]:a[M],z[C]=x?p[C]:a[M],F[S]=a[S],F[M]=d?p[M]:a[M],F[C]=x?p[C]:a[M],B++}for(let y=0;y<=1;y++)for(let d=0;d<=1;d++)for(let x=0;x<=1;x++){i.x=y?a.x:p.x,i.y=d?a.y:p.y,i.z=x?a.z:p.z,this.closestPointToPoint(i,s);const m=i.distanceToSquared(s);if(m<v&&(v=m,o&&o.copy(s),u&&u.copy(i),m<l))return Math.sqrt(m)}for(let y=0;y<12;y++){const d=t[y];for(let x=0;x<12;x++){const m=n[x];Jt(d,m,s,i);const b=s.distanceToSquared(i);if(b<v&&(v=b,o&&o.copy(s),u&&u.copy(i),b<l))return Math.sqrt(b)}}return Math.sqrt(v)}}();const G=new E,K=new E,J=new E,At=new nt,vt=new nt,Tt=new nt,le=new E,fe=new E,ue=new E,Pt=new E;function pn(e,t,n,s,i,r){let c;return r===Le?c=e.intersectTriangle(s,n,t,!0,i):c=e.intersectTriangle(t,n,s,r!==Re,i),c===null?null:{distance:e.origin.distanceTo(i),point:i.clone()}}function dn(e,t,n,s,i,r,c,f,o){G.fromBufferAttribute(t,r),K.fromBufferAttribute(t,c),J.fromBufferAttribute(t,f);const u=pn(e,G,K,J,Pt,o);if(u){s&&(At.fromBufferAttribute(s,r),vt.fromBufferAttribute(s,c),Tt.fromBufferAttribute(s,f),u.uv=lt.getInterpolation(Pt,G,K,J,At,vt,Tt,new nt)),i&&(At.fromBufferAttribute(i,r),vt.fromBufferAttribute(i,c),Tt.fromBufferAttribute(i,f),u.uv1=lt.getInterpolation(Pt,G,K,J,At,vt,Tt,new nt)),n&&(le.fromBufferAttribute(n,r),fe.fromBufferAttribute(n,c),ue.fromBufferAttribute(n,f),u.normal=lt.getInterpolation(Pt,G,K,J,le,fe,ue,new E),u.normal.dot(e.direction)>0&&u.normal.multiplyScalar(-1));const l={a:r,b:c,c:f,normal:new E,materialIndex:0};lt.getNormal(G,K,J,l.normal),u.face=l,u.faceIndex=r}return u}function Pe(e,t,n,s,i){const r=s*3,c=e.index.getX(r),f=e.index.getX(r+1),o=e.index.getX(r+2),{position:u,normal:l,uv:p,uv1:a}=e.attributes,h=dn(n,u,l,p,a,c,f,o,t);return h?(h.faceIndex=s,i&&i.push(h),h):null}function hn(e,t,n,s,i,r){for(let c=s,f=s+i;c<f;c++)Pe(e,t,n,c,r)}function mn(e,t,n,s,i){let r=1/0,c=null;for(let f=s,o=s+i;f<o;f++){const u=Pe(e,t,n,f);u&&u.distance<r&&(c=u,r=u.distance)}return c}function pe(e,t,n){return e===null||(e.point.applyMatrix4(t.matrixWorld),e.distance=e.point.distanceTo(n.ray.origin),e.object=t,e.distance<n.near||e.distance>n.far)?null:e}function D(e,t,n,s){const i=e.a,r=e.b,c=e.c;let f=t,o=t+1,u=t+2;n&&(f=n.getX(t),o=n.getX(t+1),u=n.getX(t+2)),i.x=s.getX(f),i.y=s.getY(f),i.z=s.getZ(f),r.x=s.getX(o),r.y=s.getY(o),r.z=s.getZ(o),c.x=s.getX(u),c.y=s.getY(u),c.z=s.getZ(u)}function de(e,t,n,s,i,r,c){const f=n.index,o=n.attributes.position;for(let u=e,l=t+e;u<l;u++)if(D(c,u*3,f,o),c.needsUpdate=!0,s(c,u,i,r))return!0;return!1}class ge{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return t.length===0?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}function N(e,t){return t[e+15]===65535}function et(e,t){return t[e+6]}function dt(e,t){return t[e+14]}function ht(e){return e+8}function mt(e,t){return t[e+6]}function yn(e,t){return t[e+7]}const tt=new st,Et=new E,xn=["x","y","z"];function Wt(e,t,n,s,i){let r=e*2,c=it,f=j,o=X;if(N(r,f)){const l=et(e,o),p=dt(r,f);hn(t,n,s,l,p,i)}else{const l=ht(e);Ct(l,c,s,Et)&&Wt(l,t,n,s,i);const p=mt(e,o);Ct(p,c,s,Et)&&Wt(p,t,n,s,i)}}function Gt(e,t,n,s){let i=e*2,r=it,c=j,f=X;if(N(i,c)){const u=et(e,f),l=dt(i,c);return mn(t,n,s,u,l)}else{const u=yn(e,f),l=xn[u],a=s.direction[l]>=0;let h,v;a?(h=ht(e),v=mt(e,f)):(h=mt(e,f),v=ht(e));const y=Ct(h,r,s,Et)?Gt(h,t,n,s):null;if(y){const m=y.point[l];if(a?m<=r[v+u]:m>=r[v+u+3])return y}const x=Ct(v,r,s,Et)?Gt(v,t,n,s):null;return y&&x?y.distance<=x.distance?y:x:y||x||null}}const wn=function(){let e,t;const n=[],s=new ge(()=>new st);return function(...c){e=s.getPrimitive(),t=s.getPrimitive(),n.push(e,t);const f=i(...c);s.releasePrimitive(e),s.releasePrimitive(t),n.pop(),n.pop();const o=n.length;return o>0&&(t=n[o-1],e=n[o-2]),f};function i(r,c,f,o,u=null,l=0,p=0){function a(m){let b=m*2,w=j,A=X;for(;!N(b,w);)m=ht(m),b=m*2;return et(m,A)}function h(m){let b=m*2,w=j,A=X;for(;!N(b,w);)m=mt(m,A),b=m*2;return et(m,A)+dt(b,w)}let v=r*2,B=it,y=j,d=X;if(N(v,y)){const m=et(r,d),b=dt(v,y);return O(r,B,e),o(m,b,!1,p,l+r,e)}else{const m=ht(r),b=mt(r,d);let w=m,A=b,P,g,T,S;if(u&&(T=e,S=t,O(w,B,T),O(A,B,S),P=u(T),g=u(S),g<P)){w=b,A=m;const L=P;P=g,g=L,T=S}T||(T=e,O(w,B,T));const M=N(w*2,y),C=f(T,M,P,p+1,l+w);let _;if(C===ie){const L=a(w),W=h(w)-L;_=o(L,W,!0,p+1,l+w,T)}else _=C&&i(w,c,f,o,u,l,p+1);if(_)return!0;S=t,O(A,B,S);const z=N(A*2,y),F=f(S,z,g,p+1,l+A);let Z;if(F===ie){const L=a(A),W=h(A)-L;Z=o(L,W,!0,p+1,l+A,S)}else Z=F&&i(A,c,f,o,u,l,p+1);return!!Z}}}(),bn=function(){const e=new H,t=new H,n=new pt,s=new U,i=new U;return function r(c,f,o,u,l=null){let p=c*2,a=it,h=j,v=X;if(l===null&&(o.boundingBox||o.computeBoundingBox(),s.set(o.boundingBox.min,o.boundingBox.max,u),l=s),N(p,h)){const y=f,d=y.index,x=y.attributes.position,m=o.index,b=o.attributes.position,w=et(c,v),A=dt(p,h);if(n.copy(u).invert(),o.boundsTree)return O(c,a,i),i.matrix.copy(n),i.needsUpdate=!0,o.boundsTree.shapecast({intersectsBounds:g=>i.intersectsBox(g),intersectsTriangle:g=>{g.a.applyMatrix4(u),g.b.applyMatrix4(u),g.c.applyMatrix4(u),g.needsUpdate=!0;for(let T=w*3,S=(A+w)*3;T<S;T+=3)if(D(t,T,d,x),t.needsUpdate=!0,g.intersectsTriangle(t))return!0;return!1}});for(let P=w*3,g=A+w*3;P<g;P+=3){D(e,P,d,x),e.a.applyMatrix4(n),e.b.applyMatrix4(n),e.c.applyMatrix4(n),e.needsUpdate=!0;for(let T=0,S=m.count;T<S;T+=3)if(D(t,T,m,b),t.needsUpdate=!0,e.intersectsTriangle(t))return!0}}else{const y=c+8,d=v[c+6];return O(y,a,tt),!!(l.intersectsBox(tt)&&r(y,f,o,u,l)||(O(d,a,tt),l.intersectsBox(tt)&&r(d,f,o,u,l)))}}}();function Ct(e,t,n,s){return O(e,t,tt),n.intersectBox(tt,s)}const Kt=[];let It,it,j,X;function ft(e){It&&Kt.push(It),It=e,it=new Float32Array(e),j=new Uint16Array(e),X=new Uint32Array(e)}function gt(){It=null,it=null,j=null,X=null,Kt.length&&ft(Kt.pop())}const Ot=Symbol("skip tree generation"),Ut=new st,$t=new st,Q=new pt,Y=new U,ct=new U,at=new E,Bt=new E,An=new E,vn=new E,Tn=new E,he=new st,R=new ge(()=>new H);class ut{static serialize(t,n={}){if(n.isBufferGeometry)return console.warn("MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature."),ut.serialize(arguments[0],{cloneBuffers:arguments[2]===void 0?!0:arguments[2]});n={cloneBuffers:!0,...n};const s=t.geometry,i=t._roots,r=s.getIndex();let c;return n.cloneBuffers?c={roots:i.map(f=>f.slice()),index:r.array.slice()}:c={roots:i,index:r.array},c}static deserialize(t,n,s={}){if(typeof s=="boolean")return console.warn("MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature."),ut.deserialize(arguments[0],arguments[1],{setIndex:arguments[2]===void 0?!0:arguments[2]});s={setIndex:!0,...s};const{index:i,roots:r}=t,c=new ut(n,{...s,[Ot]:!0});if(c._roots=r,s.setIndex){const f=n.getIndex();if(f===null){const o=new Ae(t.index,1,!1);n.setIndex(o)}else f.array!==i&&(f.array.set(i),f.needsUpdate=!0)}return c}constructor(t,n={}){if(t.isBufferGeometry){if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(n=Object.assign({strategy:Te,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,[Ot]:!1},n),n.useSharedArrayBuffer&&typeof SharedArrayBuffer>"u")throw new Error("MeshBVH: SharedArrayBuffer is not available.");this._roots=null,n[Ot]||(this._roots=an(t,n),!t.boundingBox&&n.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new st))),this.geometry=t}refit(t=null){t&&Array.isArray(t)&&(t=new Set(t));const n=this.geometry,s=n.index.array,i=n.attributes.position;let r,c,f,o,u=0;const l=this._roots;for(let a=0,h=l.length;a<h;a++)r=l[a],c=new Uint32Array(r),f=new Uint16Array(r),o=new Float32Array(r),p(0,u),u+=r.byteLength;function p(a,h,v=!1){const B=a*2;if(f[B+15]===Zt){const d=c[a+6],x=f[B+14];let m=1/0,b=1/0,w=1/0,A=-1/0,P=-1/0,g=-1/0;for(let T=3*d,S=3*(d+x);T<S;T++){const M=s[T],C=i.getX(M),_=i.getY(M),z=i.getZ(M);C<m&&(m=C),C>A&&(A=C),_<b&&(b=_),_>P&&(P=_),z<w&&(w=z),z>g&&(g=z)}return o[a+0]!==m||o[a+1]!==b||o[a+2]!==w||o[a+3]!==A||o[a+4]!==P||o[a+5]!==g?(o[a+0]=m,o[a+1]=b,o[a+2]=w,o[a+3]=A,o[a+4]=P,o[a+5]=g,!0):!1}else{const d=a+8,x=c[a+6],m=d+h,b=x+h;let w=v,A=!1,P=!1;t?w||(A=t.has(m),P=t.has(b),w=!A&&!P):(A=!0,P=!0);const g=w||A,T=w||P;let S=!1;g&&(S=p(d,h,w));let M=!1;T&&(M=p(x,h,w));const C=S||M;if(C)for(let _=0;_<3;_++){const z=d+_,F=x+_,Z=o[z],L=o[z+3],yt=o[F],W=o[F+3];o[a+_]=Z<yt?Z:yt,o[a+_+3]=L>W?L:W}return C}}}traverse(t,n=0){const s=this._roots[n],i=new Uint32Array(s),r=new Uint16Array(s);c(0);function c(f,o=0){const u=f*2,l=r[u+15]===Zt;if(l){const p=i[f+6],a=r[u+14];t(o,l,new Float32Array(s,f*4,6),p,a)}else{const p=f+Mt/4,a=i[f+6],h=i[f+7];t(o,l,new Float32Array(s,f*4,6),h)||(c(p,o+1),c(a,o+1))}}}raycast(t,n=ne){const s=this._roots,i=this.geometry,r=[],c=n.isMaterial,f=Array.isArray(n),o=i.groups,u=c?n.side:n;for(let l=0,p=s.length;l<p;l++){const a=f?n[o[l].materialIndex].side:u,h=r.length;if(ft(s[l]),Wt(0,i,a,t,r),gt(),f){const v=o[l].materialIndex;for(let B=h,y=r.length;B<y;B++)r[B].face.materialIndex=v}}return r}raycastFirst(t,n=ne){const s=this._roots,i=this.geometry,r=n.isMaterial,c=Array.isArray(n);let f=null;const o=i.groups,u=r?n.side:n;for(let l=0,p=s.length;l<p;l++){const a=c?n[o[l].materialIndex].side:u;ft(s[l]);const h=Gt(0,i,a,t);gt(),h!=null&&(f==null||h.distance<f.distance)&&(f=h,c&&(h.face.materialIndex=o[l].materialIndex))}return f}intersectsGeometry(t,n){const s=this.geometry;let i=!1;for(const r of this._roots)if(ft(r),i=bn(0,s,t,n),gt(),i)break;return i}shapecast(t,n,s){const i=this.geometry;if(t instanceof Function){if(n){const a=n;n=(h,v,B,y)=>{const d=v*3;return a(h,d,d+1,d+2,B,y)}}t={boundsTraverseOrder:s,intersectsBounds:t,intersectsTriangle:n,intersectsRange:null},console.warn("MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.")}const r=R.getPrimitive();let{boundsTraverseOrder:c,intersectsBounds:f,intersectsRange:o,intersectsTriangle:u}=t;if(o&&u){const a=o;o=(h,v,B,y,d)=>a(h,v,B,y,d)?!0:de(h,v,i,u,B,y,r)}else o||(u?o=(a,h,v,B)=>de(a,h,i,u,v,B,r):o=(a,h,v)=>v);let l=!1,p=0;for(const a of this._roots){if(ft(a),l=wn(0,i,f,o,c,p),gt(),l)break;p+=a.byteLength}return R.releasePrimitive(r),l}bvhcast(t,n,s){let{intersectsRanges:i,intersectsTriangles:r}=s;const c=this.geometry.index,f=this.geometry.attributes.position,o=t.geometry.index,u=t.geometry.attributes.position;Q.copy(n).invert();const l=R.getPrimitive(),p=R.getPrimitive();if(r){let h=function(v,B,y,d,x,m,b,w){for(let A=y,P=y+d;A<P;A++){D(p,A*3,o,u),p.a.applyMatrix4(n),p.b.applyMatrix4(n),p.c.applyMatrix4(n),p.needsUpdate=!0;for(let g=v,T=v+B;g<T;g++)if(D(l,g*3,c,f),l.needsUpdate=!0,r(l,p,g,A,x,m,b,w))return!0}return!1};if(i){const v=i;i=function(B,y,d,x,m,b,w,A){return v(B,y,d,x,m,b,w,A)?!0:h(B,y,d,x,m,b,w,A)}}else i=h}t.getBoundingBox($t),$t.applyMatrix4(n);const a=this.shapecast({intersectsBounds:h=>$t.intersectsBox(h),intersectsRange:(h,v,B,y,d,x)=>(Ut.copy(x),Ut.applyMatrix4(Q),t.shapecast({intersectsBounds:m=>Ut.intersectsBox(m),intersectsRange:(m,b,w,A,P)=>i(h,v,m,b,y,d,A,P)}))});return R.releasePrimitive(l),R.releasePrimitive(p),a}intersectsBox(t,n){return Y.set(t.min,t.max,n),Y.needsUpdate=!0,this.shapecast({intersectsBounds:s=>Y.intersectsBox(s),intersectsTriangle:s=>Y.intersectsTriangle(s)})}intersectsSphere(t){return this.shapecast({intersectsBounds:n=>t.intersectsBox(n),intersectsTriangle:n=>n.intersectsSphere(t)})}closestPointToGeometry(t,n,s={},i={},r=0,c=1/0){t.boundingBox||t.computeBoundingBox(),Y.set(t.boundingBox.min,t.boundingBox.max,n),Y.needsUpdate=!0;const f=this.geometry,o=f.attributes.position,u=f.index,l=t.attributes.position,p=t.index,a=R.getPrimitive(),h=R.getPrimitive();let v=Bt,B=An,y=null,d=null;i&&(y=vn,d=Tn);let x=1/0,m=null,b=null;return Q.copy(n).invert(),ct.matrix.copy(Q),this.shapecast({boundsTraverseOrder:w=>Y.distanceToBox(w),intersectsBounds:(w,A,P)=>P<x&&P<c?(A&&(ct.min.copy(w.min),ct.max.copy(w.max),ct.needsUpdate=!0),!0):!1,intersectsRange:(w,A)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:P=>ct.distanceToBox(P),intersectsBounds:(P,g,T)=>T<x&&T<c,intersectsRange:(P,g)=>{for(let T=P*3,S=(P+g)*3;T<S;T+=3){D(h,T,p,l),h.a.applyMatrix4(n),h.b.applyMatrix4(n),h.c.applyMatrix4(n),h.needsUpdate=!0;for(let M=w*3,C=(w+A)*3;M<C;M+=3){D(a,M,u,o),a.needsUpdate=!0;const _=a.distanceToTriangle(h,v,y);if(_<x&&(B.copy(v),d&&d.copy(y),x=_,m=M/3,b=T/3),_<r)return!0}}}});{const P=p?p.count:l.count;for(let g=0,T=P;g<T;g+=3){D(h,g,p,l),h.a.applyMatrix4(n),h.b.applyMatrix4(n),h.c.applyMatrix4(n),h.needsUpdate=!0;for(let S=w*3,M=(w+A)*3;S<M;S+=3){D(a,S,u,o),a.needsUpdate=!0;const C=a.distanceToTriangle(h,v,y);if(C<x&&(B.copy(v),d&&d.copy(y),x=C,m=S/3,b=g/3),C<r)return!0}}}}}),R.releasePrimitive(a),R.releasePrimitive(h),x===1/0?null:(s.point?s.point.copy(B):s.point=B.clone(),s.distance=x,s.faceIndex=m,i&&(i.point?i.point.copy(d):i.point=d.clone(),i.point.applyMatrix4(Q),B.applyMatrix4(Q),i.distance=B.sub(i.point).length(),i.faceIndex=b),s)}closestPointToPoint(t,n={},s=0,i=1/0){const r=s*s,c=i*i;let f=1/0,o=null;if(this.shapecast({boundsTraverseOrder:l=>(at.copy(t).clamp(l.min,l.max),at.distanceToSquared(t)),intersectsBounds:(l,p,a)=>a<f&&a<c,intersectsTriangle:(l,p)=>{l.closestPointToPoint(t,at);const a=t.distanceToSquared(at);return a<f&&(Bt.copy(at),f=a,o=p),a<r}}),f===1/0)return null;const u=Math.sqrt(f);return n.point?n.point.copy(Bt):n.point=Bt.clone(),n.distance=u,n.faceIndex=o,n}getBoundingBox(t){return t.makeEmpty(),this._roots.forEach(s=>{O(0,new Float32Array(s),he),t.union(he)}),t}}const Vt=new De,me=new pt,Pn=St.prototype.raycast;function ye(e,t){if(this.geometry.boundsTree){if(this.material===void 0)return;me.copy(this.matrixWorld).invert(),Vt.copy(e.ray).applyMatrix4(me);const n=this.geometry.boundsTree;if(e.firstHitOnly===!0){const s=pe(n.raycastFirst(Vt,this.material),this,e);s&&t.push(s)}else{const s=n.raycast(Vt,this.material);for(let i=0,r=s.length;i<r;i++){const c=pe(s[i],this,e);c&&t.push(c)}}}else Pn.call(this,e,t)}function gn(e){return this.boundsTree=new ut(this,e),this.boundsTree}function Bn(){this.boundsTree=null}const Sn=(e={})=>{const{computeBoundsTree:t,disposeBoundsTree:n}=ot.prototype,{raycast:s}=Ft.prototype,{raycast:i}=St.prototype;return Ft.prototype.raycast=ye,St.prototype.raycast=ye,se.prototype.firstHitOnly=e.firstHitOnly??!0,ot.prototype.computeBoundsTree=function(f){return gn.call(this,f??e)},ot.prototype.disposeBoundsTree=Bn,()=>{ot.prototype.computeBoundsTree=t,ot.prototype.disposeBoundsTree=n,Ft.prototype.raycast=s,St.prototype.raycast=i,delete se.prototype.firstHitOnly}},Mn=e=>{I.interactiveMap[e.uuid]===void 0&&(I.interactiveObjects.push(e),I.interactiveMap[e.uuid]=e)},In=e=>{const t=I.interactiveObjects.indexOf(e);I.interactiveObjects.splice(t,1),delete I.interactiveMap[e.uuid]},En=()=>{const e=Oe(n=>Mn(n)),t=Ue(n=>In(n));return()=>{e(),t()}},Qt=e=>`${(e.eventObject||e.object).uuid}/${e.index}${e.instanceId}`,xe=[["click",!1],["contextmenu",!1],["dblclick",!1],["wheel",!1],["pointerdown",!0],["pointerup",!0],["pointerleave",!0],["pointerenter",!0],["pointermove",!0],["pointercancel",!0]],Cn=e=>{const t=e.offsetX-(I.initialClick[0]??0),n=e.offsetY-(I.initialClick[1]??0);return Math.round(Math.hypot(t,n))},qt=e=>{I.hovered.forEach(t=>{if(e.length===0||!e.some(n=>n.object===t.object&&n.index===t.index&&n.instanceId===t.instanceId)){const{eventObject:n}=t;I.hovered.delete(Qt(t)),n.dispatchEvent({type:"pointerout",...t,intersections:e}),n.dispatchEvent({type:"pointerleave",...t,intersections:e})}})},_n=()=>{const e=new Set,t=[];let n=I.raycaster.intersectObjects(I.interactiveObjects).sort((s,i)=>s.distance-i.distance).filter(s=>{const i=Qt(s);return e.has(i)?!1:(e.add(i),!0)});return I.filter&&(n=I.filter(n,I)),n.forEach(s=>{let i=s.object;for(;i;)t.push({...s,eventObject:i}),i=i.parent}),t},we=(e,t)=>{t.forEach(n=>{n.dispatchEvent({type:"pointermissed",event:e})})},be=e=>e==="pointerleave"||e==="pointercancel"?()=>{I.pointerOverTarget=!1,qt([])}:e==="pointerenter"?()=>{I.pointerOverTarget=!0}:t=>{const n=e==="pointermove",s=e==="click"||e==="contextmenu"||e==="dblclick";I.compute(t,I);const i=I.enabled?_n():[],r=s?Cn(t):0;e==="pointerdown"&&(I.initialClick=[t.offsetX,t.offsetY],I.initialHits=i.map(o=>o.eventObject)),s&&i.length===0&&r<=2&&we(t,I.interactiveObjects),n&&qt(i);let c=!1;const f=()=>{c=!0};for(let o=0,u=i.length;o<u;o+=1){const l=i[o],p={stopped:c,...l,intersections:i,stopPropagation(){f(),p.stopped=!0;const a=[...I.hovered.values()];if(I.hovered.size>0&&a.some(h=>h.eventObject===l.eventObject)){const h=i.slice(0,i.indexOf(l));qt([...h,l])}},camera:I.raycaster.camera,delta:r,nativeEvent:t,pointer:I.pointer,ray:I.raycaster.ray};if(n){const a=Qt(p),h=I.hovered.get(a);h?h.stopped&&p.stopPropagation():(I.hovered.set(a,p),l.eventObject.dispatchEvent({type:"pointerover",...p}),l.eventObject.dispatchEvent({type:"pointerenter",...p})),l.eventObject.dispatchEvent({type:"pointermove",...p})}else(!s||I.initialHits.includes(l.eventObject))&&(we(t,I.interactiveObjects.filter(a=>!I.initialHits.includes(a))),l.eventObject.dispatchEvent({type:e,...p}));if(c)break}},zn=()=>(xe.forEach(([e,t])=>{I.target.addEventListener(e,be(e),{passive:t})}),()=>{xe.forEach(([e])=>{I.target.removeEventListener(e,be(e))})}),Fn=e=>{I.camera=e.camera,I.enabled=e.enabled??!0,I.target=e.target,I.filter=e.filter,I.compute=e.compute??Ye();const t=En(),n=zn();return{context:I,dispose:()=>{t(),n()}}},Ln=e=>{const t=2*Math.PI*Math.random();return[e*Math.cos(t),e*Math.sin(t)]},Rn=e=>{e.traverse(t=>{const n="isMesh"in t,s="isLight"in t&&!("isAmbientLight"in t)&&!("isRectAreaLight"in t);t.castShadow=n||s,t.receiveShadow=n})},Dn=`
import * as THREE from 'three'
import { pointerEvents, useBvhRaycast } from 'trzy'

// Optionally install three-mesh-bvh
useBvhRaycast({ firstHitOnly: true })

pointerEvents({ target: canvas, camera })

const mesh = new THREE.Mesh(
  new THREE.BoxGeometry(),
  new THREE.MeshStandardMaterial()
)

// If using three-mesh-bvh
mesh.geometry.computeBoundsTree()

mesh.addEventListener('pointerenter', (event) => console.log(event))
mesh.addEventListener('pointerleave', (event) => console.log(event))
mesh.addEventListener('click', (event) => console.log(event))

mesh.addEventListener('pointerenter', (event) => {
  // Call stop propagation to stop events from firing on other intersections.
  event.stopPropagation()
})
`;function On(e){let t,n="Adds pointer events to all rendererable objects.",s,i,r,c,f;return i=new Ne({}),c=new Xe({props:{code:Dn}}),{c(){t=Ce("p"),t.textContent=n,s=te(),Ht(i.$$.fragment),r=te(),Ht(c.$$.fragment)},l(o){t=_e(o,"P",{"data-svelte-h":!0}),ze(t)!=="svelte-1y787p9"&&(t.textContent=n),s=ee(o),kt(i.$$.fragment,o),r=ee(o),kt(c.$$.fragment,o)},m(o,u){_t(o,t,u),_t(o,s,u),Nt(i,o,u),_t(o,r,u),Nt(c,o,u),f=!0},p:Me,i(o){f||(jt(i.$$.fragment,o),jt(c.$$.fragment,o),f=!0)},o(o){Xt(i.$$.fragment,o),Xt(c.$$.fragment,o),f=!1},d(o){o&&(zt(t),zt(s),zt(r)),Yt(i,o),Yt(c,o)}}}function Un(e){let t,n;return t=new je({props:{title:"pointerEvents",$$slots:{default:[On]},$$scope:{ctx:e}}}),{c(){Ht(t.$$.fragment)},l(s){kt(t.$$.fragment,s)},m(s,i){Nt(t,s,i),n=!0},p(s,[i]){const r={};i&1&&(r.$$scope={dirty:i,ctx:s}),t.$set(r)},i(s){n||(jt(t.$$.fragment,s),n=!0)},o(s){Xt(t.$$.fragment,s),n=!1},d(s){Yt(t,s)}}}function $n(e){return Se(()=>{const{scene:t,camera:n,renderer:s}=$e(),i=Sn({firstHitOnly:!0}),{dispose:r}=Fn({target:s.domElement,camera:n.current});Ve();const c=Array.from({length:100}).map(()=>{const o=new qe({color:"yellow"}),u=.1,l=He(o,u,u,u),[p,a]=Ln(1.5);return l.position.set(p,-.25,a),l.userData.rotation={y:(Math.random()-.5)*.1,z:(Math.random()-.5)*.1},l.addEventListener("pointerenter",h=>{h.stopPropagation(),o.color.set("hotpink")}),l.addEventListener("pointerleave",()=>o.color.set("yellow")),l.addEventListener("click",()=>o.color.set("blue")),l.geometry.computeBoundsTree(),l});t.add(...c),Rn(t);const{stop:f}=ke(()=>{c.forEach(o=>{o.rotation.y+=o.userData.rotation.y,o.rotation.z+=o.userData.rotation.z})});return()=>{f(),r(),c.forEach(o=>o.geometry.disposeBoundsTree()),i()}}),[]}class Nn extends Ie{constructor(t){super(),Ee(this,t,$n,Un,Be,{})}}export{Nn as component};
