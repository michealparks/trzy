import{s as k,o as z,n as P}from"../chunks/scheduler.b0c1c2c3.js";import{S as I,i as R,r as E,u as $,v as b,d as w,t as O,w as M,g as H,s as y,h as S,z as D,c as _,a as m,f as h}from"../chunks/index.f44ac6f0.js";import{e as n,f as T,g as A,u as F,s as X,c as Y,h as q,b as B,C as G}from"../chunks/setup.f6d951a4.js";import{D as J,C as K}from"../chunks/code.759f5f5e.js";const Q=()=>{let t=0,e=0;return new ResizeObserver(([s])=>{t=(s==null?void 0:s.contentRect.width)??0,e=(s==null?void 0:s.contentRect.height)??0}).observe(n.target),s=>{n.pointer.set(s.offsetX/t*2-1,-(s.offsetY/e*2)+1),n.raycaster.setFromCamera(n.pointer,n.camera)}},U=t=>{n.interactiveMap[t.uuid]===void 0&&(n.interactiveObjects.push(t),n.interactiveMap[t.uuid]=t)},V=t=>{const e=n.interactiveObjects.indexOf(t);n.interactiveObjects.splice(e,1),delete n.interactiveMap[t.uuid]},W=()=>{const t=T(r=>U(r)),e=A(r=>V(r));return()=>{t(),e()}},x=t=>`${(t.eventObject||t.object).uuid}/${t.index}${t.instanceId}`,C=[["click",!1],["contextmenu",!1],["dblclick",!1],["wheel",!1],["pointerdown",!0],["pointerup",!0],["pointerleave",!0],["pointerenter",!0],["pointermove",!0],["pointercancel",!0]],Z=t=>{const e=t.offsetX-(n.initialClick[0]??0),r=t.offsetY-(n.initialClick[1]??0);return Math.round(Math.hypot(e,r))},g=t=>{n.hovered.forEach(e=>{if(t.length===0||!t.some(r=>r.object===e.object&&r.index===e.index&&r.instanceId===e.instanceId)){const{eventObject:r}=e;n.hovered.delete(x(e)),r.dispatchEvent({type:"pointerout",...e,intersections:t}),r.dispatchEvent({type:"pointerleave",...e,intersections:t})}})},N=()=>{const t=new Set,e=[];let r=n.raycaster.intersectObjects(n.interactiveObjects).sort((s,o)=>s.distance-o.distance).filter(s=>{const o=x(s);return t.has(o)?!1:(t.add(o),!0)});return n.filter&&(r=n.filter(r,n)),r.forEach(s=>{let o=s.object;for(;o;)e.push({...s,eventObject:o}),o=o.parent}),e},j=(t,e)=>{e.forEach(r=>{r.dispatchEvent({type:"pointermissed",event:t})})},L=t=>t==="pointerleave"||t==="pointercancel"?()=>{n.pointerOverTarget=!1,g([])}:t==="pointerenter"?()=>{n.pointerOverTarget=!0}:e=>{const r=t==="pointermove",s=t==="click"||t==="contextmenu"||t==="dblclick";n.compute(e,n);const o=n.enabled?N():[],p=s?Z(e):0;t==="pointerdown"&&(n.initialClick=[e.offsetX,e.offsetY],n.initialHits=o.map(i=>i.eventObject)),s&&o.length===0&&p<=2&&j(e,n.interactiveObjects),r&&g(o);let l=!1;const a=()=>{l=!0};for(let i=0,c=o.length;i<c;i+=1){const d=o[i],u={stopped:l,...d,intersections:o,stopPropagation(){a(),u.stopped=!0;const f=[...n.hovered.values()];if(n.hovered.size>0&&f.some(v=>v.eventObject===d.eventObject)){const v=o.slice(0,o.indexOf(d));g([...v,d])}},camera:n.raycaster.camera,delta:p,nativeEvent:e,pointer:n.pointer,ray:n.raycaster.ray};if(r){const f=x(u),v=n.hovered.get(f);v?v.stopped&&u.stopPropagation():(n.hovered.set(f,u),d.eventObject.dispatchEvent({type:"pointerover",...u}),d.eventObject.dispatchEvent({type:"pointerenter",...u})),d.eventObject.dispatchEvent({type:"pointermove",...u})}else(!s||n.initialHits.includes(d.eventObject))&&(j(e,n.interactiveObjects.filter(f=>!n.initialHits.includes(f))),d.eventObject.dispatchEvent({type:t,...u}));if(l)break}},ee=()=>(C.forEach(([t,e])=>{n.target.addEventListener(t,L(t),{passive:e})}),()=>{C.forEach(([t])=>{n.target.removeEventListener(t,L(t))})}),te=t=>{n.camera=t.camera,n.enabled=t.enabled??!0,n.target=t.target,n.filter=t.filter,n.compute=t.compute??Q();const e=W(),r=ee();return{context:n,dispose:()=>{e(),r()}}},ne=t=>{const e=2*Math.PI*Math.random();return[t*Math.cos(e),t*Math.sin(e)]},se=t=>{t.traverse(e=>{const r="isMesh"in e,s="isLight"in e&&!("isAmbientLight"in e)&&!("isRectAreaLight"in e);e.castShadow=r||s,e.receiveShadow=r})},re=`
import * as THREE from 'three'
import { pointerEvents } from 'trzy'

pointerEvents({ target: canvas, camera })

const mesh = new THREE.Mesh(
  new THREE.BoxGeometry(),
  new THREE.MeshStandardMaterial()
)

mesh.addEventListener('pointerenter', (event) => console.log(event))
mesh.addEventListener('pointerleave', (event) => console.log(event))
mesh.addEventListener('click', (event) => console.log(event))

mesh.addEventListener('pointerenter', (event) => {
  // Call stop propagation to stop events from firing on other intersections.
  event.stopPropagation()
})
`;function oe(t){let e,r="Adds pointer events to all rendererable objects.",s,o,p,l,a;return o=new G({}),l=new K({props:{code:re}}),{c(){e=H("p"),e.textContent=r,s=y(),E(o.$$.fragment),p=y(),E(l.$$.fragment)},l(i){e=S(i,"P",{"data-svelte-h":!0}),D(e)!=="svelte-1y787p9"&&(e.textContent=r),s=_(i),$(o.$$.fragment,i),p=_(i),$(l.$$.fragment,i)},m(i,c){m(i,e,c),m(i,s,c),b(o,i,c),m(i,p,c),b(l,i,c),a=!0},p:P,i(i){a||(w(o.$$.fragment,i),w(l.$$.fragment,i),a=!0)},o(i){O(o.$$.fragment,i),O(l.$$.fragment,i),a=!1},d(i){i&&(h(e),h(s),h(p)),M(o,i),M(l,i)}}}function ie(t){let e,r;return e=new J({props:{title:"pointerEvents",$$slots:{default:[oe]},$$scope:{ctx:t}}}),{c(){E(e.$$.fragment)},l(s){$(e.$$.fragment,s)},m(s,o){b(e,s,o),r=!0},p(s,[o]){const p={};o&1&&(p.$$scope={dirty:o,ctx:s}),e.$set(p)},i(s){r||(w(e.$$.fragment,s),r=!0)},o(s){O(e.$$.fragment,s),r=!1},d(s){M(e,s)}}}function ae(t){return z(()=>{const{scene:e,camera:r,renderer:s}=F(),{dispose:o}=te({target:s.domElement,camera:r.current});X();const p=Array.from({length:100}).map(()=>{const a=new Y({color:"yellow"}),i=.1,c=q(a,i,i,i),[d,u]=ne(1.5);return c.position.set(d,-.25,u),c.userData.rotation={y:(Math.random()-.5)*.1,z:(Math.random()-.5)*.1},c.addEventListener("pointerenter",f=>{f.stopPropagation(),a.color.set("hotpink")}),c.addEventListener("pointerleave",()=>a.color.set("yellow")),c.addEventListener("click",()=>a.color.set("blue")),c});e.add(...p),se(e);const{stop:l}=B(()=>{p.forEach(a=>{a.rotation.y+=a.userData.rotation.y,a.rotation.z+=a.userData.rotation.z})});return()=>{l(),o()}}),[]}class ue extends I{constructor(e){super(),R(this,e,ae,ie,k,{})}}export{ue as component};
